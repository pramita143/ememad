"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sweetalert2";
exports.ids = ["vendor-chunks/sweetalert2"];
exports.modules = {

/***/ "(ssr)/./node_modules/sweetalert2/dist/sweetalert2.all.js":
/*!**********************************************************!*\
  !*** ./node_modules/sweetalert2/dist/sweetalert2.all.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\n/*!\n* sweetalert2 v11.7.1\n* Released under the MIT License.\n*/ (function(global, factory) {\n     true ? module.exports = factory() : 0;\n})(void 0, function() {\n    \"use strict\";\n    /**\n   * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n   * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n   * This is the approach that Babel will probably take to implement private methods/fields\n   *   https://github.com/tc39/proposal-private-methods\n   *   https://github.com/babel/babel/pull/7555\n   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n   *   then we can use that language feature.\n   */ var privateProps = {\n        awaitingPromise: new WeakMap(),\n        promise: new WeakMap(),\n        innerParams: new WeakMap(),\n        domCache: new WeakMap()\n    };\n    const swalPrefix = \"swal2-\";\n    /**\n   * @param {string[]} items\n   * @returns {object}\n   */ const prefix = (items)=>{\n        const result = {};\n        for(const i in items){\n            result[items[i]] = swalPrefix + items[i];\n        }\n        return result;\n    };\n    const swalClasses = prefix([\n        \"container\",\n        \"shown\",\n        \"height-auto\",\n        \"iosfix\",\n        \"popup\",\n        \"modal\",\n        \"no-backdrop\",\n        \"no-transition\",\n        \"toast\",\n        \"toast-shown\",\n        \"show\",\n        \"hide\",\n        \"close\",\n        \"title\",\n        \"html-container\",\n        \"actions\",\n        \"confirm\",\n        \"deny\",\n        \"cancel\",\n        \"default-outline\",\n        \"footer\",\n        \"icon\",\n        \"icon-content\",\n        \"image\",\n        \"input\",\n        \"file\",\n        \"range\",\n        \"select\",\n        \"radio\",\n        \"checkbox\",\n        \"label\",\n        \"textarea\",\n        \"inputerror\",\n        \"input-label\",\n        \"validation-message\",\n        \"progress-steps\",\n        \"active-progress-step\",\n        \"progress-step\",\n        \"progress-step-line\",\n        \"loader\",\n        \"loading\",\n        \"styled\",\n        \"top\",\n        \"top-start\",\n        \"top-end\",\n        \"top-left\",\n        \"top-right\",\n        \"center\",\n        \"center-start\",\n        \"center-end\",\n        \"center-left\",\n        \"center-right\",\n        \"bottom\",\n        \"bottom-start\",\n        \"bottom-end\",\n        \"bottom-left\",\n        \"bottom-right\",\n        \"grow-row\",\n        \"grow-column\",\n        \"grow-fullscreen\",\n        \"rtl\",\n        \"timer-progress-bar\",\n        \"timer-progress-bar-container\",\n        \"scrollbar-measure\",\n        \"icon-success\",\n        \"icon-warning\",\n        \"icon-info\",\n        \"icon-question\",\n        \"icon-error\"\n    ]);\n    const iconTypes = prefix([\n        \"success\",\n        \"warning\",\n        \"info\",\n        \"question\",\n        \"error\"\n    ]);\n    const consolePrefix = \"SweetAlert2:\";\n    /**\n   * Filter the unique values into a new array\n   *\n   * @param {Array} arr\n   * @returns {Array}\n   */ const uniqueArray = (arr)=>{\n        const result = [];\n        for(let i = 0; i < arr.length; i++){\n            if (result.indexOf(arr[i]) === -1) {\n                result.push(arr[i]);\n            }\n        }\n        return result;\n    };\n    /**\n   * Capitalize the first letter of a string\n   *\n   * @param {string} str\n   * @returns {string}\n   */ const capitalizeFirstLetter = (str)=>str.charAt(0).toUpperCase() + str.slice(1);\n    /**\n   * Standardize console warnings\n   *\n   * @param {string | Array} message\n   */ const warn = (message)=>{\n        console.warn(`${consolePrefix} ${typeof message === \"object\" ? message.join(\" \") : message}`);\n    };\n    /**\n   * Standardize console errors\n   *\n   * @param {string} message\n   */ const error = (message)=>{\n        console.error(`${consolePrefix} ${message}`);\n    };\n    /**\n   * Private global state for `warnOnce`\n   *\n   * @type {Array}\n   * @private\n   */ const previousWarnOnceMessages = [];\n    /**\n   * Show a console warning, but only if it hasn't already been shown\n   *\n   * @param {string} message\n   */ const warnOnce = (message)=>{\n        if (!previousWarnOnceMessages.includes(message)) {\n            previousWarnOnceMessages.push(message);\n            warn(message);\n        }\n    };\n    /**\n   * Show a one-time console warning about deprecated params/methods\n   *\n   * @param {string} deprecatedParam\n   * @param {string} useInstead\n   */ const warnAboutDeprecation = (deprecatedParam, useInstead)=>{\n        warnOnce(`\"${deprecatedParam}\" is deprecated and will be removed in the next major release. Please use \"${useInstead}\" instead.`);\n    };\n    /**\n   * If `arg` is a function, call it (with no arguments or context) and return the result.\n   * Otherwise, just pass the value through\n   *\n   * @param {Function | any} arg\n   * @returns {any}\n   */ const callIfFunction = (arg)=>typeof arg === \"function\" ? arg() : arg;\n    /**\n   * @param {any} arg\n   * @returns {boolean}\n   */ const hasToPromiseFn = (arg)=>arg && typeof arg.toPromise === \"function\";\n    /**\n   * @param {any} arg\n   * @returns {Promise}\n   */ const asPromise = (arg)=>hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);\n    /**\n   * @param {any} arg\n   * @returns {boolean}\n   */ const isPromise = (arg)=>arg && Promise.resolve(arg) === arg;\n    /**\n   * Gets the popup container which contains the backdrop and the popup itself.\n   *\n   * @returns {HTMLElement | null}\n   */ const getContainer = ()=>document.body.querySelector(`.${swalClasses.container}`);\n    /**\n   * @param {string} selectorString\n   * @returns {HTMLElement | null}\n   */ const elementBySelector = (selectorString)=>{\n        const container = getContainer();\n        return container ? container.querySelector(selectorString) : null;\n    };\n    /**\n   * @param {string} className\n   * @returns {HTMLElement | null}\n   */ const elementByClass = (className)=>{\n        return elementBySelector(`.${className}`);\n    };\n    /**\n   * @returns {HTMLElement | null}\n   */ const getPopup = ()=>elementByClass(swalClasses.popup);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getIcon = ()=>elementByClass(swalClasses.icon);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getIconContent = ()=>elementByClass(swalClasses[\"icon-content\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getTitle = ()=>elementByClass(swalClasses.title);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getHtmlContainer = ()=>elementByClass(swalClasses[\"html-container\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getImage = ()=>elementByClass(swalClasses.image);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getProgressSteps = ()=>elementByClass(swalClasses[\"progress-steps\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getValidationMessage = ()=>elementByClass(swalClasses[\"validation-message\"]);\n    /**\n   * @returns {HTMLButtonElement | null}\n   */ const getConfirmButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`);\n    /**\n   * @returns {HTMLButtonElement | null}\n   */ const getCancelButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`);\n    /**\n   * @returns {HTMLButtonElement | null}\n   */ const getDenyButton = ()=>/** @type {HTMLButtonElement} */ elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getInputLabel = ()=>elementByClass(swalClasses[\"input-label\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getLoader = ()=>elementBySelector(`.${swalClasses.loader}`);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getActions = ()=>elementByClass(swalClasses.actions);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getFooter = ()=>elementByClass(swalClasses.footer);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getTimerProgressBar = ()=>elementByClass(swalClasses[\"timer-progress-bar\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getCloseButton = ()=>elementByClass(swalClasses.close);\n    // https://github.com/jkup/focusable/blob/master/index.js\n    const focusable = `\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex=\"0\"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n`;\n    /**\n   * @returns {HTMLElement[]}\n   */ const getFocusableElements = ()=>{\n        const focusableElementsWithTabindex = Array.from(getPopup().querySelectorAll('[tabindex]:not([tabindex=\"-1\"]):not([tabindex=\"0\"])'))// sort according to tabindex\n        .sort((a, b)=>{\n            const tabindexA = parseInt(a.getAttribute(\"tabindex\"));\n            const tabindexB = parseInt(b.getAttribute(\"tabindex\"));\n            if (tabindexA > tabindexB) {\n                return 1;\n            } else if (tabindexA < tabindexB) {\n                return -1;\n            }\n            return 0;\n        });\n        const otherFocusableElements = Array.from(getPopup().querySelectorAll(focusable)).filter((el)=>el.getAttribute(\"tabindex\") !== \"-1\");\n        return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter((el)=>isVisible$1(el));\n    };\n    /**\n   * @returns {boolean}\n   */ const isModal = ()=>{\n        return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses[\"toast-shown\"]) && !hasClass(document.body, swalClasses[\"no-backdrop\"]);\n    };\n    /**\n   * @returns {boolean}\n   */ const isToast = ()=>{\n        return getPopup() && hasClass(getPopup(), swalClasses.toast);\n    };\n    /**\n   * @returns {boolean}\n   */ const isLoading = ()=>{\n        return getPopup().hasAttribute(\"data-loading\");\n    };\n    // Remember state in cases where opening and handling a modal will fiddle with it.\n    const states = {\n        previousBodyPadding: null\n    };\n    /**\n   * Securely set innerHTML of an element\n   * https://github.com/sweetalert2/sweetalert2/issues/1926\n   *\n   * @param {HTMLElement} elem\n   * @param {string} html\n   */ const setInnerHtml = (elem, html)=>{\n        elem.textContent = \"\";\n        if (html) {\n            const parser = new DOMParser();\n            const parsed = parser.parseFromString(html, `text/html`);\n            Array.from(parsed.querySelector(\"head\").childNodes).forEach((child)=>{\n                elem.appendChild(child);\n            });\n            Array.from(parsed.querySelector(\"body\").childNodes).forEach((child)=>{\n                if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {\n                    elem.appendChild(child.cloneNode(true)); // https://github.com/sweetalert2/sweetalert2/issues/2507\n                } else {\n                    elem.appendChild(child);\n                }\n            });\n        }\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {string} className\n   * @returns {boolean}\n   */ const hasClass = (elem, className)=>{\n        if (!className) {\n            return false;\n        }\n        const classList = className.split(/\\s+/);\n        for(let i = 0; i < classList.length; i++){\n            if (!elem.classList.contains(classList[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {SweetAlertOptions} params\n   */ const removeCustomClasses = (elem, params)=>{\n        Array.from(elem.classList).forEach((className)=>{\n            if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass).includes(className)) {\n                elem.classList.remove(className);\n            }\n        });\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {SweetAlertOptions} params\n   * @param {string} className\n   */ const applyCustomClass = (elem, params, className)=>{\n        removeCustomClasses(elem, params);\n        if (params.customClass && params.customClass[className]) {\n            if (typeof params.customClass[className] !== \"string\" && !params.customClass[className].forEach) {\n                warn(`Invalid type of customClass.${className}! Expected string or iterable object, got \"${typeof params.customClass[className]}\"`);\n                return;\n            }\n            addClass(elem, params.customClass[className]);\n        }\n    };\n    /**\n   * @param {HTMLElement} popup\n   * @param {import('./renderers/renderInput').InputClass} inputClass\n   * @returns {HTMLInputElement | null}\n   */ const getInput$1 = (popup, inputClass)=>{\n        if (!inputClass) {\n            return null;\n        }\n        switch(inputClass){\n            case \"select\":\n            case \"textarea\":\n            case \"file\":\n                return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);\n            case \"checkbox\":\n                return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);\n            case \"radio\":\n                return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);\n            case \"range\":\n                return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);\n            default:\n                return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);\n        }\n    };\n    /**\n   * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input\n   */ const focusInput = (input)=>{\n        input.focus();\n        // place cursor at end of text in text input\n        if (input.type !== \"file\") {\n            // http://stackoverflow.com/a/2345915\n            const val = input.value;\n            input.value = \"\";\n            input.value = val;\n        }\n    };\n    /**\n   * @param {HTMLElement | HTMLElement[] | null} target\n   * @param {string | string[] | readonly string[]} classList\n   * @param {boolean} condition\n   */ const toggleClass = (target, classList, condition)=>{\n        if (!target || !classList) {\n            return;\n        }\n        if (typeof classList === \"string\") {\n            classList = classList.split(/\\s+/).filter(Boolean);\n        }\n        classList.forEach((className)=>{\n            if (Array.isArray(target)) {\n                target.forEach((elem)=>{\n                    condition ? elem.classList.add(className) : elem.classList.remove(className);\n                });\n            } else {\n                condition ? target.classList.add(className) : target.classList.remove(className);\n            }\n        });\n    };\n    /**\n   * @param {HTMLElement | HTMLElement[] | null} target\n   * @param {string | string[] | readonly string[]} classList\n   */ const addClass = (target, classList)=>{\n        toggleClass(target, classList, true);\n    };\n    /**\n   * @param {HTMLElement | HTMLElement[] | null} target\n   * @param {string | string[] | readonly string[]} classList\n   */ const removeClass = (target, classList)=>{\n        toggleClass(target, classList, false);\n    };\n    /**\n   * Get direct child of an element by class name\n   *\n   * @param {HTMLElement} elem\n   * @param {string} className\n   * @returns {HTMLElement | undefined}\n   */ const getDirectChildByClass = (elem, className)=>{\n        const children = Array.from(elem.children);\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child instanceof HTMLElement && hasClass(child, className)) {\n                return child;\n            }\n        }\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {string} property\n   * @param {*} value\n   */ const applyNumericalStyle = (elem, property, value)=>{\n        if (value === `${parseInt(value)}`) {\n            value = parseInt(value);\n        }\n        if (value || parseInt(value) === 0) {\n            elem.style[property] = typeof value === \"number\" ? `${value}px` : value;\n        } else {\n            elem.style.removeProperty(property);\n        }\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {string} display\n   */ const show = function(elem) {\n        let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"flex\";\n        elem.style.display = display;\n    };\n    /**\n   * @param {HTMLElement} elem\n   */ const hide = (elem)=>{\n        elem.style.display = \"none\";\n    };\n    /**\n   * @param {HTMLElement} parent\n   * @param {string} selector\n   * @param {string} property\n   * @param {string} value\n   */ const setStyle = (parent, selector, property, value)=>{\n        /** @type {HTMLElement} */ const el = parent.querySelector(selector);\n        if (el) {\n            el.style[property] = value;\n        }\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {any} condition\n   * @param {string} display\n   */ const toggle = function(elem, condition) {\n        let display = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"flex\";\n        condition ? show(elem, display) : hide(elem);\n    };\n    /**\n   * borrowed from jquery $(elem).is(':visible') implementation\n   *\n   * @param {HTMLElement} elem\n   * @returns {boolean}\n   */ const isVisible$1 = (elem)=>!!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));\n    /**\n   * @returns {boolean}\n   */ const allButtonsAreHidden = ()=>!isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());\n    /**\n   * @param {HTMLElement} elem\n   * @returns {boolean}\n   */ const isScrollable = (elem)=>!!(elem.scrollHeight > elem.clientHeight);\n    /**\n   * borrowed from https://stackoverflow.com/a/46352119\n   *\n   * @param {HTMLElement} elem\n   * @returns {boolean}\n   */ const hasCssAnimation = (elem)=>{\n        const style = window.getComputedStyle(elem);\n        const animDuration = parseFloat(style.getPropertyValue(\"animation-duration\") || \"0\");\n        const transDuration = parseFloat(style.getPropertyValue(\"transition-duration\") || \"0\");\n        return animDuration > 0 || transDuration > 0;\n    };\n    /**\n   * @param {number} timer\n   * @param {boolean} reset\n   */ const animateTimerProgressBar = function(timer) {\n        let reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        const timerProgressBar = getTimerProgressBar();\n        if (isVisible$1(timerProgressBar)) {\n            if (reset) {\n                timerProgressBar.style.transition = \"none\";\n                timerProgressBar.style.width = \"100%\";\n            }\n            setTimeout(()=>{\n                timerProgressBar.style.transition = `width ${timer / 1000}s linear`;\n                timerProgressBar.style.width = \"0%\";\n            }, 10);\n        }\n    };\n    const stopTimerProgressBar = ()=>{\n        const timerProgressBar = getTimerProgressBar();\n        const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n        timerProgressBar.style.removeProperty(\"transition\");\n        timerProgressBar.style.width = \"100%\";\n        const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n        const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;\n        timerProgressBar.style.width = `${timerProgressBarPercent}%`;\n    };\n    const RESTORE_FOCUS_TIMEOUT = 100;\n    /** @type {GlobalState} */ const globalState = {};\n    const focusPreviousActiveElement = ()=>{\n        if (globalState.previousActiveElement instanceof HTMLElement) {\n            globalState.previousActiveElement.focus();\n            globalState.previousActiveElement = null;\n        } else if (document.body) {\n            document.body.focus();\n        }\n    };\n    /**\n   * Restore previous active (focused) element\n   *\n   * @param {boolean} returnFocus\n   * @returns {Promise}\n   */ const restoreActiveElement = (returnFocus)=>{\n        return new Promise((resolve)=>{\n            if (!returnFocus) {\n                return resolve();\n            }\n            const x = window.scrollX;\n            const y = window.scrollY;\n            globalState.restoreFocusTimeout = setTimeout(()=>{\n                focusPreviousActiveElement();\n                resolve();\n            }, RESTORE_FOCUS_TIMEOUT); // issues/900\n            window.scrollTo(x, y);\n        });\n    };\n    /**\n   * Detect Node env\n   *\n   * @returns {boolean}\n   */ const isNodeEnv = ()=> true || 0;\n    const sweetHTML = `\n <div aria-labelledby=\"${swalClasses.title}\" aria-describedby=\"${swalClasses[\"html-container\"]}\" class=\"${swalClasses.popup}\" tabindex=\"-1\">\n   <button type=\"button\" class=\"${swalClasses.close}\"></button>\n   <ul class=\"${swalClasses[\"progress-steps\"]}\"></ul>\n   <div class=\"${swalClasses.icon}\"></div>\n   <img class=\"${swalClasses.image}\" />\n   <h2 class=\"${swalClasses.title}\" id=\"${swalClasses.title}\"></h2>\n   <div class=\"${swalClasses[\"html-container\"]}\" id=\"${swalClasses[\"html-container\"]}\"></div>\n   <input class=\"${swalClasses.input}\" />\n   <input type=\"file\" class=\"${swalClasses.file}\" />\n   <div class=\"${swalClasses.range}\">\n     <input type=\"range\" />\n     <output></output>\n   </div>\n   <select class=\"${swalClasses.select}\"></select>\n   <div class=\"${swalClasses.radio}\"></div>\n   <label for=\"${swalClasses.checkbox}\" class=\"${swalClasses.checkbox}\">\n     <input type=\"checkbox\" />\n     <span class=\"${swalClasses.label}\"></span>\n   </label>\n   <textarea class=\"${swalClasses.textarea}\"></textarea>\n   <div class=\"${swalClasses[\"validation-message\"]}\" id=\"${swalClasses[\"validation-message\"]}\"></div>\n   <div class=\"${swalClasses.actions}\">\n     <div class=\"${swalClasses.loader}\"></div>\n     <button type=\"button\" class=\"${swalClasses.confirm}\"></button>\n     <button type=\"button\" class=\"${swalClasses.deny}\"></button>\n     <button type=\"button\" class=\"${swalClasses.cancel}\"></button>\n   </div>\n   <div class=\"${swalClasses.footer}\"></div>\n   <div class=\"${swalClasses[\"timer-progress-bar-container\"]}\">\n     <div class=\"${swalClasses[\"timer-progress-bar\"]}\"></div>\n   </div>\n </div>\n`.replace(/(^|\\n)\\s*/g, \"\");\n    /**\n   * @returns {boolean}\n   */ const resetOldContainer = ()=>{\n        const oldContainer = getContainer();\n        if (!oldContainer) {\n            return false;\n        }\n        oldContainer.remove();\n        removeClass([\n            document.documentElement,\n            document.body\n        ], [\n            swalClasses[\"no-backdrop\"],\n            swalClasses[\"toast-shown\"],\n            swalClasses[\"has-column\"]\n        ]);\n        return true;\n    };\n    const resetValidationMessage$1 = ()=>{\n        globalState.currentInstance.resetValidationMessage();\n    };\n    const addInputChangeListeners = ()=>{\n        const popup = getPopup();\n        const input = getDirectChildByClass(popup, swalClasses.input);\n        const file = getDirectChildByClass(popup, swalClasses.file);\n        /** @type {HTMLInputElement} */ const range = popup.querySelector(`.${swalClasses.range} input`);\n        /** @type {HTMLOutputElement} */ const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);\n        const select = getDirectChildByClass(popup, swalClasses.select);\n        /** @type {HTMLInputElement} */ const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);\n        const textarea = getDirectChildByClass(popup, swalClasses.textarea);\n        input.oninput = resetValidationMessage$1;\n        file.onchange = resetValidationMessage$1;\n        select.onchange = resetValidationMessage$1;\n        checkbox.onchange = resetValidationMessage$1;\n        textarea.oninput = resetValidationMessage$1;\n        range.oninput = ()=>{\n            resetValidationMessage$1();\n            rangeOutput.value = range.value;\n        };\n        range.onchange = ()=>{\n            resetValidationMessage$1();\n            rangeOutput.value = range.value;\n        };\n    };\n    /**\n   * @param {string | HTMLElement} target\n   * @returns {HTMLElement}\n   */ const getTarget = (target)=>typeof target === \"string\" ? document.querySelector(target) : target;\n    /**\n   * @param {SweetAlertOptions} params\n   */ const setupAccessibility = (params)=>{\n        const popup = getPopup();\n        popup.setAttribute(\"role\", params.toast ? \"alert\" : \"dialog\");\n        popup.setAttribute(\"aria-live\", params.toast ? \"polite\" : \"assertive\");\n        if (!params.toast) {\n            popup.setAttribute(\"aria-modal\", \"true\");\n        }\n    };\n    /**\n   * @param {HTMLElement} targetElement\n   */ const setupRTL = (targetElement)=>{\n        if (window.getComputedStyle(targetElement).direction === \"rtl\") {\n            addClass(getContainer(), swalClasses.rtl);\n        }\n    };\n    /**\n   * Add modal + backdrop + no-war message for Russians to DOM\n   *\n   * @param {SweetAlertOptions} params\n   */ const init = (params)=>{\n        // Clean up the old popup container if it exists\n        const oldContainerExisted = resetOldContainer();\n        /* istanbul ignore if */ if (isNodeEnv()) {\n            error(\"SweetAlert2 requires document to initialize\");\n            return;\n        }\n        const container = document.createElement(\"div\");\n        container.className = swalClasses.container;\n        if (oldContainerExisted) {\n            addClass(container, swalClasses[\"no-transition\"]);\n        }\n        setInnerHtml(container, sweetHTML);\n        const targetElement = getTarget(params.target);\n        targetElement.appendChild(container);\n        setupAccessibility(params);\n        setupRTL(targetElement);\n        addInputChangeListeners();\n    };\n    /**\n   * @param {HTMLElement | object | string} param\n   * @param {HTMLElement} target\n   */ const parseHtmlToContainer = (param, target)=>{\n        // DOM element\n        if (param instanceof HTMLElement) {\n            target.appendChild(param);\n        } else if (typeof param === \"object\") {\n            handleObject(param, target);\n        } else if (param) {\n            setInnerHtml(target, param);\n        }\n    };\n    /**\n   * @param {object} param\n   * @param {HTMLElement} target\n   */ const handleObject = (param, target)=>{\n        // JQuery element(s)\n        if (param.jquery) {\n            handleJqueryElem(target, param);\n        } else {\n            setInnerHtml(target, param.toString());\n        }\n    };\n    /**\n   * @param {HTMLElement} target\n   * @param {HTMLElement} elem\n   */ const handleJqueryElem = (target, elem)=>{\n        target.textContent = \"\";\n        if (0 in elem) {\n            for(let i = 0; (i in elem); i++){\n                target.appendChild(elem[i].cloneNode(true));\n            }\n        } else {\n            target.appendChild(elem.cloneNode(true));\n        }\n    };\n    /**\n   * @returns {'webkitAnimationEnd' | 'animationend' | false}\n   */ const animationEndEvent = (()=>{\n        // Prevent run in Node env\n        /* istanbul ignore if */ if (isNodeEnv()) {\n            return false;\n        }\n        const testEl = document.createElement(\"div\");\n        const transEndEventNames = {\n            WebkitAnimation: \"webkitAnimationEnd\",\n            // Chrome, Safari and Opera\n            animation: \"animationend\" // Standard syntax\n        };\n        for(const i in transEndEventNames){\n            if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== \"undefined\") {\n                return transEndEventNames[i];\n            }\n        }\n        return false;\n    })();\n    /**\n   * Measure scrollbar width for padding body during modal show/hide\n   * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js\n   *\n   * @returns {number}\n   */ const measureScrollbar = ()=>{\n        const scrollDiv = document.createElement(\"div\");\n        scrollDiv.className = swalClasses[\"scrollbar-measure\"];\n        document.body.appendChild(scrollDiv);\n        const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n        document.body.removeChild(scrollDiv);\n        return scrollbarWidth;\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderActions = (instance, params)=>{\n        const actions = getActions();\n        const loader = getLoader();\n        // Actions (buttons) wrapper\n        if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {\n            hide(actions);\n        } else {\n            show(actions);\n        }\n        // Custom class\n        applyCustomClass(actions, params, \"actions\");\n        // Render all the buttons\n        renderButtons(actions, loader, params);\n        // Loader\n        setInnerHtml(loader, params.loaderHtml);\n        applyCustomClass(loader, params, \"loader\");\n    };\n    /**\n   * @param {HTMLElement} actions\n   * @param {HTMLElement} loader\n   * @param {SweetAlertOptions} params\n   */ function renderButtons(actions, loader, params) {\n        const confirmButton = getConfirmButton();\n        const denyButton = getDenyButton();\n        const cancelButton = getCancelButton();\n        // Render buttons\n        renderButton(confirmButton, \"confirm\", params);\n        renderButton(denyButton, \"deny\", params);\n        renderButton(cancelButton, \"cancel\", params);\n        handleButtonsStyling(confirmButton, denyButton, cancelButton, params);\n        if (params.reverseButtons) {\n            if (params.toast) {\n                actions.insertBefore(cancelButton, confirmButton);\n                actions.insertBefore(denyButton, confirmButton);\n            } else {\n                actions.insertBefore(cancelButton, loader);\n                actions.insertBefore(denyButton, loader);\n                actions.insertBefore(confirmButton, loader);\n            }\n        }\n    }\n    /**\n   * @param {HTMLElement} confirmButton\n   * @param {HTMLElement} denyButton\n   * @param {HTMLElement} cancelButton\n   * @param {SweetAlertOptions} params\n   */ function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {\n        if (!params.buttonsStyling) {\n            removeClass([\n                confirmButton,\n                denyButton,\n                cancelButton\n            ], swalClasses.styled);\n            return;\n        }\n        addClass([\n            confirmButton,\n            denyButton,\n            cancelButton\n        ], swalClasses.styled);\n        // Buttons background colors\n        if (params.confirmButtonColor) {\n            confirmButton.style.backgroundColor = params.confirmButtonColor;\n            addClass(confirmButton, swalClasses[\"default-outline\"]);\n        }\n        if (params.denyButtonColor) {\n            denyButton.style.backgroundColor = params.denyButtonColor;\n            addClass(denyButton, swalClasses[\"default-outline\"]);\n        }\n        if (params.cancelButtonColor) {\n            cancelButton.style.backgroundColor = params.cancelButtonColor;\n            addClass(cancelButton, swalClasses[\"default-outline\"]);\n        }\n    }\n    /**\n   * @param {HTMLElement} button\n   * @param {'confirm' | 'deny' | 'cancel'} buttonType\n   * @param {SweetAlertOptions} params\n   */ function renderButton(button, buttonType, params) {\n        toggle(button, params[`show${capitalizeFirstLetter(buttonType)}Button`], \"inline-block\");\n        setInnerHtml(button, params[`${buttonType}ButtonText`]); // Set caption text\n        button.setAttribute(\"aria-label\", params[`${buttonType}ButtonAriaLabel`]); // ARIA label\n        // Add buttons custom classes\n        button.className = swalClasses[buttonType];\n        applyCustomClass(button, params, `${buttonType}Button`);\n        addClass(button, params[`${buttonType}ButtonClass`]);\n    }\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderCloseButton = (instance, params)=>{\n        const closeButton = getCloseButton();\n        setInnerHtml(closeButton, params.closeButtonHtml);\n        // Custom class\n        applyCustomClass(closeButton, params, \"closeButton\");\n        toggle(closeButton, params.showCloseButton);\n        closeButton.setAttribute(\"aria-label\", params.closeButtonAriaLabel);\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderContainer = (instance, params)=>{\n        const container = getContainer();\n        if (!container) {\n            return;\n        }\n        handleBackdropParam(container, params.backdrop);\n        handlePositionParam(container, params.position);\n        handleGrowParam(container, params.grow);\n        // Custom class\n        applyCustomClass(container, params, \"container\");\n    };\n    /**\n   * @param {HTMLElement} container\n   * @param {SweetAlertOptions['backdrop']} backdrop\n   */ function handleBackdropParam(container, backdrop) {\n        if (typeof backdrop === \"string\") {\n            container.style.background = backdrop;\n        } else if (!backdrop) {\n            addClass([\n                document.documentElement,\n                document.body\n            ], swalClasses[\"no-backdrop\"]);\n        }\n    }\n    /**\n   * @param {HTMLElement} container\n   * @param {SweetAlertOptions['position']} position\n   */ function handlePositionParam(container, position) {\n        if (position in swalClasses) {\n            addClass(container, swalClasses[position]);\n        } else {\n            warn('The \"position\" parameter is not valid, defaulting to \"center\"');\n            addClass(container, swalClasses.center);\n        }\n    }\n    /**\n   * @param {HTMLElement} container\n   * @param {SweetAlertOptions['grow']} grow\n   */ function handleGrowParam(container, grow) {\n        if (grow && typeof grow === \"string\") {\n            const growClass = `grow-${grow}`;\n            if (growClass in swalClasses) {\n                addClass(container, swalClasses[growClass]);\n            }\n        }\n    }\n    /// <reference path=\"../../../../sweetalert2.d.ts\"/>\n    /** @type {InputClass[]} */ const inputClasses = [\n        \"input\",\n        \"file\",\n        \"range\",\n        \"select\",\n        \"radio\",\n        \"checkbox\",\n        \"textarea\"\n    ];\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderInput = (instance, params)=>{\n        const popup = getPopup();\n        const innerParams = privateProps.innerParams.get(instance);\n        const rerender = !innerParams || params.input !== innerParams.input;\n        inputClasses.forEach((inputClass)=>{\n            const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);\n            // set attributes\n            setAttributes(inputClass, params.inputAttributes);\n            // set class\n            inputContainer.className = swalClasses[inputClass];\n            if (rerender) {\n                hide(inputContainer);\n            }\n        });\n        if (params.input) {\n            if (rerender) {\n                showInput(params);\n            }\n            // set custom class\n            setCustomClass(params);\n        }\n    };\n    /**\n   * @param {SweetAlertOptions} params\n   */ const showInput = (params)=>{\n        if (!renderInputType[params.input]) {\n            error(`Unexpected type of input! Expected \"text\", \"email\", \"password\", \"number\", \"tel\", \"select\", \"radio\", \"checkbox\", \"textarea\", \"file\" or \"url\", got \"${params.input}\"`);\n            return;\n        }\n        const inputContainer = getInputContainer(params.input);\n        const input = renderInputType[params.input](inputContainer, params);\n        show(inputContainer);\n        // input autofocus\n        if (params.inputAutoFocus) {\n            setTimeout(()=>{\n                focusInput(input);\n            });\n        }\n    };\n    /**\n   * @param {HTMLInputElement} input\n   */ const removeAttributes = (input)=>{\n        for(let i = 0; i < input.attributes.length; i++){\n            const attrName = input.attributes[i].name;\n            if (![\n                \"type\",\n                \"value\",\n                \"style\"\n            ].includes(attrName)) {\n                input.removeAttribute(attrName);\n            }\n        }\n    };\n    /**\n   * @param {InputClass} inputClass\n   * @param {SweetAlertOptions['inputAttributes']} inputAttributes\n   */ const setAttributes = (inputClass, inputAttributes)=>{\n        const input = getInput$1(getPopup(), inputClass);\n        if (!input) {\n            return;\n        }\n        removeAttributes(input);\n        for(const attr in inputAttributes){\n            input.setAttribute(attr, inputAttributes[attr]);\n        }\n    };\n    /**\n   * @param {SweetAlertOptions} params\n   */ const setCustomClass = (params)=>{\n        const inputContainer = getInputContainer(params.input);\n        if (typeof params.customClass === \"object\") {\n            addClass(inputContainer, params.customClass.input);\n        }\n    };\n    /**\n   * @param {HTMLInputElement | HTMLTextAreaElement} input\n   * @param {SweetAlertOptions} params\n   */ const setInputPlaceholder = (input, params)=>{\n        if (!input.placeholder || params.inputPlaceholder) {\n            input.placeholder = params.inputPlaceholder;\n        }\n    };\n    /**\n   * @param {Input} input\n   * @param {Input} prependTo\n   * @param {SweetAlertOptions} params\n   */ const setInputLabel = (input, prependTo, params)=>{\n        if (params.inputLabel) {\n            input.id = swalClasses.input;\n            const label = document.createElement(\"label\");\n            const labelClass = swalClasses[\"input-label\"];\n            label.setAttribute(\"for\", input.id);\n            label.className = labelClass;\n            if (typeof params.customClass === \"object\") {\n                addClass(label, params.customClass.inputLabel);\n            }\n            label.innerText = params.inputLabel;\n            prependTo.insertAdjacentElement(\"beforebegin\", label);\n        }\n    };\n    /**\n   * @param {SweetAlertOptions['input']} inputType\n   * @returns {HTMLElement}\n   */ const getInputContainer = (inputType)=>{\n        return getDirectChildByClass(getPopup(), swalClasses[inputType] || swalClasses.input);\n    };\n    /**\n   * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input\n   * @param {SweetAlertOptions['inputValue']} inputValue\n   */ const checkAndSetInputValue = (input, inputValue)=>{\n        if ([\n            \"string\",\n            \"number\"\n        ].includes(typeof inputValue)) {\n            input.value = `${inputValue}`;\n        } else if (!isPromise(inputValue)) {\n            warn(`Unexpected type of inputValue! Expected \"string\", \"number\" or \"Promise\", got \"${typeof inputValue}\"`);\n        }\n    };\n    /** @type {Record<string, (input: Input | HTMLElement, params: SweetAlertOptions) => Input>} */ const renderInputType = {};\n    /**\n   * @param {HTMLInputElement} input\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */ renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = (input, params)=>{\n        checkAndSetInputValue(input, params.inputValue);\n        setInputLabel(input, input, params);\n        setInputPlaceholder(input, params);\n        input.type = params.input;\n        return input;\n    };\n    /**\n   * @param {HTMLInputElement} input\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */ renderInputType.file = (input, params)=>{\n        setInputLabel(input, input, params);\n        setInputPlaceholder(input, params);\n        return input;\n    };\n    /**\n   * @param {HTMLInputElement} range\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */ renderInputType.range = (range, params)=>{\n        const rangeInput = range.querySelector(\"input\");\n        const rangeOutput = range.querySelector(\"output\");\n        checkAndSetInputValue(rangeInput, params.inputValue);\n        rangeInput.type = params.input;\n        checkAndSetInputValue(rangeOutput, params.inputValue);\n        setInputLabel(rangeInput, range, params);\n        return range;\n    };\n    /**\n   * @param {HTMLSelectElement} select\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLSelectElement}\n   */ renderInputType.select = (select, params)=>{\n        select.textContent = \"\";\n        if (params.inputPlaceholder) {\n            const placeholder = document.createElement(\"option\");\n            setInnerHtml(placeholder, params.inputPlaceholder);\n            placeholder.value = \"\";\n            placeholder.disabled = true;\n            placeholder.selected = true;\n            select.appendChild(placeholder);\n        }\n        setInputLabel(select, select, params);\n        return select;\n    };\n    /**\n   * @param {HTMLInputElement} radio\n   * @returns {HTMLInputElement}\n   */ renderInputType.radio = (radio)=>{\n        radio.textContent = \"\";\n        return radio;\n    };\n    /**\n   * @param {HTMLLabelElement} checkboxContainer\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */ renderInputType.checkbox = (checkboxContainer, params)=>{\n        const checkbox = getInput$1(getPopup(), \"checkbox\");\n        checkbox.value = \"1\";\n        checkbox.id = swalClasses.checkbox;\n        checkbox.checked = Boolean(params.inputValue);\n        const label = checkboxContainer.querySelector(\"span\");\n        setInnerHtml(label, params.inputPlaceholder);\n        return checkbox;\n    };\n    /**\n   * @param {HTMLTextAreaElement} textarea\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLTextAreaElement}\n   */ renderInputType.textarea = (textarea, params)=>{\n        checkAndSetInputValue(textarea, params.inputValue);\n        setInputPlaceholder(textarea, params);\n        setInputLabel(textarea, textarea, params);\n        /**\n     * @param {HTMLElement} el\n     * @returns {number}\n     */ const getMargin = (el)=>parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);\n        // https://github.com/sweetalert2/sweetalert2/issues/2291\n        setTimeout(()=>{\n            // https://github.com/sweetalert2/sweetalert2/issues/1699\n            if (\"MutationObserver\" in window) {\n                const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);\n                const textareaResizeHandler = ()=>{\n                    const textareaWidth = textarea.offsetWidth + getMargin(textarea);\n                    if (textareaWidth > initialPopupWidth) {\n                        getPopup().style.width = `${textareaWidth}px`;\n                    } else {\n                        getPopup().style.width = null;\n                    }\n                };\n                new MutationObserver(textareaResizeHandler).observe(textarea, {\n                    attributes: true,\n                    attributeFilter: [\n                        \"style\"\n                    ]\n                });\n            }\n        });\n        return textarea;\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderContent = (instance, params)=>{\n        const htmlContainer = getHtmlContainer();\n        applyCustomClass(htmlContainer, params, \"htmlContainer\");\n        // Content as HTML\n        if (params.html) {\n            parseHtmlToContainer(params.html, htmlContainer);\n            show(htmlContainer, \"block\");\n        } else if (params.text) {\n            htmlContainer.textContent = params.text;\n            show(htmlContainer, \"block\");\n        } else {\n            hide(htmlContainer);\n        }\n        renderInput(instance, params);\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderFooter = (instance, params)=>{\n        const footer = getFooter();\n        toggle(footer, params.footer);\n        if (params.footer) {\n            parseHtmlToContainer(params.footer, footer);\n        }\n        // Custom class\n        applyCustomClass(footer, params, \"footer\");\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderIcon = (instance, params)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        const icon = getIcon();\n        // if the given icon already rendered, apply the styling without re-rendering the icon\n        if (innerParams && params.icon === innerParams.icon) {\n            // Custom or default content\n            setContent(icon, params);\n            applyStyles(icon, params);\n            return;\n        }\n        if (!params.icon && !params.iconHtml) {\n            hide(icon);\n            return;\n        }\n        if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {\n            error(`Unknown icon! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"${params.icon}\"`);\n            hide(icon);\n            return;\n        }\n        show(icon);\n        // Custom or default content\n        setContent(icon, params);\n        applyStyles(icon, params);\n        // Animate icon\n        addClass(icon, params.showClass.icon);\n    };\n    /**\n   * @param {HTMLElement} icon\n   * @param {SweetAlertOptions} params\n   */ const applyStyles = (icon, params)=>{\n        for(const iconType in iconTypes){\n            if (params.icon !== iconType) {\n                removeClass(icon, iconTypes[iconType]);\n            }\n        }\n        addClass(icon, iconTypes[params.icon]);\n        // Icon color\n        setColor(icon, params);\n        // Success icon background color\n        adjustSuccessIconBackgroundColor();\n        // Custom class\n        applyCustomClass(icon, params, \"icon\");\n    };\n    // Adjust success icon background color to match the popup background color\n    const adjustSuccessIconBackgroundColor = ()=>{\n        const popup = getPopup();\n        const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue(\"background-color\");\n        /** @type {NodeListOf<HTMLElement>} */ const successIconParts = popup.querySelectorAll(\"[class^=swal2-success-circular-line], .swal2-success-fix\");\n        for(let i = 0; i < successIconParts.length; i++){\n            successIconParts[i].style.backgroundColor = popupBackgroundColor;\n        }\n    };\n    const successIconHtml = `\n  <div class=\"swal2-success-circular-line-left\"></div>\n  <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n  <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\n  <div class=\"swal2-success-circular-line-right\"></div>\n`;\n    const errorIconHtml = `\n  <span class=\"swal2-x-mark\">\n    <span class=\"swal2-x-mark-line-left\"></span>\n    <span class=\"swal2-x-mark-line-right\"></span>\n  </span>\n`;\n    /**\n   * @param {HTMLElement} icon\n   * @param {SweetAlertOptions} params\n   */ const setContent = (icon, params)=>{\n        let oldContent = icon.innerHTML;\n        let newContent;\n        if (params.iconHtml) {\n            newContent = iconContent(params.iconHtml);\n        } else if (params.icon === \"success\") {\n            newContent = successIconHtml;\n            oldContent = oldContent.replace(/ style=\".*?\"/g, \"\"); // undo adjustSuccessIconBackgroundColor()\n        } else if (params.icon === \"error\") {\n            newContent = errorIconHtml;\n        } else {\n            const defaultIconHtml = {\n                question: \"?\",\n                warning: \"!\",\n                info: \"i\"\n            };\n            newContent = iconContent(defaultIconHtml[params.icon]);\n        }\n        if (oldContent.trim() !== newContent.trim()) {\n            setInnerHtml(icon, newContent);\n        }\n    };\n    /**\n   * @param {HTMLElement} icon\n   * @param {SweetAlertOptions} params\n   */ const setColor = (icon, params)=>{\n        if (!params.iconColor) {\n            return;\n        }\n        icon.style.color = params.iconColor;\n        icon.style.borderColor = params.iconColor;\n        for (const sel of [\n            \".swal2-success-line-tip\",\n            \".swal2-success-line-long\",\n            \".swal2-x-mark-line-left\",\n            \".swal2-x-mark-line-right\"\n        ]){\n            setStyle(icon, sel, \"backgroundColor\", params.iconColor);\n        }\n        setStyle(icon, \".swal2-success-ring\", \"borderColor\", params.iconColor);\n    };\n    /**\n   * @param {string} content\n   * @returns {string}\n   */ const iconContent = (content)=>`<div class=\"${swalClasses[\"icon-content\"]}\">${content}</div>`;\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderImage = (instance, params)=>{\n        const image = getImage();\n        if (!params.imageUrl) {\n            hide(image);\n            return;\n        }\n        show(image, \"\");\n        // Src, alt\n        image.setAttribute(\"src\", params.imageUrl);\n        image.setAttribute(\"alt\", params.imageAlt);\n        // Width, height\n        applyNumericalStyle(image, \"width\", params.imageWidth);\n        applyNumericalStyle(image, \"height\", params.imageHeight);\n        // Class\n        image.className = swalClasses.image;\n        applyCustomClass(image, params, \"image\");\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderPopup = (instance, params)=>{\n        const container = getContainer();\n        const popup = getPopup();\n        // Width\n        // https://github.com/sweetalert2/sweetalert2/issues/2170\n        if (params.toast) {\n            applyNumericalStyle(container, \"width\", params.width);\n            popup.style.width = \"100%\";\n            popup.insertBefore(getLoader(), getIcon());\n        } else {\n            applyNumericalStyle(popup, \"width\", params.width);\n        }\n        // Padding\n        applyNumericalStyle(popup, \"padding\", params.padding);\n        // Color\n        if (params.color) {\n            popup.style.color = params.color;\n        }\n        // Background\n        if (params.background) {\n            popup.style.background = params.background;\n        }\n        hide(getValidationMessage());\n        // Classes\n        addClasses$1(popup, params);\n    };\n    /**\n   * @param {HTMLElement} popup\n   * @param {SweetAlertOptions} params\n   */ const addClasses$1 = (popup, params)=>{\n        // Default Class + showClass when updating Swal.update({})\n        popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? params.showClass.popup : \"\"}`;\n        if (params.toast) {\n            addClass([\n                document.documentElement,\n                document.body\n            ], swalClasses[\"toast-shown\"]);\n            addClass(popup, swalClasses.toast);\n        } else {\n            addClass(popup, swalClasses.modal);\n        }\n        // Custom class\n        applyCustomClass(popup, params, \"popup\");\n        if (typeof params.customClass === \"string\") {\n            addClass(popup, params.customClass);\n        }\n        // Icon class (#1842)\n        if (params.icon) {\n            addClass(popup, swalClasses[`icon-${params.icon}`]);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderProgressSteps = (instance, params)=>{\n        const progressStepsContainer = getProgressSteps();\n        if (!params.progressSteps || params.progressSteps.length === 0) {\n            hide(progressStepsContainer);\n            return;\n        }\n        show(progressStepsContainer);\n        progressStepsContainer.textContent = \"\";\n        if (params.currentProgressStep >= params.progressSteps.length) {\n            warn(\"Invalid currentProgressStep parameter, it should be less than progressSteps.length \" + \"(currentProgressStep like JS arrays starts from 0)\");\n        }\n        params.progressSteps.forEach((step, index)=>{\n            const stepEl = createStepElement(step);\n            progressStepsContainer.appendChild(stepEl);\n            if (index === params.currentProgressStep) {\n                addClass(stepEl, swalClasses[\"active-progress-step\"]);\n            }\n            if (index !== params.progressSteps.length - 1) {\n                const lineEl = createLineElement(params);\n                progressStepsContainer.appendChild(lineEl);\n            }\n        });\n    };\n    /**\n   * @param {string} step\n   * @returns {HTMLLIElement}\n   */ const createStepElement = (step)=>{\n        const stepEl = document.createElement(\"li\");\n        addClass(stepEl, swalClasses[\"progress-step\"]);\n        setInnerHtml(stepEl, step);\n        return stepEl;\n    };\n    /**\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLLIElement}\n   */ const createLineElement = (params)=>{\n        const lineEl = document.createElement(\"li\");\n        addClass(lineEl, swalClasses[\"progress-step-line\"]);\n        if (params.progressStepsDistance) {\n            applyNumericalStyle(lineEl, \"width\", params.progressStepsDistance);\n        }\n        return lineEl;\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderTitle = (instance, params)=>{\n        const title = getTitle();\n        toggle(title, params.title || params.titleText, \"block\");\n        if (params.title) {\n            parseHtmlToContainer(params.title, title);\n        }\n        if (params.titleText) {\n            title.innerText = params.titleText;\n        }\n        // Custom class\n        applyCustomClass(title, params, \"title\");\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const render = (instance, params)=>{\n        renderPopup(instance, params);\n        renderContainer(instance, params);\n        renderProgressSteps(instance, params);\n        renderIcon(instance, params);\n        renderImage(instance, params);\n        renderTitle(instance, params);\n        renderCloseButton(instance, params);\n        renderContent(instance, params);\n        renderActions(instance, params);\n        renderFooter(instance, params);\n        if (typeof params.didRender === \"function\") {\n            params.didRender(getPopup());\n        }\n    };\n    /**\n   * Hides loader and shows back the button which was hidden by .showLoading()\n   */ function hideLoading() {\n        // do nothing if popup is closed\n        const innerParams = privateProps.innerParams.get(this);\n        if (!innerParams) {\n            return;\n        }\n        const domCache = privateProps.domCache.get(this);\n        hide(domCache.loader);\n        if (isToast()) {\n            if (innerParams.icon) {\n                show(getIcon());\n            }\n        } else {\n            showRelatedButton(domCache);\n        }\n        removeClass([\n            domCache.popup,\n            domCache.actions\n        ], swalClasses.loading);\n        domCache.popup.removeAttribute(\"aria-busy\");\n        domCache.popup.removeAttribute(\"data-loading\");\n        domCache.confirmButton.disabled = false;\n        domCache.denyButton.disabled = false;\n        domCache.cancelButton.disabled = false;\n    }\n    const showRelatedButton = (domCache)=>{\n        const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute(\"data-button-to-replace\"));\n        if (buttonToReplace.length) {\n            show(buttonToReplace[0], \"inline-block\");\n        } else if (allButtonsAreHidden()) {\n            hide(domCache.actions);\n        }\n    };\n    /**\n   * Gets the input DOM node, this method works with input parameter.\n   *\n   * @param {SweetAlert2} instance\n   * @returns {HTMLElement | null}\n   */ function getInput(instance) {\n        const innerParams = privateProps.innerParams.get(instance || this);\n        const domCache = privateProps.domCache.get(instance || this);\n        if (!domCache) {\n            return null;\n        }\n        return getInput$1(domCache.popup, innerParams.input);\n    }\n    /*\n   * Global function to determine if SweetAlert2 popup is shown\n   */ const isVisible = ()=>{\n        return isVisible$1(getPopup());\n    };\n    /*\n   * Global function to click 'Confirm' button\n   */ const clickConfirm = ()=>getConfirmButton() && getConfirmButton().click();\n    /*\n   * Global function to click 'Deny' button\n   */ const clickDeny = ()=>getDenyButton() && getDenyButton().click();\n    /*\n   * Global function to click 'Cancel' button\n   */ const clickCancel = ()=>getCancelButton() && getCancelButton().click();\n    const DismissReason = Object.freeze({\n        cancel: \"cancel\",\n        backdrop: \"backdrop\",\n        close: \"close\",\n        esc: \"esc\",\n        timer: \"timer\"\n    });\n    /**\n   * @param {GlobalState} globalState\n   */ const removeKeydownHandler = (globalState)=>{\n        if (globalState.keydownTarget && globalState.keydownHandlerAdded) {\n            globalState.keydownTarget.removeEventListener(\"keydown\", globalState.keydownHandler, {\n                capture: globalState.keydownListenerCapture\n            });\n            globalState.keydownHandlerAdded = false;\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {GlobalState} globalState\n   * @param {SweetAlertOptions} innerParams\n   * @param {*} dismissWith\n   */ const addKeydownHandler = (instance, globalState, innerParams, dismissWith)=>{\n        removeKeydownHandler(globalState);\n        if (!innerParams.toast) {\n            globalState.keydownHandler = (e)=>keydownHandler(instance, e, dismissWith);\n            globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();\n            globalState.keydownListenerCapture = innerParams.keydownListenerCapture;\n            globalState.keydownTarget.addEventListener(\"keydown\", globalState.keydownHandler, {\n                capture: globalState.keydownListenerCapture\n            });\n            globalState.keydownHandlerAdded = true;\n        }\n    };\n    /**\n   * @param {number} index\n   * @param {number} increment\n   */ const setFocus = (index, increment)=>{\n        const focusableElements = getFocusableElements();\n        // search for visible elements and select the next possible match\n        if (focusableElements.length) {\n            index = index + increment;\n            // rollover to first item\n            if (index === focusableElements.length) {\n                index = 0;\n            // go to last item\n            } else if (index === -1) {\n                index = focusableElements.length - 1;\n            }\n            focusableElements[index].focus();\n            return;\n        }\n        // no visible focusable elements, focus the popup\n        getPopup().focus();\n    };\n    const arrowKeysNextButton = [\n        \"ArrowRight\",\n        \"ArrowDown\"\n    ];\n    const arrowKeysPreviousButton = [\n        \"ArrowLeft\",\n        \"ArrowUp\"\n    ];\n    /**\n   * @param {SweetAlert2} instance\n   * @param {KeyboardEvent} event\n   * @param {Function} dismissWith\n   */ const keydownHandler = (instance, event, dismissWith)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        if (!innerParams) {\n            return; // This instance has already been destroyed\n        }\n        // Ignore keydown during IME composition\n        // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition\n        // https://github.com/sweetalert2/sweetalert2/issues/720\n        // https://github.com/sweetalert2/sweetalert2/issues/2406\n        if (event.isComposing || event.keyCode === 229) {\n            return;\n        }\n        if (innerParams.stopKeydownPropagation) {\n            event.stopPropagation();\n        }\n        // ENTER\n        if (event.key === \"Enter\") {\n            handleEnter(instance, event, innerParams);\n        } else if (event.key === \"Tab\") {\n            handleTab(event);\n        } else if ([\n            ...arrowKeysNextButton,\n            ...arrowKeysPreviousButton\n        ].includes(event.key)) {\n            handleArrows(event.key);\n        } else if (event.key === \"Escape\") {\n            handleEsc(event, innerParams, dismissWith);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {KeyboardEvent} event\n   * @param {SweetAlertOptions} innerParams\n   */ const handleEnter = (instance, event, innerParams)=>{\n        // https://github.com/sweetalert2/sweetalert2/issues/2386\n        if (!callIfFunction(innerParams.allowEnterKey)) {\n            return;\n        }\n        if (event.target && instance.getInput() && event.target instanceof HTMLElement && event.target.outerHTML === instance.getInput().outerHTML) {\n            if ([\n                \"textarea\",\n                \"file\"\n            ].includes(innerParams.input)) {\n                return; // do not submit\n            }\n            clickConfirm();\n            event.preventDefault();\n        }\n    };\n    /**\n   * @param {KeyboardEvent} event\n   */ const handleTab = (event)=>{\n        const targetElement = event.target;\n        const focusableElements = getFocusableElements();\n        let btnIndex = -1;\n        for(let i = 0; i < focusableElements.length; i++){\n            if (targetElement === focusableElements[i]) {\n                btnIndex = i;\n                break;\n            }\n        }\n        // Cycle to the next button\n        if (!event.shiftKey) {\n            setFocus(btnIndex, 1);\n        } else {\n            setFocus(btnIndex, -1);\n        }\n        event.stopPropagation();\n        event.preventDefault();\n    };\n    /**\n   * @param {string} key\n   */ const handleArrows = (key)=>{\n        const confirmButton = getConfirmButton();\n        const denyButton = getDenyButton();\n        const cancelButton = getCancelButton();\n        /** @type HTMLElement[] */ const buttons = [\n            confirmButton,\n            denyButton,\n            cancelButton\n        ];\n        if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {\n            return;\n        }\n        const sibling = arrowKeysNextButton.includes(key) ? \"nextElementSibling\" : \"previousElementSibling\";\n        let buttonToFocus = document.activeElement;\n        for(let i = 0; i < getActions().children.length; i++){\n            buttonToFocus = buttonToFocus[sibling];\n            if (!buttonToFocus) {\n                return;\n            }\n            if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {\n                break;\n            }\n        }\n        if (buttonToFocus instanceof HTMLButtonElement) {\n            buttonToFocus.focus();\n        }\n    };\n    /**\n   * @param {KeyboardEvent} event\n   * @param {SweetAlertOptions} innerParams\n   * @param {Function} dismissWith\n   */ const handleEsc = (event, innerParams, dismissWith)=>{\n        if (callIfFunction(innerParams.allowEscapeKey)) {\n            event.preventDefault();\n            dismissWith(DismissReason.esc);\n        }\n    };\n    /**\n   * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n   * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n   * This is the approach that Babel will probably take to implement private methods/fields\n   *   https://github.com/tc39/proposal-private-methods\n   *   https://github.com/babel/babel/pull/7555\n   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n   *   then we can use that language feature.\n   */ var privateMethods = {\n        swalPromiseResolve: new WeakMap(),\n        swalPromiseReject: new WeakMap()\n    };\n    // From https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/\n    // Adding aria-hidden=\"true\" to elements outside of the active modal dialog ensures that\n    // elements not within the active modal dialog will not be surfaced if a user opens a screen\n    // reader’s list of elements (headings, form controls, landmarks, etc.) in the document.\n    const setAriaHidden = ()=>{\n        const bodyChildren = Array.from(document.body.children);\n        bodyChildren.forEach((el)=>{\n            if (el === getContainer() || el.contains(getContainer())) {\n                return;\n            }\n            if (el.hasAttribute(\"aria-hidden\")) {\n                el.setAttribute(\"data-previous-aria-hidden\", el.getAttribute(\"aria-hidden\"));\n            }\n            el.setAttribute(\"aria-hidden\", \"true\");\n        });\n    };\n    const unsetAriaHidden = ()=>{\n        const bodyChildren = Array.from(document.body.children);\n        bodyChildren.forEach((el)=>{\n            if (el.hasAttribute(\"data-previous-aria-hidden\")) {\n                el.setAttribute(\"aria-hidden\", el.getAttribute(\"data-previous-aria-hidden\"));\n                el.removeAttribute(\"data-previous-aria-hidden\");\n            } else {\n                el.removeAttribute(\"aria-hidden\");\n            }\n        });\n    };\n    /* istanbul ignore file */ // Fix iOS scrolling http://stackoverflow.com/q/39626302\n    const iOSfix = ()=>{\n        const iOS = // @ts-ignore\n        /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 1;\n        if (iOS && !hasClass(document.body, swalClasses.iosfix)) {\n            const offset = document.body.scrollTop;\n            document.body.style.top = `${offset * -1}px`;\n            addClass(document.body, swalClasses.iosfix);\n            lockBodyScroll();\n            addBottomPaddingForTallPopups();\n        }\n    };\n    /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1948\n   */ const addBottomPaddingForTallPopups = ()=>{\n        const ua = navigator.userAgent;\n        const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);\n        const webkit = !!ua.match(/WebKit/i);\n        const iOSSafari = iOS && webkit && !ua.match(/CriOS/i);\n        if (iOSSafari) {\n            const bottomPanelHeight = 44;\n            if (getPopup().scrollHeight > window.innerHeight - bottomPanelHeight) {\n                getContainer().style.paddingBottom = `${bottomPanelHeight}px`;\n            }\n        }\n    };\n    /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1246\n   */ const lockBodyScroll = ()=>{\n        const container = getContainer();\n        let preventTouchMove;\n        /**\n     * @param {TouchEvent} event\n     */ container.ontouchstart = (event)=>{\n            preventTouchMove = shouldPreventTouchMove(event);\n        };\n        /**\n     * @param {TouchEvent} event\n     */ container.ontouchmove = (event)=>{\n            if (preventTouchMove) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        };\n    };\n    /**\n   * @param {TouchEvent} event\n   * @returns {boolean}\n   */ const shouldPreventTouchMove = (event)=>{\n        const target = event.target;\n        const container = getContainer();\n        if (isStylus(event) || isZoom(event)) {\n            return false;\n        }\n        if (target === container) {\n            return true;\n        }\n        if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== \"INPUT\" && // #1603\n        target.tagName !== \"TEXTAREA\" && // #2266\n        !(isScrollable(getHtmlContainer()) && // #1944\n        getHtmlContainer().contains(target))) {\n            return true;\n        }\n        return false;\n    };\n    /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1786\n   *\n   * @param {*} event\n   * @returns {boolean}\n   */ const isStylus = (event)=>{\n        return event.touches && event.touches.length && event.touches[0].touchType === \"stylus\";\n    };\n    /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1891\n   *\n   * @param {TouchEvent} event\n   * @returns {boolean}\n   */ const isZoom = (event)=>{\n        return event.touches && event.touches.length > 1;\n    };\n    const undoIOSfix = ()=>{\n        if (hasClass(document.body, swalClasses.iosfix)) {\n            const offset = parseInt(document.body.style.top, 10);\n            removeClass(document.body, swalClasses.iosfix);\n            document.body.style.top = \"\";\n            document.body.scrollTop = offset * -1;\n        }\n    };\n    const fixScrollbar = ()=>{\n        // for queues, do not do this more than once\n        if (states.previousBodyPadding !== null) {\n            return;\n        }\n        // if the body has overflow\n        if (document.body.scrollHeight > window.innerHeight) {\n            // add padding so the content doesn't shift after removal of scrollbar\n            states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue(\"padding-right\"));\n            document.body.style.paddingRight = `${states.previousBodyPadding + measureScrollbar()}px`;\n        }\n    };\n    const undoScrollbar = ()=>{\n        if (states.previousBodyPadding !== null) {\n            document.body.style.paddingRight = `${states.previousBodyPadding}px`;\n            states.previousBodyPadding = null;\n        }\n    };\n    /*\n   * Instance method to close sweetAlert\n   */ function removePopupAndResetState(instance, container, returnFocus, didClose) {\n        if (isToast()) {\n            triggerDidCloseAndDispose(instance, didClose);\n        } else {\n            restoreActiveElement(returnFocus).then(()=>triggerDidCloseAndDispose(instance, didClose));\n            removeKeydownHandler(globalState);\n        }\n        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n        // workaround for #2088\n        // for some reason removing the container in Safari will scroll the document to bottom\n        if (isSafari) {\n            container.setAttribute(\"style\", \"display:none !important\");\n            container.removeAttribute(\"class\");\n            container.innerHTML = \"\";\n        } else {\n            container.remove();\n        }\n        if (isModal()) {\n            undoScrollbar();\n            undoIOSfix();\n            unsetAriaHidden();\n        }\n        removeBodyClasses();\n    }\n    function removeBodyClasses() {\n        removeClass([\n            document.documentElement,\n            document.body\n        ], [\n            swalClasses.shown,\n            swalClasses[\"height-auto\"],\n            swalClasses[\"no-backdrop\"],\n            swalClasses[\"toast-shown\"]\n        ]);\n    }\n    function close(resolveValue) {\n        resolveValue = prepareResolveValue(resolveValue);\n        const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);\n        const didClose = triggerClosePopup(this);\n        if (this.isAwaitingPromise()) {\n            // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335\n            if (!resolveValue.isDismissed) {\n                handleAwaitingPromise(this);\n                swalPromiseResolve(resolveValue);\n            }\n        } else if (didClose) {\n            // Resolve Swal promise\n            swalPromiseResolve(resolveValue);\n        }\n    }\n    function isAwaitingPromise() {\n        return !!privateProps.awaitingPromise.get(this);\n    }\n    const triggerClosePopup = (instance)=>{\n        const popup = getPopup();\n        if (!popup) {\n            return false;\n        }\n        const innerParams = privateProps.innerParams.get(instance);\n        if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {\n            return false;\n        }\n        removeClass(popup, innerParams.showClass.popup);\n        addClass(popup, innerParams.hideClass.popup);\n        const backdrop = getContainer();\n        removeClass(backdrop, innerParams.showClass.backdrop);\n        addClass(backdrop, innerParams.hideClass.backdrop);\n        handlePopupAnimation(instance, popup, innerParams);\n        return true;\n    };\n    function rejectPromise(error) {\n        const rejectPromise = privateMethods.swalPromiseReject.get(this);\n        handleAwaitingPromise(this);\n        if (rejectPromise) {\n            // Reject Swal promise\n            rejectPromise(error);\n        }\n    }\n    const handleAwaitingPromise = (instance)=>{\n        if (instance.isAwaitingPromise()) {\n            privateProps.awaitingPromise.delete(instance);\n            // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335\n            if (!privateProps.innerParams.get(instance)) {\n                instance._destroy();\n            }\n        }\n    };\n    const prepareResolveValue = (resolveValue)=>{\n        // When user calls Swal.close()\n        if (typeof resolveValue === \"undefined\") {\n            return {\n                isConfirmed: false,\n                isDenied: false,\n                isDismissed: true\n            };\n        }\n        return Object.assign({\n            isConfirmed: false,\n            isDenied: false,\n            isDismissed: false\n        }, resolveValue);\n    };\n    const handlePopupAnimation = (instance, popup, innerParams)=>{\n        const container = getContainer();\n        // If animation is supported, animate\n        const animationIsSupported = animationEndEvent && hasCssAnimation(popup);\n        if (typeof innerParams.willClose === \"function\") {\n            innerParams.willClose(popup);\n        }\n        if (animationIsSupported) {\n            animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);\n        } else {\n            // Otherwise, remove immediately\n            removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);\n        }\n    };\n    const animatePopup = (instance, popup, container, returnFocus, didClose)=>{\n        globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);\n        popup.addEventListener(animationEndEvent, function(e) {\n            if (e.target === popup) {\n                globalState.swalCloseEventFinishedCallback();\n                delete globalState.swalCloseEventFinishedCallback;\n            }\n        });\n    };\n    const triggerDidCloseAndDispose = (instance, didClose)=>{\n        setTimeout(()=>{\n            if (typeof didClose === \"function\") {\n                didClose.bind(instance.params)();\n            }\n            instance._destroy();\n        });\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {string[]} buttons\n   * @param {boolean} disabled\n   */ function setButtonsDisabled(instance, buttons, disabled) {\n        const domCache = privateProps.domCache.get(instance);\n        buttons.forEach((button)=>{\n            domCache[button].disabled = disabled;\n        });\n    }\n    /**\n   * @param {HTMLInputElement} input\n   * @param {boolean} disabled\n   */ function setInputDisabled(input, disabled) {\n        if (!input) {\n            return;\n        }\n        if (input.type === \"radio\") {\n            const radiosContainer = input.parentNode.parentNode;\n            const radios = radiosContainer.querySelectorAll(\"input\");\n            for(let i = 0; i < radios.length; i++){\n                radios[i].disabled = disabled;\n            }\n        } else {\n            input.disabled = disabled;\n        }\n    }\n    function enableButtons() {\n        setButtonsDisabled(this, [\n            \"confirmButton\",\n            \"denyButton\",\n            \"cancelButton\"\n        ], false);\n    }\n    function disableButtons() {\n        setButtonsDisabled(this, [\n            \"confirmButton\",\n            \"denyButton\",\n            \"cancelButton\"\n        ], true);\n    }\n    function enableInput() {\n        setInputDisabled(this.getInput(), false);\n    }\n    function disableInput() {\n        setInputDisabled(this.getInput(), true);\n    }\n    /**\n   * Show block with validation message\n   *\n   * @param {string} error\n   */ function showValidationMessage(error) {\n        const domCache = privateProps.domCache.get(this);\n        const params = privateProps.innerParams.get(this);\n        setInnerHtml(domCache.validationMessage, error);\n        domCache.validationMessage.className = swalClasses[\"validation-message\"];\n        if (params.customClass && params.customClass.validationMessage) {\n            addClass(domCache.validationMessage, params.customClass.validationMessage);\n        }\n        show(domCache.validationMessage);\n        const input = this.getInput();\n        if (input) {\n            input.setAttribute(\"aria-invalid\", true);\n            input.setAttribute(\"aria-describedby\", swalClasses[\"validation-message\"]);\n            focusInput(input);\n            addClass(input, swalClasses.inputerror);\n        }\n    }\n    /**\n   * Hide block with validation message\n   */ function resetValidationMessage() {\n        const domCache = privateProps.domCache.get(this);\n        if (domCache.validationMessage) {\n            hide(domCache.validationMessage);\n        }\n        const input = this.getInput();\n        if (input) {\n            input.removeAttribute(\"aria-invalid\");\n            input.removeAttribute(\"aria-describedby\");\n            removeClass(input, swalClasses.inputerror);\n        }\n    }\n    const defaultParams = {\n        title: \"\",\n        titleText: \"\",\n        text: \"\",\n        html: \"\",\n        footer: \"\",\n        icon: undefined,\n        iconColor: undefined,\n        iconHtml: undefined,\n        template: undefined,\n        toast: false,\n        showClass: {\n            popup: \"swal2-show\",\n            backdrop: \"swal2-backdrop-show\",\n            icon: \"swal2-icon-show\"\n        },\n        hideClass: {\n            popup: \"swal2-hide\",\n            backdrop: \"swal2-backdrop-hide\",\n            icon: \"swal2-icon-hide\"\n        },\n        customClass: {},\n        target: \"body\",\n        color: undefined,\n        backdrop: true,\n        heightAuto: true,\n        allowOutsideClick: true,\n        allowEscapeKey: true,\n        allowEnterKey: true,\n        stopKeydownPropagation: true,\n        keydownListenerCapture: false,\n        showConfirmButton: true,\n        showDenyButton: false,\n        showCancelButton: false,\n        preConfirm: undefined,\n        preDeny: undefined,\n        confirmButtonText: \"OK\",\n        confirmButtonAriaLabel: \"\",\n        confirmButtonColor: undefined,\n        denyButtonText: \"No\",\n        denyButtonAriaLabel: \"\",\n        denyButtonColor: undefined,\n        cancelButtonText: \"Cancel\",\n        cancelButtonAriaLabel: \"\",\n        cancelButtonColor: undefined,\n        buttonsStyling: true,\n        reverseButtons: false,\n        focusConfirm: true,\n        focusDeny: false,\n        focusCancel: false,\n        returnFocus: true,\n        showCloseButton: false,\n        closeButtonHtml: \"&times;\",\n        closeButtonAriaLabel: \"Close this dialog\",\n        loaderHtml: \"\",\n        showLoaderOnConfirm: false,\n        showLoaderOnDeny: false,\n        imageUrl: undefined,\n        imageWidth: undefined,\n        imageHeight: undefined,\n        imageAlt: \"\",\n        timer: undefined,\n        timerProgressBar: false,\n        width: undefined,\n        padding: undefined,\n        background: undefined,\n        input: undefined,\n        inputPlaceholder: \"\",\n        inputLabel: \"\",\n        inputValue: \"\",\n        inputOptions: {},\n        inputAutoFocus: true,\n        inputAutoTrim: true,\n        inputAttributes: {},\n        inputValidator: undefined,\n        returnInputValueOnDeny: false,\n        validationMessage: undefined,\n        grow: false,\n        position: \"center\",\n        progressSteps: [],\n        currentProgressStep: undefined,\n        progressStepsDistance: undefined,\n        willOpen: undefined,\n        didOpen: undefined,\n        didRender: undefined,\n        willClose: undefined,\n        didClose: undefined,\n        didDestroy: undefined,\n        scrollbarPadding: true\n    };\n    const updatableParams = [\n        \"allowEscapeKey\",\n        \"allowOutsideClick\",\n        \"background\",\n        \"buttonsStyling\",\n        \"cancelButtonAriaLabel\",\n        \"cancelButtonColor\",\n        \"cancelButtonText\",\n        \"closeButtonAriaLabel\",\n        \"closeButtonHtml\",\n        \"color\",\n        \"confirmButtonAriaLabel\",\n        \"confirmButtonColor\",\n        \"confirmButtonText\",\n        \"currentProgressStep\",\n        \"customClass\",\n        \"denyButtonAriaLabel\",\n        \"denyButtonColor\",\n        \"denyButtonText\",\n        \"didClose\",\n        \"didDestroy\",\n        \"footer\",\n        \"hideClass\",\n        \"html\",\n        \"icon\",\n        \"iconColor\",\n        \"iconHtml\",\n        \"imageAlt\",\n        \"imageHeight\",\n        \"imageUrl\",\n        \"imageWidth\",\n        \"preConfirm\",\n        \"preDeny\",\n        \"progressSteps\",\n        \"returnFocus\",\n        \"reverseButtons\",\n        \"showCancelButton\",\n        \"showCloseButton\",\n        \"showConfirmButton\",\n        \"showDenyButton\",\n        \"text\",\n        \"title\",\n        \"titleText\",\n        \"willClose\"\n    ];\n    const deprecatedParams = {};\n    const toastIncompatibleParams = [\n        \"allowOutsideClick\",\n        \"allowEnterKey\",\n        \"backdrop\",\n        \"focusConfirm\",\n        \"focusDeny\",\n        \"focusCancel\",\n        \"returnFocus\",\n        \"heightAuto\",\n        \"keydownListenerCapture\"\n    ];\n    /**\n   * Is valid parameter\n   *\n   * @param {string} paramName\n   * @returns {boolean}\n   */ const isValidParameter = (paramName)=>{\n        return Object.prototype.hasOwnProperty.call(defaultParams, paramName);\n    };\n    /**\n   * Is valid parameter for Swal.update() method\n   *\n   * @param {string} paramName\n   * @returns {boolean}\n   */ const isUpdatableParameter = (paramName)=>{\n        return updatableParams.indexOf(paramName) !== -1;\n    };\n    /**\n   * Is deprecated parameter\n   *\n   * @param {string} paramName\n   * @returns {string | undefined}\n   */ const isDeprecatedParameter = (paramName)=>{\n        return deprecatedParams[paramName];\n    };\n    /**\n   * @param {string} param\n   */ const checkIfParamIsValid = (param)=>{\n        if (!isValidParameter(param)) {\n            warn(`Unknown parameter \"${param}\"`);\n        }\n    };\n    /**\n   * @param {string} param\n   */ const checkIfToastParamIsValid = (param)=>{\n        if (toastIncompatibleParams.includes(param)) {\n            warn(`The parameter \"${param}\" is incompatible with toasts`);\n        }\n    };\n    /**\n   * @param {string} param\n   */ const checkIfParamIsDeprecated = (param)=>{\n        if (isDeprecatedParameter(param)) {\n            warnAboutDeprecation(param, isDeprecatedParameter(param));\n        }\n    };\n    /**\n   * Show relevant warnings for given params\n   *\n   * @param {SweetAlertOptions} params\n   */ const showWarningsForParams = (params)=>{\n        if (params.backdrop === false && params.allowOutsideClick) {\n            warn('\"allowOutsideClick\" parameter requires `backdrop` parameter to be set to `true`');\n        }\n        for(const param in params){\n            checkIfParamIsValid(param);\n            if (params.toast) {\n                checkIfToastParamIsValid(param);\n            }\n            checkIfParamIsDeprecated(param);\n        }\n    };\n    /**\n   * Updates popup parameters.\n   *\n   * @param {SweetAlertOptions} params\n   */ function update(params) {\n        const popup = getPopup();\n        const innerParams = privateProps.innerParams.get(this);\n        if (!popup || hasClass(popup, innerParams.hideClass.popup)) {\n            warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);\n            return;\n        }\n        const validUpdatableParams = filterValidParams(params);\n        const updatedParams = Object.assign({}, innerParams, validUpdatableParams);\n        render(this, updatedParams);\n        privateProps.innerParams.set(this, updatedParams);\n        Object.defineProperties(this, {\n            params: {\n                value: Object.assign({}, this.params, params),\n                writable: false,\n                enumerable: true\n            }\n        });\n    }\n    /**\n   * @param {SweetAlertOptions} params\n   * @returns {SweetAlertOptions}\n   */ const filterValidParams = (params)=>{\n        const validUpdatableParams = {};\n        Object.keys(params).forEach((param)=>{\n            if (isUpdatableParameter(param)) {\n                validUpdatableParams[param] = params[param];\n            } else {\n                warn(`Invalid parameter to update: ${param}`);\n            }\n        });\n        return validUpdatableParams;\n    };\n    /**\n   * Dispose the current SweetAlert2 instance\n   */ function _destroy() {\n        const domCache = privateProps.domCache.get(this);\n        const innerParams = privateProps.innerParams.get(this);\n        if (!innerParams) {\n            disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335\n            return; // This instance has already been destroyed\n        }\n        // Check if there is another Swal closing\n        if (domCache.popup && globalState.swalCloseEventFinishedCallback) {\n            globalState.swalCloseEventFinishedCallback();\n            delete globalState.swalCloseEventFinishedCallback;\n        }\n        if (typeof innerParams.didDestroy === \"function\") {\n            innerParams.didDestroy();\n        }\n        disposeSwal(this);\n    }\n    /**\n   * @param {SweetAlert2} instance\n   */ const disposeSwal = (instance)=>{\n        disposeWeakMaps(instance);\n        // Unset this.params so GC will dispose it (#1569)\n        // @ts-ignore\n        delete instance.params;\n        // Unset globalState props so GC will dispose globalState (#1569)\n        delete globalState.keydownHandler;\n        delete globalState.keydownTarget;\n        // Unset currentInstance\n        delete globalState.currentInstance;\n    };\n    /**\n   * @param {SweetAlert2} instance\n   */ const disposeWeakMaps = (instance)=>{\n        // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335\n        // @ts-ignore\n        if (instance.isAwaitingPromise()) {\n            unsetWeakMaps(privateProps, instance);\n            privateProps.awaitingPromise.set(instance, true);\n        } else {\n            unsetWeakMaps(privateMethods, instance);\n            unsetWeakMaps(privateProps, instance);\n        }\n    };\n    /**\n   * @param {object} obj\n   * @param {SweetAlert2} instance\n   */ const unsetWeakMaps = (obj, instance)=>{\n        for(const i in obj){\n            obj[i].delete(instance);\n        }\n    };\n    var instanceMethods = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        hideLoading: hideLoading,\n        disableLoading: hideLoading,\n        getInput: getInput,\n        close: close,\n        isAwaitingPromise: isAwaitingPromise,\n        rejectPromise: rejectPromise,\n        handleAwaitingPromise: handleAwaitingPromise,\n        closePopup: close,\n        closeModal: close,\n        closeToast: close,\n        enableButtons: enableButtons,\n        disableButtons: disableButtons,\n        enableInput: enableInput,\n        disableInput: disableInput,\n        showValidationMessage: showValidationMessage,\n        resetValidationMessage: resetValidationMessage,\n        update: update,\n        _destroy: _destroy\n    });\n    /**\n   * Shows loader (spinner), this is useful with AJAX requests.\n   * By default the loader be shown instead of the \"Confirm\" button.\n   *\n   * @param {HTMLButtonElement} [buttonToReplace]\n   */ const showLoading = (buttonToReplace)=>{\n        let popup = getPopup();\n        if (!popup) {\n            new Swal(); // eslint-disable-line no-new\n        }\n        popup = getPopup();\n        const loader = getLoader();\n        if (isToast()) {\n            hide(getIcon());\n        } else {\n            replaceButton(popup, buttonToReplace);\n        }\n        show(loader);\n        popup.setAttribute(\"data-loading\", \"true\");\n        popup.setAttribute(\"aria-busy\", \"true\");\n        popup.focus();\n    };\n    /**\n   * @param {HTMLElement} popup\n   * @param {HTMLButtonElement} [buttonToReplace]\n   */ const replaceButton = (popup, buttonToReplace)=>{\n        const actions = getActions();\n        const loader = getLoader();\n        if (!buttonToReplace && isVisible$1(getConfirmButton())) {\n            buttonToReplace = getConfirmButton();\n        }\n        show(actions);\n        if (buttonToReplace) {\n            hide(buttonToReplace);\n            loader.setAttribute(\"data-button-to-replace\", buttonToReplace.className);\n        }\n        loader.parentNode.insertBefore(loader, buttonToReplace);\n        addClass([\n            popup,\n            actions\n        ], swalClasses.loading);\n    };\n    /**\n   * @typedef { string | number | boolean } InputValue\n   */ /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const handleInputOptionsAndValue = (instance, params)=>{\n        if (params.input === \"select\" || params.input === \"radio\") {\n            handleInputOptions(instance, params);\n        } else if ([\n            \"text\",\n            \"email\",\n            \"number\",\n            \"tel\",\n            \"textarea\"\n        ].includes(params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {\n            showLoading(getConfirmButton());\n            handleInputValue(instance, params);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} innerParams\n   * @returns {string | number | File | FileList | null}\n   */ const getInputValue = (instance, innerParams)=>{\n        const input = instance.getInput();\n        if (!input) {\n            return null;\n        }\n        switch(innerParams.input){\n            case \"checkbox\":\n                return getCheckboxValue(input);\n            case \"radio\":\n                return getRadioValue(input);\n            case \"file\":\n                return getFileValue(input);\n            default:\n                return innerParams.inputAutoTrim ? input.value.trim() : input.value;\n        }\n    };\n    /**\n   * @param {HTMLInputElement} input\n   * @returns {number}\n   */ const getCheckboxValue = (input)=>input.checked ? 1 : 0;\n    /**\n   * @param {HTMLInputElement} input\n   * @returns {string | null}\n   */ const getRadioValue = (input)=>input.checked ? input.value : null;\n    /**\n   * @param {HTMLInputElement} input\n   * @returns {FileList | File | null}\n   */ const getFileValue = (input)=>input.files.length ? input.getAttribute(\"multiple\") !== null ? input.files : input.files[0] : null;\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const handleInputOptions = (instance, params)=>{\n        const popup = getPopup();\n        /**\n     * @param {Record<string, any>} inputOptions\n     */ const processInputOptions = (inputOptions)=>{\n            populateInputOptions[params.input](popup, formatInputOptions(inputOptions), params);\n        };\n        if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {\n            showLoading(getConfirmButton());\n            asPromise(params.inputOptions).then((inputOptions)=>{\n                instance.hideLoading();\n                processInputOptions(inputOptions);\n            });\n        } else if (typeof params.inputOptions === \"object\") {\n            processInputOptions(params.inputOptions);\n        } else {\n            error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const handleInputValue = (instance, params)=>{\n        const input = instance.getInput();\n        hide(input);\n        asPromise(params.inputValue).then((inputValue)=>{\n            input.value = params.input === \"number\" ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;\n            show(input);\n            input.focus();\n            instance.hideLoading();\n        }).catch((err)=>{\n            error(`Error in inputValue promise: ${err}`);\n            input.value = \"\";\n            show(input);\n            input.focus();\n            instance.hideLoading();\n        });\n    };\n    const populateInputOptions = {\n        /**\n     * @param {HTMLElement} popup\n     * @param {Record<string, any>} inputOptions\n     * @param {SweetAlertOptions} params\n     */ select: (popup, inputOptions, params)=>{\n            const select = getDirectChildByClass(popup, swalClasses.select);\n            /**\n       * @param {HTMLElement} parent\n       * @param {string} optionLabel\n       * @param {string} optionValue\n       */ const renderOption = (parent, optionLabel, optionValue)=>{\n                const option = document.createElement(\"option\");\n                option.value = optionValue;\n                setInnerHtml(option, optionLabel);\n                option.selected = isSelected(optionValue, params.inputValue);\n                parent.appendChild(option);\n            };\n            inputOptions.forEach((inputOption)=>{\n                const optionValue = inputOption[0];\n                const optionLabel = inputOption[1];\n                // <optgroup> spec:\n                // https://www.w3.org/TR/html401/interact/forms.html#h-17.6\n                // \"...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)...\"\n                // check whether this is a <optgroup>\n                if (Array.isArray(optionLabel)) {\n                    // if it is an array, then it is an <optgroup>\n                    const optgroup = document.createElement(\"optgroup\");\n                    optgroup.label = optionValue;\n                    optgroup.disabled = false; // not configurable for now\n                    select.appendChild(optgroup);\n                    optionLabel.forEach((o)=>renderOption(optgroup, o[1], o[0]));\n                } else {\n                    // case of <option>\n                    renderOption(select, optionLabel, optionValue);\n                }\n            });\n            select.focus();\n        },\n        /**\n     * @param {HTMLElement} popup\n     * @param {Record<string, any>} inputOptions\n     * @param {SweetAlertOptions} params\n     */ radio: (popup, inputOptions, params)=>{\n            const radio = getDirectChildByClass(popup, swalClasses.radio);\n            inputOptions.forEach((inputOption)=>{\n                const radioValue = inputOption[0];\n                const radioLabel = inputOption[1];\n                const radioInput = document.createElement(\"input\");\n                const radioLabelElement = document.createElement(\"label\");\n                radioInput.type = \"radio\";\n                radioInput.name = swalClasses.radio;\n                radioInput.value = radioValue;\n                if (isSelected(radioValue, params.inputValue)) {\n                    radioInput.checked = true;\n                }\n                const label = document.createElement(\"span\");\n                setInnerHtml(label, radioLabel);\n                label.className = swalClasses.label;\n                radioLabelElement.appendChild(radioInput);\n                radioLabelElement.appendChild(label);\n                radio.appendChild(radioLabelElement);\n            });\n            const radios = radio.querySelectorAll(\"input\");\n            if (radios.length) {\n                radios[0].focus();\n            }\n        }\n    };\n    /**\n   * Converts `inputOptions` into an array of `[value, label]`s\n   *\n   * @param {Record<string, any>} inputOptions\n   * @returns {Array<Array<string>>}\n   */ const formatInputOptions = (inputOptions)=>{\n        const result = [];\n        if (typeof Map !== \"undefined\" && inputOptions instanceof Map) {\n            inputOptions.forEach((value, key)=>{\n                let valueFormatted = value;\n                if (typeof valueFormatted === \"object\") {\n                    // case of <optgroup>\n                    valueFormatted = formatInputOptions(valueFormatted);\n                }\n                result.push([\n                    key,\n                    valueFormatted\n                ]);\n            });\n        } else {\n            Object.keys(inputOptions).forEach((key)=>{\n                let valueFormatted = inputOptions[key];\n                if (typeof valueFormatted === \"object\") {\n                    // case of <optgroup>\n                    valueFormatted = formatInputOptions(valueFormatted);\n                }\n                result.push([\n                    key,\n                    valueFormatted\n                ]);\n            });\n        }\n        return result;\n    };\n    /**\n   * @param {string} optionValue\n   * @param {InputValue | Promise<InputValue> | { toPromise: () => InputValue }} inputValue\n   * @returns {boolean}\n   */ const isSelected = (optionValue, inputValue)=>{\n        return inputValue && inputValue.toString() === optionValue.toString();\n    };\n    /**\n   * @param {SweetAlert2} instance\n   */ const handleConfirmButtonClick = (instance)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        instance.disableButtons();\n        if (innerParams.input) {\n            handleConfirmOrDenyWithInput(instance, \"confirm\");\n        } else {\n            confirm(instance, true);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   */ const handleDenyButtonClick = (instance)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        instance.disableButtons();\n        if (innerParams.returnInputValueOnDeny) {\n            handleConfirmOrDenyWithInput(instance, \"deny\");\n        } else {\n            deny(instance, false);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {Function} dismissWith\n   */ const handleCancelButtonClick = (instance, dismissWith)=>{\n        instance.disableButtons();\n        dismissWith(DismissReason.cancel);\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {'confirm' | 'deny'} type\n   */ const handleConfirmOrDenyWithInput = (instance, type)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        if (!innerParams.input) {\n            error(`The \"input\" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);\n            return;\n        }\n        const inputValue = getInputValue(instance, innerParams);\n        if (innerParams.inputValidator) {\n            handleInputValidator(instance, inputValue, type);\n        } else if (!instance.getInput().checkValidity()) {\n            instance.enableButtons();\n            instance.showValidationMessage(innerParams.validationMessage);\n        } else if (type === \"deny\") {\n            deny(instance, inputValue);\n        } else {\n            confirm(instance, inputValue);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {string | number | File | FileList | null} inputValue\n   * @param {'confirm' | 'deny'} type\n   */ const handleInputValidator = (instance, inputValue, type)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        instance.disableInput();\n        const validationPromise = Promise.resolve().then(()=>asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));\n        validationPromise.then((validationMessage)=>{\n            instance.enableButtons();\n            instance.enableInput();\n            if (validationMessage) {\n                instance.showValidationMessage(validationMessage);\n            } else if (type === \"deny\") {\n                deny(instance, inputValue);\n            } else {\n                confirm(instance, inputValue);\n            }\n        });\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {any} value\n   */ const deny = (instance, value)=>{\n        const innerParams = privateProps.innerParams.get(instance || undefined);\n        if (innerParams.showLoaderOnDeny) {\n            showLoading(getDenyButton());\n        }\n        if (innerParams.preDeny) {\n            privateProps.awaitingPromise.set(instance || undefined, true); // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received\n            const preDenyPromise = Promise.resolve().then(()=>asPromise(innerParams.preDeny(value, innerParams.validationMessage)));\n            preDenyPromise.then((preDenyValue)=>{\n                if (preDenyValue === false) {\n                    instance.hideLoading();\n                    handleAwaitingPromise(instance);\n                } else {\n                    instance.close({\n                        isDenied: true,\n                        value: typeof preDenyValue === \"undefined\" ? value : preDenyValue\n                    });\n                }\n            }).catch((error)=>rejectWith(instance || undefined, error));\n        } else {\n            instance.close({\n                isDenied: true,\n                value\n            });\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {any} value\n   */ const succeedWith = (instance, value)=>{\n        instance.close({\n            isConfirmed: true,\n            value\n        });\n    };\n    /**\n   *\n   * @param {SweetAlert2} instance\n   * @param {string} error\n   */ const rejectWith = (instance, error)=>{\n        // @ts-ignore\n        instance.rejectPromise(error);\n    };\n    /**\n   *\n   * @param {SweetAlert2} instance\n   * @param {any} value\n   */ const confirm = (instance, value)=>{\n        const innerParams = privateProps.innerParams.get(instance || undefined);\n        if (innerParams.showLoaderOnConfirm) {\n            showLoading();\n        }\n        if (innerParams.preConfirm) {\n            instance.resetValidationMessage();\n            privateProps.awaitingPromise.set(instance || undefined, true); // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received\n            const preConfirmPromise = Promise.resolve().then(()=>asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));\n            preConfirmPromise.then((preConfirmValue)=>{\n                if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {\n                    instance.hideLoading();\n                    handleAwaitingPromise(instance);\n                } else {\n                    succeedWith(instance, typeof preConfirmValue === \"undefined\" ? value : preConfirmValue);\n                }\n            }).catch((error)=>rejectWith(instance || undefined, error));\n        } else {\n            succeedWith(instance, value);\n        }\n    };\n    const handlePopupClick = (instance, domCache, dismissWith)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        if (innerParams.toast) {\n            handleToastClick(instance, domCache, dismissWith);\n        } else {\n            // Ignore click events that had mousedown on the popup but mouseup on the container\n            // This can happen when the user drags a slider\n            handleModalMousedown(domCache);\n            // Ignore click events that had mousedown on the container but mouseup on the popup\n            handleContainerMousedown(domCache);\n            handleModalClick(instance, domCache, dismissWith);\n        }\n    };\n    const handleToastClick = (instance, domCache, dismissWith)=>{\n        // Closing toast by internal click\n        domCache.popup.onclick = ()=>{\n            const innerParams = privateProps.innerParams.get(instance);\n            if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {\n                return;\n            }\n            dismissWith(DismissReason.close);\n        };\n    };\n    /**\n   * @param {*} innerParams\n   * @returns {boolean}\n   */ const isAnyButtonShown = (innerParams)=>{\n        return innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton;\n    };\n    let ignoreOutsideClick = false;\n    const handleModalMousedown = (domCache)=>{\n        domCache.popup.onmousedown = ()=>{\n            domCache.container.onmouseup = function(e) {\n                domCache.container.onmouseup = undefined;\n                // We only check if the mouseup target is the container because usually it doesn't\n                // have any other direct children aside of the popup\n                if (e.target === domCache.container) {\n                    ignoreOutsideClick = true;\n                }\n            };\n        };\n    };\n    const handleContainerMousedown = (domCache)=>{\n        domCache.container.onmousedown = ()=>{\n            domCache.popup.onmouseup = function(e) {\n                domCache.popup.onmouseup = undefined;\n                // We also need to check if the mouseup target is a child of the popup\n                if (e.target === domCache.popup || domCache.popup.contains(e.target)) {\n                    ignoreOutsideClick = true;\n                }\n            };\n        };\n    };\n    const handleModalClick = (instance, domCache, dismissWith)=>{\n        domCache.container.onclick = (e)=>{\n            const innerParams = privateProps.innerParams.get(instance);\n            if (ignoreOutsideClick) {\n                ignoreOutsideClick = false;\n                return;\n            }\n            if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {\n                dismissWith(DismissReason.backdrop);\n            }\n        };\n    };\n    const isJqueryElement = (elem)=>typeof elem === \"object\" && elem.jquery;\n    const isElement = (elem)=>elem instanceof Element || isJqueryElement(elem);\n    const argsToParams = (args)=>{\n        const params = {};\n        if (typeof args[0] === \"object\" && !isElement(args[0])) {\n            Object.assign(params, args[0]);\n        } else {\n            [\n                \"title\",\n                \"html\",\n                \"icon\"\n            ].forEach((name, index)=>{\n                const arg = args[index];\n                if (typeof arg === \"string\" || isElement(arg)) {\n                    params[name] = arg;\n                } else if (arg !== undefined) {\n                    error(`Unexpected type of ${name}! Expected \"string\" or \"Element\", got ${typeof arg}`);\n                }\n            });\n        }\n        return params;\n    };\n    function fire() {\n        const Swal = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return new Swal(...args);\n    }\n    /**\n   * Returns an extended version of `Swal` containing `params` as defaults.\n   * Useful for reusing Swal configuration.\n   *\n   * For example:\n   *\n   * Before:\n   * const textPromptOptions = { input: 'text', showCancelButton: true }\n   * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })\n   * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })\n   *\n   * After:\n   * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })\n   * const {value: firstName} = await TextPrompt('What is your first name?')\n   * const {value: lastName} = await TextPrompt('What is your last name?')\n   *\n   * @param mixinParams\n   */ function mixin(mixinParams) {\n        class MixinSwal extends this {\n            _main(params, priorityMixinParams) {\n                return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));\n            }\n        }\n        return MixinSwal;\n    }\n    /**\n   * If `timer` parameter is set, returns number of milliseconds of timer remained.\n   * Otherwise, returns undefined.\n   *\n   * @returns {number | undefined}\n   */ const getTimerLeft = ()=>{\n        return globalState.timeout && globalState.timeout.getTimerLeft();\n    };\n    /**\n   * Stop timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   *\n   * @returns {number | undefined}\n   */ const stopTimer = ()=>{\n        if (globalState.timeout) {\n            stopTimerProgressBar();\n            return globalState.timeout.stop();\n        }\n    };\n    /**\n   * Resume timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   *\n   * @returns {number | undefined}\n   */ const resumeTimer = ()=>{\n        if (globalState.timeout) {\n            const remaining = globalState.timeout.start();\n            animateTimerProgressBar(remaining);\n            return remaining;\n        }\n    };\n    /**\n   * Resume timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   *\n   * @returns {number | undefined}\n   */ const toggleTimer = ()=>{\n        const timer = globalState.timeout;\n        return timer && (timer.running ? stopTimer() : resumeTimer());\n    };\n    /**\n   * Increase timer. Returns number of milliseconds of an updated timer.\n   * If `timer` parameter isn't set, returns undefined.\n   *\n   * @param {number} n\n   * @returns {number | undefined}\n   */ const increaseTimer = (n)=>{\n        if (globalState.timeout) {\n            const remaining = globalState.timeout.increase(n);\n            animateTimerProgressBar(remaining, true);\n            return remaining;\n        }\n    };\n    /**\n   * Check if timer is running. Returns true if timer is running\n   * or false if timer is paused or stopped.\n   * If `timer` parameter isn't set, returns undefined\n   *\n   * @returns {boolean}\n   */ const isTimerRunning = ()=>{\n        return globalState.timeout && globalState.timeout.isRunning();\n    };\n    let bodyClickListenerAdded = false;\n    const clickHandlers = {};\n    /**\n   * @param {string} attr\n   */ function bindClickHandler() {\n        let attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"data-swal-template\";\n        clickHandlers[attr] = this;\n        if (!bodyClickListenerAdded) {\n            document.body.addEventListener(\"click\", bodyClickListener);\n            bodyClickListenerAdded = true;\n        }\n    }\n    const bodyClickListener = (event)=>{\n        for(let el = event.target; el && el !== document; el = el.parentNode){\n            for(const attr in clickHandlers){\n                const template = el.getAttribute(attr);\n                if (template) {\n                    clickHandlers[attr].fire({\n                        template\n                    });\n                    return;\n                }\n            }\n        }\n    };\n    var staticMethods = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        isValidParameter: isValidParameter,\n        isUpdatableParameter: isUpdatableParameter,\n        isDeprecatedParameter: isDeprecatedParameter,\n        argsToParams: argsToParams,\n        getContainer: getContainer,\n        getPopup: getPopup,\n        getTitle: getTitle,\n        getHtmlContainer: getHtmlContainer,\n        getImage: getImage,\n        getIcon: getIcon,\n        getIconContent: getIconContent,\n        getInputLabel: getInputLabel,\n        getCloseButton: getCloseButton,\n        getActions: getActions,\n        getConfirmButton: getConfirmButton,\n        getDenyButton: getDenyButton,\n        getCancelButton: getCancelButton,\n        getLoader: getLoader,\n        getFooter: getFooter,\n        getTimerProgressBar: getTimerProgressBar,\n        getFocusableElements: getFocusableElements,\n        getValidationMessage: getValidationMessage,\n        getProgressSteps: getProgressSteps,\n        isLoading: isLoading,\n        isVisible: isVisible,\n        clickConfirm: clickConfirm,\n        clickDeny: clickDeny,\n        clickCancel: clickCancel,\n        fire: fire,\n        mixin: mixin,\n        showLoading: showLoading,\n        enableLoading: showLoading,\n        getTimerLeft: getTimerLeft,\n        stopTimer: stopTimer,\n        resumeTimer: resumeTimer,\n        toggleTimer: toggleTimer,\n        increaseTimer: increaseTimer,\n        isTimerRunning: isTimerRunning,\n        bindClickHandler: bindClickHandler\n    });\n    class Timer {\n        /**\n     * @param {Function} callback\n     * @param {number} delay\n     */ constructor(callback, delay){\n            this.callback = callback;\n            this.remaining = delay;\n            this.running = false;\n            this.start();\n        }\n        start() {\n            if (!this.running) {\n                this.running = true;\n                this.started = new Date();\n                this.id = setTimeout(this.callback, this.remaining);\n            }\n            return this.remaining;\n        }\n        stop() {\n            if (this.running) {\n                this.running = false;\n                clearTimeout(this.id);\n                this.remaining -= new Date().getTime() - this.started.getTime();\n            }\n            return this.remaining;\n        }\n        increase(n) {\n            const running = this.running;\n            if (running) {\n                this.stop();\n            }\n            this.remaining += n;\n            if (running) {\n                this.start();\n            }\n            return this.remaining;\n        }\n        getTimerLeft() {\n            if (this.running) {\n                this.stop();\n                this.start();\n            }\n            return this.remaining;\n        }\n        isRunning() {\n            return this.running;\n        }\n    }\n    const swalStringParams = [\n        \"swal-title\",\n        \"swal-html\",\n        \"swal-footer\"\n    ];\n    /**\n   * @param {SweetAlertOptions} params\n   * @returns {SweetAlertOptions}\n   */ const getTemplateParams = (params)=>{\n        /** @type {HTMLTemplateElement} */ const template = typeof params.template === \"string\" ? document.querySelector(params.template) : params.template;\n        if (!template) {\n            return {};\n        }\n        /** @type {DocumentFragment} */ const templateContent = template.content;\n        showWarningsForElements(templateContent);\n        const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalParams = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement[]} */ const swalParams = Array.from(templateContent.querySelectorAll(\"swal-param\"));\n        swalParams.forEach((param)=>{\n            showWarningsForAttributes(param, [\n                \"name\",\n                \"value\"\n            ]);\n            const paramName = param.getAttribute(\"name\");\n            const value = param.getAttribute(\"value\");\n            if (typeof defaultParams[paramName] === \"boolean\") {\n                result[paramName] = value !== \"false\";\n            } else if (typeof defaultParams[paramName] === \"object\") {\n                result[paramName] = JSON.parse(value);\n            } else {\n                result[paramName] = value;\n            }\n        });\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalFunctionParams = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement[]} */ const swalFunctions = Array.from(templateContent.querySelectorAll(\"swal-function-param\"));\n        swalFunctions.forEach((param)=>{\n            const paramName = param.getAttribute(\"name\");\n            const value = param.getAttribute(\"value\");\n            result[paramName] = new Function(`return ${value}`)();\n        });\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalButtons = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement[]} */ const swalButtons = Array.from(templateContent.querySelectorAll(\"swal-button\"));\n        swalButtons.forEach((button)=>{\n            showWarningsForAttributes(button, [\n                \"type\",\n                \"color\",\n                \"aria-label\"\n            ]);\n            const type = button.getAttribute(\"type\");\n            result[`${type}ButtonText`] = button.innerHTML;\n            result[`show${capitalizeFirstLetter(type)}Button`] = true;\n            if (button.hasAttribute(\"color\")) {\n                result[`${type}ButtonColor`] = button.getAttribute(\"color\");\n            }\n            if (button.hasAttribute(\"aria-label\")) {\n                result[`${type}ButtonAriaLabel`] = button.getAttribute(\"aria-label\");\n            }\n        });\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalImage = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement} */ const image = templateContent.querySelector(\"swal-image\");\n        if (image) {\n            showWarningsForAttributes(image, [\n                \"src\",\n                \"width\",\n                \"height\",\n                \"alt\"\n            ]);\n            if (image.hasAttribute(\"src\")) {\n                result.imageUrl = image.getAttribute(\"src\");\n            }\n            if (image.hasAttribute(\"width\")) {\n                result.imageWidth = image.getAttribute(\"width\");\n            }\n            if (image.hasAttribute(\"height\")) {\n                result.imageHeight = image.getAttribute(\"height\");\n            }\n            if (image.hasAttribute(\"alt\")) {\n                result.imageAlt = image.getAttribute(\"alt\");\n            }\n        }\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalIcon = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement} */ const icon = templateContent.querySelector(\"swal-icon\");\n        if (icon) {\n            showWarningsForAttributes(icon, [\n                \"type\",\n                \"color\"\n            ]);\n            if (icon.hasAttribute(\"type\")) {\n                /** @type {SweetAlertIcon} */ // @ts-ignore\n                result.icon = icon.getAttribute(\"type\");\n            }\n            if (icon.hasAttribute(\"color\")) {\n                result.iconColor = icon.getAttribute(\"color\");\n            }\n            result.iconHtml = icon.innerHTML;\n        }\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalInput = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement} */ const input = templateContent.querySelector(\"swal-input\");\n        if (input) {\n            showWarningsForAttributes(input, [\n                \"type\",\n                \"label\",\n                \"placeholder\",\n                \"value\"\n            ]);\n            /** @type {SweetAlertInput} */ // @ts-ignore\n            result.input = input.getAttribute(\"type\") || \"text\";\n            if (input.hasAttribute(\"label\")) {\n                result.inputLabel = input.getAttribute(\"label\");\n            }\n            if (input.hasAttribute(\"placeholder\")) {\n                result.inputPlaceholder = input.getAttribute(\"placeholder\");\n            }\n            if (input.hasAttribute(\"value\")) {\n                result.inputValue = input.getAttribute(\"value\");\n            }\n        }\n        /** @type {HTMLElement[]} */ const inputOptions = Array.from(templateContent.querySelectorAll(\"swal-input-option\"));\n        if (inputOptions.length) {\n            result.inputOptions = {};\n            inputOptions.forEach((option)=>{\n                showWarningsForAttributes(option, [\n                    \"value\"\n                ]);\n                const optionValue = option.getAttribute(\"value\");\n                const optionName = option.innerHTML;\n                result.inputOptions[optionValue] = optionName;\n            });\n        }\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @param {string[]} paramNames\n   * @returns {SweetAlertOptions}\n   */ const getSwalStringParams = (templateContent, paramNames)=>{\n        const result = {};\n        for(const i in paramNames){\n            const paramName = paramNames[i];\n            /** @type {HTMLElement} */ const tag = templateContent.querySelector(paramName);\n            if (tag) {\n                showWarningsForAttributes(tag, []);\n                result[paramName.replace(/^swal-/, \"\")] = tag.innerHTML.trim();\n            }\n        }\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   */ const showWarningsForElements = (templateContent)=>{\n        const allowedElements = swalStringParams.concat([\n            \"swal-param\",\n            \"swal-function-param\",\n            \"swal-button\",\n            \"swal-image\",\n            \"swal-icon\",\n            \"swal-input\",\n            \"swal-input-option\"\n        ]);\n        Array.from(templateContent.children).forEach((el)=>{\n            const tagName = el.tagName.toLowerCase();\n            if (!allowedElements.includes(tagName)) {\n                warn(`Unrecognized element <${tagName}>`);\n            }\n        });\n    };\n    /**\n   * @param {HTMLElement} el\n   * @param {string[]} allowedAttributes\n   */ const showWarningsForAttributes = (el, allowedAttributes)=>{\n        Array.from(el.attributes).forEach((attribute)=>{\n            if (allowedAttributes.indexOf(attribute.name) === -1) {\n                warn([\n                    `Unrecognized attribute \"${attribute.name}\" on <${el.tagName.toLowerCase()}>.`,\n                    `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(\", \")}` : \"To set the value, use HTML within the element.\"}`\n                ]);\n            }\n        });\n    };\n    const SHOW_CLASS_TIMEOUT = 10;\n    /**\n   * Open popup, add necessary classes and styles, fix scrollbar\n   *\n   * @param {SweetAlertOptions} params\n   */ const openPopup = (params)=>{\n        const container = getContainer();\n        const popup = getPopup();\n        if (typeof params.willOpen === \"function\") {\n            params.willOpen(popup);\n        }\n        const bodyStyles = window.getComputedStyle(document.body);\n        const initialBodyOverflow = bodyStyles.overflowY;\n        addClasses(container, popup, params);\n        // scrolling is 'hidden' until animation is done, after that 'auto'\n        setTimeout(()=>{\n            setScrollingVisibility(container, popup);\n        }, SHOW_CLASS_TIMEOUT);\n        if (isModal()) {\n            fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);\n            setAriaHidden();\n        }\n        if (!isToast() && !globalState.previousActiveElement) {\n            globalState.previousActiveElement = document.activeElement;\n        }\n        if (typeof params.didOpen === \"function\") {\n            setTimeout(()=>params.didOpen(popup));\n        }\n        removeClass(container, swalClasses[\"no-transition\"]);\n    };\n    /**\n   * @param {AnimationEvent} event\n   */ const swalOpenAnimationFinished = (event)=>{\n        const popup = getPopup();\n        if (event.target !== popup) {\n            return;\n        }\n        const container = getContainer();\n        popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);\n        container.style.overflowY = \"auto\";\n    };\n    /**\n   * @param {HTMLElement} container\n   * @param {HTMLElement} popup\n   */ const setScrollingVisibility = (container, popup)=>{\n        if (animationEndEvent && hasCssAnimation(popup)) {\n            container.style.overflowY = \"hidden\";\n            popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);\n        } else {\n            container.style.overflowY = \"auto\";\n        }\n    };\n    /**\n   * @param {HTMLElement} container\n   * @param {boolean} scrollbarPadding\n   * @param {string} initialBodyOverflow\n   */ const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow)=>{\n        iOSfix();\n        if (scrollbarPadding && initialBodyOverflow !== \"hidden\") {\n            fixScrollbar();\n        }\n        // sweetalert2/issues/1247\n        setTimeout(()=>{\n            container.scrollTop = 0;\n        });\n    };\n    /**\n   * @param {HTMLElement} container\n   * @param {HTMLElement} popup\n   * @param {SweetAlertOptions} params\n   */ const addClasses = (container, popup, params)=>{\n        addClass(container, params.showClass.backdrop);\n        // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059\n        popup.style.setProperty(\"opacity\", \"0\", \"important\");\n        show(popup, \"grid\");\n        setTimeout(()=>{\n            // Animate popup right after showing it\n            addClass(popup, params.showClass.popup);\n            // and remove the opacity workaround\n            popup.style.removeProperty(\"opacity\");\n        }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses.shown);\n        if (params.heightAuto && params.backdrop && !params.toast) {\n            addClass([\n                document.documentElement,\n                document.body\n            ], swalClasses[\"height-auto\"]);\n        }\n    };\n    var defaultInputValidators = {\n        /**\n     * @param {string} string\n     * @param {string} validationMessage\n     * @returns {Promise<void | string>}\n     */ email: (string, validationMessage)=>{\n            return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid email address\");\n        },\n        /**\n     * @param {string} string\n     * @param {string} validationMessage\n     * @returns {Promise<void | string>}\n     */ url: (string, validationMessage)=>{\n            // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013\n            return /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-z]{2,63}\\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid URL\");\n        }\n    };\n    /**\n   * @param {SweetAlertOptions} params\n   */ function setDefaultInputValidators(params) {\n        // Use default `inputValidator` for supported input types if not provided\n        if (!params.inputValidator) {\n            Object.keys(defaultInputValidators).forEach((key)=>{\n                if (params.input === key) {\n                    params.inputValidator = defaultInputValidators[key];\n                }\n            });\n        }\n    }\n    /**\n   * @param {SweetAlertOptions} params\n   */ function validateCustomTargetElement(params) {\n        // Determine if the custom target element is valid\n        if (!params.target || typeof params.target === \"string\" && !document.querySelector(params.target) || typeof params.target !== \"string\" && !params.target.appendChild) {\n            warn('Target parameter is not valid, defaulting to \"body\"');\n            params.target = \"body\";\n        }\n    }\n    /**\n   * Set type, text and actions on popup\n   *\n   * @param {SweetAlertOptions} params\n   */ function setParameters(params) {\n        setDefaultInputValidators(params);\n        // showLoaderOnConfirm && preConfirm\n        if (params.showLoaderOnConfirm && !params.preConfirm) {\n            warn(\"showLoaderOnConfirm is set to true, but preConfirm is not defined.\\n\" + \"showLoaderOnConfirm should be used together with preConfirm, see usage example:\\n\" + \"https://sweetalert2.github.io/#ajax-request\");\n        }\n        validateCustomTargetElement(params);\n        // Replace newlines with <br> in title\n        if (typeof params.title === \"string\") {\n            params.title = params.title.split(\"\\n\").join(\"<br />\");\n        }\n        init(params);\n    }\n    let currentInstance;\n    class SweetAlert {\n        constructor(){\n            // Prevent run in Node env\n            if (true) {\n                return;\n            }\n            currentInstance = this;\n            // @ts-ignore\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            const outerParams = Object.freeze(this.constructor.argsToParams(args));\n            Object.defineProperties(this, {\n                params: {\n                    value: outerParams,\n                    writable: false,\n                    enumerable: true,\n                    configurable: true\n                }\n            });\n            // @ts-ignore\n            const promise = currentInstance._main(currentInstance.params);\n            privateProps.promise.set(this, promise);\n        }\n        _main(userParams) {\n            let mixinParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            showWarningsForParams(Object.assign({}, mixinParams, userParams));\n            if (globalState.currentInstance) {\n                // @ts-ignore\n                globalState.currentInstance._destroy();\n                if (isModal()) {\n                    unsetAriaHidden();\n                }\n            }\n            globalState.currentInstance = currentInstance;\n            const innerParams = prepareParams(userParams, mixinParams);\n            setParameters(innerParams);\n            Object.freeze(innerParams);\n            // clear the previous timer\n            if (globalState.timeout) {\n                globalState.timeout.stop();\n                delete globalState.timeout;\n            }\n            // clear the restore focus timeout\n            clearTimeout(globalState.restoreFocusTimeout);\n            const domCache = populateDomCache(currentInstance);\n            render(currentInstance, innerParams);\n            privateProps.innerParams.set(currentInstance, innerParams);\n            return swalPromise(currentInstance, domCache, innerParams);\n        }\n        // `catch` cannot be the name of a module export, so we define our thenable methods here instead\n        then(onFulfilled) {\n            const promise = privateProps.promise.get(this);\n            return promise.then(onFulfilled);\n        }\n        finally(onFinally) {\n            const promise = privateProps.promise.get(this);\n            return promise.finally(onFinally);\n        }\n    }\n    /**\n   * @param {SweetAlert2} instance\n   * @param {DomCache} domCache\n   * @param {SweetAlertOptions} innerParams\n   * @returns {Promise}\n   */ const swalPromise = (instance, domCache, innerParams)=>{\n        return new Promise((resolve, reject)=>{\n            // functions to handle all closings/dismissals\n            /**\n       * @param {DismissReason} dismiss\n       */ const dismissWith = (dismiss)=>{\n                // @ts-ignore\n                instance.close({\n                    isDismissed: true,\n                    dismiss\n                });\n            };\n            privateMethods.swalPromiseResolve.set(instance, resolve);\n            privateMethods.swalPromiseReject.set(instance, reject);\n            domCache.confirmButton.onclick = ()=>{\n                handleConfirmButtonClick(instance);\n            };\n            domCache.denyButton.onclick = ()=>{\n                handleDenyButtonClick(instance);\n            };\n            domCache.cancelButton.onclick = ()=>{\n                handleCancelButtonClick(instance, dismissWith);\n            };\n            domCache.closeButton.onclick = ()=>{\n                // @ts-ignore\n                dismissWith(DismissReason.close);\n            };\n            handlePopupClick(instance, domCache, dismissWith);\n            addKeydownHandler(instance, globalState, innerParams, dismissWith);\n            handleInputOptionsAndValue(instance, innerParams);\n            openPopup(innerParams);\n            setupTimer(globalState, innerParams, dismissWith);\n            initFocus(domCache, innerParams);\n            // Scroll container to top on open (#1247, #1946)\n            setTimeout(()=>{\n                domCache.container.scrollTop = 0;\n            });\n        });\n    };\n    /**\n   * @param {SweetAlertOptions} userParams\n   * @param {SweetAlertOptions} mixinParams\n   * @returns {SweetAlertOptions}\n   */ const prepareParams = (userParams, mixinParams)=>{\n        const templateParams = getTemplateParams(userParams);\n        const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131\n        params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);\n        params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);\n        return params;\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @returns {DomCache}\n   */ const populateDomCache = (instance)=>{\n        const domCache = {\n            popup: getPopup(),\n            container: getContainer(),\n            actions: getActions(),\n            confirmButton: getConfirmButton(),\n            denyButton: getDenyButton(),\n            cancelButton: getCancelButton(),\n            loader: getLoader(),\n            closeButton: getCloseButton(),\n            validationMessage: getValidationMessage(),\n            progressSteps: getProgressSteps()\n        };\n        privateProps.domCache.set(instance, domCache);\n        return domCache;\n    };\n    /**\n   * @param {GlobalState} globalState\n   * @param {SweetAlertOptions} innerParams\n   * @param {Function} dismissWith\n   */ const setupTimer = (globalState, innerParams, dismissWith)=>{\n        const timerProgressBar = getTimerProgressBar();\n        hide(timerProgressBar);\n        if (innerParams.timer) {\n            globalState.timeout = new Timer(()=>{\n                dismissWith(\"timer\");\n                delete globalState.timeout;\n            }, innerParams.timer);\n            if (innerParams.timerProgressBar) {\n                show(timerProgressBar);\n                applyCustomClass(timerProgressBar, innerParams, \"timerProgressBar\");\n                setTimeout(()=>{\n                    if (globalState.timeout && globalState.timeout.running) {\n                        // timer can be already stopped or unset at this point\n                        animateTimerProgressBar(innerParams.timer);\n                    }\n                });\n            }\n        }\n    };\n    /**\n   * @param {DomCache} domCache\n   * @param {SweetAlertOptions} innerParams\n   */ const initFocus = (domCache, innerParams)=>{\n        if (innerParams.toast) {\n            return;\n        }\n        if (!callIfFunction(innerParams.allowEnterKey)) {\n            blurActiveElement();\n            return;\n        }\n        if (!focusButton(domCache, innerParams)) {\n            setFocus(-1, 1);\n        }\n    };\n    /**\n   * @param {DomCache} domCache\n   * @param {SweetAlertOptions} innerParams\n   * @returns {boolean}\n   */ const focusButton = (domCache, innerParams)=>{\n        if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {\n            domCache.denyButton.focus();\n            return true;\n        }\n        if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {\n            domCache.cancelButton.focus();\n            return true;\n        }\n        if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {\n            domCache.confirmButton.focus();\n            return true;\n        }\n        return false;\n    };\n    const blurActiveElement = ()=>{\n        if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === \"function\") {\n            document.activeElement.blur();\n        }\n    };\n    // Dear russian users visiting russian sites. Let's have fun.\n    if (false) {}\n    // Assign instance methods from src/instanceMethods/*.js to prototype\n    Object.assign(SweetAlert.prototype, instanceMethods);\n    // Assign static methods from src/staticMethods/*.js to constructor\n    Object.assign(SweetAlert, staticMethods);\n    // Proxy to instance methods to constructor, for now, for backwards compatibility\n    Object.keys(instanceMethods).forEach((key)=>{\n        /**\n     * @param {...any} args\n     * @returns {any | undefined}\n     */ SweetAlert[key] = function() {\n            if (currentInstance) {\n                return currentInstance[key](...arguments);\n            }\n        };\n    });\n    SweetAlert.DismissReason = DismissReason;\n    SweetAlert.version = \"11.7.1\";\n    const Swal = SweetAlert;\n    // @ts-ignore\n    Swal.default = Swal;\n    return Swal;\n});\nif (typeof void 0 !== \"undefined\" && (void 0).Sweetalert2) {\n    (void 0).swal = (void 0).sweetAlert = (void 0).Swal = (void 0).SweetAlert = (void 0).Sweetalert2;\n}\n\"undefined\" != typeof document && function(e, t) {\n    var n = e.createElement(\"style\");\n    if (e.getElementsByTagName(\"head\")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);\n    else try {\n        n.innerHTML = t;\n    } catch (e) {\n        n.innerText = t;\n    }\n}(document, '.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}.swal2-container{display:grid;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:rgba(0,0,0,0) !important}.swal2-container.swal2-top-start,.swal2-container.swal2-center-start,.swal2-container.swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}.swal2-container.swal2-top,.swal2-container.swal2-center,.swal2-container.swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}.swal2-container.swal2-top-end,.swal2-container.swal2-center-end,.swal2-container.swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}.swal2-container.swal2-top-start>.swal2-popup{align-self:start}.swal2-container.swal2-top>.swal2-popup{grid-column:2;align-self:start;justify-self:center}.swal2-container.swal2-top-end>.swal2-popup,.swal2-container.swal2-top-right>.swal2-popup{grid-column:3;align-self:start;justify-self:end}.swal2-container.swal2-center-start>.swal2-popup,.swal2-container.swal2-center-left>.swal2-popup{grid-row:2;align-self:center}.swal2-container.swal2-center>.swal2-popup{grid-column:2;grid-row:2;align-self:center;justify-self:center}.swal2-container.swal2-center-end>.swal2-popup,.swal2-container.swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;align-self:center;justify-self:end}.swal2-container.swal2-bottom-start>.swal2-popup,.swal2-container.swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}.swal2-container.swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;justify-self:center;align-self:end}.swal2-container.swal2-bottom-end>.swal2-popup,.swal2-container.swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;align-self:end;justify-self:end}.swal2-container.swal2-grow-row>.swal2-popup,.swal2-container.swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}.swal2-container.swal2-grow-column>.swal2-popup,.swal2-container.swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}.swal2-container.swal2-no-transition{transition:none !important}.swal2-popup{display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:none}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-title{position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}.swal2-loader{display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}.swal2-styled{margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}.swal2-styled.swal2-confirm:focus{box-shadow:0 0 0 3px rgba(112,102,224,.5)}.swal2-styled.swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}.swal2-styled.swal2-deny:focus{box-shadow:0 0 0 3px rgba(220,55,65,.5)}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}.swal2-styled.swal2-cancel:focus{box-shadow:0 0 0 3px rgba(110,120,129,.5)}.swal2-styled.swal2-default-outline:focus{box-shadow:0 0 0 3px rgba(100,150,200,.5)}.swal2-styled:focus{outline:none}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:2em auto 1em}.swal2-close{z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:rgba(0,0,0,0);color:#ccc;font-family:serif;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}.swal2-close:hover{transform:none;background:rgba(0,0,0,0);color:#f27474}.swal2-close:focus{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}.swal2-close::-moz-focus-inner{border:0}.swal2-html-container{z-index:1;justify-content:center;margin:1em 1.6em .3em;padding:0;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}.swal2-input,.swal2-file,.swal2-textarea,.swal2-select,.swal2-radio,.swal2-checkbox{margin:1em 2em 3px}.swal2-input,.swal2-file,.swal2-textarea{box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:rgba(0,0,0,0);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}.swal2-input.swal2-inputerror,.swal2-file.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}.swal2-input:focus,.swal2-file:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}.swal2-input::placeholder,.swal2-file::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em 2em 3px;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-file{width:75%;margin-right:auto;margin-left:auto;background:rgba(0,0,0,0);font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:rgba(0,0,0,0);color:inherit;font-size:1.125em}.swal2-radio,.swal2-checkbox{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-radio label,.swal2-checkbox label{margin:0 .6em;font-size:1.125em}.swal2-radio input,.swal2-checkbox input{flex-shrink:0;margin:0 .4em}.swal2-input-label{display:flex;justify-content:center;margin:1em auto 0}.swal2-validation-message{align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:0.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:swal2-show .3s}.swal2-hide{animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static !important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dlZXRhbGVydDIvZGlzdC9zd2VldGFsZXJ0Mi5hbGwuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7QUFHQSxHQUNDLFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUN4QixLQUFpRCxHQUFjRSxPQUFPRCxPQUFPLEdBQUdELFlBQ2hGLENBQ3lHO0FBQzNHLEdBQUcsUUFBTztJQUFjO0lBRXRCOzs7Ozs7OztHQVFDLEdBRUQsSUFBSVEsZUFBZTtRQUNqQkMsaUJBQWlCLElBQUlDO1FBQ3JCQyxTQUFTLElBQUlEO1FBQ2JFLGFBQWEsSUFBSUY7UUFDakJHLFVBQVUsSUFBSUg7SUFDaEI7SUFFQSxNQUFNSSxhQUFhO0lBRW5COzs7R0FHQyxHQUNELE1BQU1DLFNBQVNDLENBQUFBO1FBQ2IsTUFBTUMsU0FBUyxDQUFDO1FBQ2hCLElBQUssTUFBTUMsS0FBS0YsTUFBTztZQUNyQkMsTUFBTSxDQUFDRCxLQUFLLENBQUNFLEVBQUUsQ0FBQyxHQUFHSixhQUFhRSxLQUFLLENBQUNFLEVBQUU7UUFDMUM7UUFDQSxPQUFPRDtJQUNUO0lBQ0EsTUFBTUUsY0FBY0osT0FBTztRQUFDO1FBQWE7UUFBUztRQUFlO1FBQVU7UUFBUztRQUFTO1FBQWU7UUFBaUI7UUFBUztRQUFlO1FBQVE7UUFBUTtRQUFTO1FBQVM7UUFBa0I7UUFBVztRQUFXO1FBQVE7UUFBVTtRQUFtQjtRQUFVO1FBQVE7UUFBZ0I7UUFBUztRQUFTO1FBQVE7UUFBUztRQUFVO1FBQVM7UUFBWTtRQUFTO1FBQVk7UUFBYztRQUFlO1FBQXNCO1FBQWtCO1FBQXdCO1FBQWlCO1FBQXNCO1FBQVU7UUFBVztRQUFVO1FBQU87UUFBYTtRQUFXO1FBQVk7UUFBYTtRQUFVO1FBQWdCO1FBQWM7UUFBZTtRQUFnQjtRQUFVO1FBQWdCO1FBQWM7UUFBZTtRQUFnQjtRQUFZO1FBQWU7UUFBbUI7UUFBTztRQUFzQjtRQUFnQztRQUFxQjtRQUFnQjtRQUFnQjtRQUFhO1FBQWlCO0tBQWE7SUFDajdC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QWlCcmMsT0FBTyxDQUFDd1QsQ0FBQUE7UUFDbkM7OztLQUdDLEdBQ0R5UixVQUFVLENBQUN6UixJQUFJLEdBQUc7WUFDaEIsSUFBSXBOLGlCQUFpQjtnQkFDbkIsT0FBT0EsZUFBZSxDQUFDb04sSUFBSSxJQUFJM1E7WUFDakM7UUFDRjtJQUNGO0lBQ0FvaUIsV0FBV2pULGFBQWEsR0FBR0E7SUFDM0JpVCxXQUFXK0IsT0FBTyxHQUFHO0lBRXJCLE1BQU1wSyxPQUFPcUk7SUFDYixhQUFhO0lBQ2JySSxLQUFLcUssT0FBTyxHQUFHcks7SUFFZixPQUFPQTtBQUVUO0FBQ0EsSUFBSSxPQUFPLFdBQVMsZUFBZSxPQUFHLEVBQUVqa0IsV0FBVyxFQUFDO0lBQUMsT0FBRyxFQUFFdXVCLElBQUksR0FBRyxPQUFHLEVBQUVDLFVBQVUsR0FBRyxPQUFHLEVBQUV2SyxJQUFJLEdBQUcsT0FBRyxFQUFFcUksVUFBVSxHQUFHLE9BQUcsRUFBRXRzQixXQUFXO0FBQUE7QUFDakksZUFBYSxPQUFPNkMsWUFBVSxTQUFTb1gsQ0FBQyxFQUFDd1UsQ0FBQztJQUFFLElBQUk3RixJQUFFM08sRUFBRXpMLGFBQWEsQ0FBQztJQUFTLElBQUd5TCxFQUFFeVUsb0JBQW9CLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQ25uQixXQUFXLENBQUNxaEIsSUFBR0EsRUFBRStGLFVBQVUsRUFBQy9GLEVBQUUrRixVQUFVLENBQUNuYSxRQUFRLElBQUdvVSxDQUFBQSxFQUFFK0YsVUFBVSxDQUFDQyxPQUFPLEdBQUNILENBQUFBO1NBQVEsSUFBRztRQUFDN0YsRUFBRXZTLFNBQVMsR0FBQ29ZO0lBQUMsRUFBQyxPQUFNeFUsR0FBRTtRQUFDMk8sRUFBRWhWLFNBQVMsR0FBQzZhO0lBQUM7QUFBQyxFQUFFNXJCLFVBQVMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92cmlzdG8tbmV4dC8uL25vZGVfbW9kdWxlcy9zd2VldGFsZXJ0Mi9kaXN0L3N3ZWV0YWxlcnQyLmFsbC5qcz8xMzFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuKiBzd2VldGFsZXJ0MiB2MTEuNy4xXG4qIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Td2VldGFsZXJ0MiA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGBXZWFrTWFwYHMgZm9yIGVhY2ggZWZmZWN0aXZlbHktXCJwcml2YXRlICBwcm9wZXJ0eVwiIHRoYXQgYSBgU3dhbGAgaGFzLlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBwcml2YXRlIHByb3BlcnR5IFwiZm9vXCIgb2YgYHRoaXNgIHRvIFwiYmFyXCIsIHlvdSBjYW4gYHByaXZhdGVQcm9wcy5mb28uc2V0KHRoaXMsICdiYXInKWBcbiAgICogVGhpcyBpcyB0aGUgYXBwcm9hY2ggdGhhdCBCYWJlbCB3aWxsIHByb2JhYmx5IHRha2UgdG8gaW1wbGVtZW50IHByaXZhdGUgbWV0aG9kcy9maWVsZHNcbiAgICogICBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcml2YXRlLW1ldGhvZHNcbiAgICogICBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvcHVsbC83NTU1XG4gICAqIE9uY2Ugd2UgaGF2ZSB0aGUgY2hhbmdlcyBmcm9tIHRoYXQgUFIgaW4gQmFiZWwsIGFuZCBvdXIgY29yZSBjbGFzcyBmaXRzIHJlYXNvbmFibGUgaW4gKm9uZSBtb2R1bGUqXG4gICAqICAgdGhlbiB3ZSBjYW4gdXNlIHRoYXQgbGFuZ3VhZ2UgZmVhdHVyZS5cbiAgICovXG5cbiAgdmFyIHByaXZhdGVQcm9wcyA9IHtcbiAgICBhd2FpdGluZ1Byb21pc2U6IG5ldyBXZWFrTWFwKCksXG4gICAgcHJvbWlzZTogbmV3IFdlYWtNYXAoKSxcbiAgICBpbm5lclBhcmFtczogbmV3IFdlYWtNYXAoKSxcbiAgICBkb21DYWNoZTogbmV3IFdlYWtNYXAoKVxuICB9O1xuXG4gIGNvbnN0IHN3YWxQcmVmaXggPSAnc3dhbDItJztcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gaXRlbXNcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGNvbnN0IHByZWZpeCA9IGl0ZW1zID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gaXRlbXMpIHtcbiAgICAgIHJlc3VsdFtpdGVtc1tpXV0gPSBzd2FsUHJlZml4ICsgaXRlbXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IHN3YWxDbGFzc2VzID0gcHJlZml4KFsnY29udGFpbmVyJywgJ3Nob3duJywgJ2hlaWdodC1hdXRvJywgJ2lvc2ZpeCcsICdwb3B1cCcsICdtb2RhbCcsICduby1iYWNrZHJvcCcsICduby10cmFuc2l0aW9uJywgJ3RvYXN0JywgJ3RvYXN0LXNob3duJywgJ3Nob3cnLCAnaGlkZScsICdjbG9zZScsICd0aXRsZScsICdodG1sLWNvbnRhaW5lcicsICdhY3Rpb25zJywgJ2NvbmZpcm0nLCAnZGVueScsICdjYW5jZWwnLCAnZGVmYXVsdC1vdXRsaW5lJywgJ2Zvb3RlcicsICdpY29uJywgJ2ljb24tY29udGVudCcsICdpbWFnZScsICdpbnB1dCcsICdmaWxlJywgJ3JhbmdlJywgJ3NlbGVjdCcsICdyYWRpbycsICdjaGVja2JveCcsICdsYWJlbCcsICd0ZXh0YXJlYScsICdpbnB1dGVycm9yJywgJ2lucHV0LWxhYmVsJywgJ3ZhbGlkYXRpb24tbWVzc2FnZScsICdwcm9ncmVzcy1zdGVwcycsICdhY3RpdmUtcHJvZ3Jlc3Mtc3RlcCcsICdwcm9ncmVzcy1zdGVwJywgJ3Byb2dyZXNzLXN0ZXAtbGluZScsICdsb2FkZXInLCAnbG9hZGluZycsICdzdHlsZWQnLCAndG9wJywgJ3RvcC1zdGFydCcsICd0b3AtZW5kJywgJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdjZW50ZXInLCAnY2VudGVyLXN0YXJ0JywgJ2NlbnRlci1lbmQnLCAnY2VudGVyLWxlZnQnLCAnY2VudGVyLXJpZ2h0JywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnYm90dG9tLWVuZCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnLCAnZ3Jvdy1yb3cnLCAnZ3Jvdy1jb2x1bW4nLCAnZ3Jvdy1mdWxsc2NyZWVuJywgJ3J0bCcsICd0aW1lci1wcm9ncmVzcy1iYXInLCAndGltZXItcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lcicsICdzY3JvbGxiYXItbWVhc3VyZScsICdpY29uLXN1Y2Nlc3MnLCAnaWNvbi13YXJuaW5nJywgJ2ljb24taW5mbycsICdpY29uLXF1ZXN0aW9uJywgJ2ljb24tZXJyb3InXSk7XG4gIGNvbnN0IGljb25UeXBlcyA9IHByZWZpeChbJ3N1Y2Nlc3MnLCAnd2FybmluZycsICdpbmZvJywgJ3F1ZXN0aW9uJywgJ2Vycm9yJ10pO1xuXG4gIGNvbnN0IGNvbnNvbGVQcmVmaXggPSAnU3dlZXRBbGVydDI6JztcblxuICAvKipcbiAgICogRmlsdGVyIHRoZSB1bmlxdWUgdmFsdWVzIGludG8gYSBuZXcgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGNvbnN0IHVuaXF1ZUFycmF5ID0gYXJyID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlc3VsdC5pbmRleE9mKGFycltpXSkgPT09IC0xKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFycltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBzdHIgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZGl6ZSBjb25zb2xlIHdhcm5pbmdzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgQXJyYXl9IG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0IHdhcm4gPSBtZXNzYWdlID0+IHtcbiAgICBjb25zb2xlLndhcm4oYCR7Y29uc29sZVByZWZpeH0gJHt0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgPyBtZXNzYWdlLmpvaW4oJyAnKSA6IG1lc3NhZ2V9YCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkaXplIGNvbnNvbGUgZXJyb3JzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAqL1xuICBjb25zdCBlcnJvciA9IG1lc3NhZ2UgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoYCR7Y29uc29sZVByZWZpeH0gJHttZXNzYWdlfWApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGdsb2JhbCBzdGF0ZSBmb3IgYHdhcm5PbmNlYFxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdCBwcmV2aW91c1dhcm5PbmNlTWVzc2FnZXMgPSBbXTtcblxuICAvKipcbiAgICogU2hvdyBhIGNvbnNvbGUgd2FybmluZywgYnV0IG9ubHkgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzaG93blxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgKi9cbiAgY29uc3Qgd2Fybk9uY2UgPSBtZXNzYWdlID0+IHtcbiAgICBpZiAoIXByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcy5pbmNsdWRlcyhtZXNzYWdlKSkge1xuICAgICAgcHJldmlvdXNXYXJuT25jZU1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICB3YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2hvdyBhIG9uZS10aW1lIGNvbnNvbGUgd2FybmluZyBhYm91dCBkZXByZWNhdGVkIHBhcmFtcy9tZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZXByZWNhdGVkUGFyYW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZUluc3RlYWRcbiAgICovXG4gIGNvbnN0IHdhcm5BYm91dERlcHJlY2F0aW9uID0gKGRlcHJlY2F0ZWRQYXJhbSwgdXNlSW5zdGVhZCkgPT4ge1xuICAgIHdhcm5PbmNlKGBcIiR7ZGVwcmVjYXRlZFBhcmFtfVwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlIFwiJHt1c2VJbnN0ZWFkfVwiIGluc3RlYWQuYCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIGBhcmdgIGlzIGEgZnVuY3Rpb24sIGNhbGwgaXQgKHdpdGggbm8gYXJndW1lbnRzIG9yIGNvbnRleHQpIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICogT3RoZXJ3aXNlLCBqdXN0IHBhc3MgdGhlIHZhbHVlIHRocm91Z2hcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbiB8IGFueX0gYXJnXG4gICAqIEByZXR1cm5zIHthbnl9XG4gICAqL1xuICBjb25zdCBjYWxsSWZGdW5jdGlvbiA9IGFyZyA9PiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKCkgOiBhcmc7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBhcmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBoYXNUb1Byb21pc2VGbiA9IGFyZyA9PiBhcmcgJiYgdHlwZW9mIGFyZy50b1Byb21pc2UgPT09ICdmdW5jdGlvbic7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBhcmdcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjb25zdCBhc1Byb21pc2UgPSBhcmcgPT4gaGFzVG9Qcm9taXNlRm4oYXJnKSA/IGFyZy50b1Byb21pc2UoKSA6IFByb21pc2UucmVzb2x2ZShhcmcpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYXJnXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNQcm9taXNlID0gYXJnID0+IGFyZyAmJiBQcm9taXNlLnJlc29sdmUoYXJnKSA9PT0gYXJnO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwb3B1cCBjb250YWluZXIgd2hpY2ggY29udGFpbnMgdGhlIGJhY2tkcm9wIGFuZCB0aGUgcG9wdXAgaXRzZWxmLlxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0Q29udGFpbmVyID0gKCkgPT4gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5jb250YWluZXJ9YCk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclN0cmluZ1xuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZWxlbWVudEJ5U2VsZWN0b3IgPSBzZWxlY3RvclN0cmluZyA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgcmV0dXJuIGNvbnRhaW5lciA/IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yU3RyaW5nKSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGVsZW1lbnRCeUNsYXNzID0gY2xhc3NOYW1lID0+IHtcbiAgICByZXR1cm4gZWxlbWVudEJ5U2VsZWN0b3IoYC4ke2NsYXNzTmFtZX1gKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGdldFBvcHVwID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMucG9wdXApO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0SWNvbiA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmljb24pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0SWNvbkNvbnRlbnQgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1snaWNvbi1jb250ZW50J10pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0VGl0bGUgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy50aXRsZSk7XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXRIdG1sQ29udGFpbmVyID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ2h0bWwtY29udGFpbmVyJ10pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0SW1hZ2UgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5pbWFnZSk7XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXRQcm9ncmVzc1N0ZXBzID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXBzJ10pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0VmFsaWRhdGlvbk1lc3NhZ2UgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1sndmFsaWRhdGlvbi1tZXNzYWdlJ10pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEJ1dHRvbkVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0Q29uZmlybUJ1dHRvbiA9ICgpID0+IC8qKiBAdHlwZSB7SFRNTEJ1dHRvbkVsZW1lbnR9ICovZWxlbWVudEJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLmFjdGlvbnN9IC4ke3N3YWxDbGFzc2VzLmNvbmZpcm19YCk7XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MQnV0dG9uRWxlbWVudCB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXRDYW5jZWxCdXR0b24gPSAoKSA9PiAvKiogQHR5cGUge0hUTUxCdXR0b25FbGVtZW50fSAqL2VsZW1lbnRCeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5hY3Rpb25zfSAuJHtzd2FsQ2xhc3Nlcy5jYW5jZWx9YCk7XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MQnV0dG9uRWxlbWVudCB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXREZW55QnV0dG9uID0gKCkgPT4gLyoqIEB0eXBlIHtIVE1MQnV0dG9uRWxlbWVudH0gKi9lbGVtZW50QnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMuYWN0aW9uc30gLiR7c3dhbENsYXNzZXMuZGVueX1gKTtcblxuICAvKipcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGdldElucHV0TGFiZWwgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1snaW5wdXQtbGFiZWwnXSk7XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXRMb2FkZXIgPSAoKSA9PiBlbGVtZW50QnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMubG9hZGVyfWApO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0QWN0aW9ucyA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmFjdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0Rm9vdGVyID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMuZm9vdGVyKTtcblxuICAvKipcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGdldFRpbWVyUHJvZ3Jlc3NCYXIgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyJ10pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0Q2xvc2VCdXR0b24gPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5jbG9zZSk7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2prdXAvZm9jdXNhYmxlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gIGNvbnN0IGZvY3VzYWJsZSA9IGBcbiAgYVtocmVmXSxcbiAgYXJlYVtocmVmXSxcbiAgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLFxuICBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLFxuICB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksXG4gIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksXG4gIGlmcmFtZSxcbiAgb2JqZWN0LFxuICBlbWJlZCxcbiAgW3RhYmluZGV4PVwiMFwiXSxcbiAgW2NvbnRlbnRlZGl0YWJsZV0sXG4gIGF1ZGlvW2NvbnRyb2xzXSxcbiAgdmlkZW9bY29udHJvbHNdLFxuICBzdW1tYXJ5XG5gO1xuICAvKipcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBjb25zdCBnZXRGb2N1c2FibGVFbGVtZW50cyA9ICgpID0+IHtcbiAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleCA9IEFycmF5LmZyb20oZ2V0UG9wdXAoKS5xdWVyeVNlbGVjdG9yQWxsKCdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSk6bm90KFt0YWJpbmRleD1cIjBcIl0pJykpXG4gICAgLy8gc29ydCBhY2NvcmRpbmcgdG8gdGFiaW5kZXhcbiAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgdGFiaW5kZXhBID0gcGFyc2VJbnQoYS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpO1xuICAgICAgY29uc3QgdGFiaW5kZXhCID0gcGFyc2VJbnQoYi5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpO1xuICAgICAgaWYgKHRhYmluZGV4QSA+IHRhYmluZGV4Qikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAodGFiaW5kZXhBIDwgdGFiaW5kZXhCKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIGNvbnN0IG90aGVyRm9jdXNhYmxlRWxlbWVudHMgPSBBcnJheS5mcm9tKGdldFBvcHVwKCkucXVlcnlTZWxlY3RvckFsbChmb2N1c2FibGUpKS5maWx0ZXIoZWwgPT4gZWwuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICE9PSAnLTEnKTtcbiAgICByZXR1cm4gdW5pcXVlQXJyYXkoZm9jdXNhYmxlRWxlbWVudHNXaXRoVGFiaW5kZXguY29uY2F0KG90aGVyRm9jdXNhYmxlRWxlbWVudHMpKS5maWx0ZXIoZWwgPT4gaXNWaXNpYmxlJDEoZWwpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBpc01vZGFsID0gKCkgPT4ge1xuICAgIHJldHVybiBoYXNDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5zaG93bikgJiYgIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzWyd0b2FzdC1zaG93biddKSAmJiAhaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXNbJ25vLWJhY2tkcm9wJ10pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGlzVG9hc3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdldFBvcHVwKCkgJiYgaGFzQ2xhc3MoZ2V0UG9wdXAoKSwgc3dhbENsYXNzZXMudG9hc3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGlzTG9hZGluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gZ2V0UG9wdXAoKS5oYXNBdHRyaWJ1dGUoJ2RhdGEtbG9hZGluZycpO1xuICB9O1xuXG4gIC8vIFJlbWVtYmVyIHN0YXRlIGluIGNhc2VzIHdoZXJlIG9wZW5pbmcgYW5kIGhhbmRsaW5nIGEgbW9kYWwgd2lsbCBmaWRkbGUgd2l0aCBpdC5cbiAgY29uc3Qgc3RhdGVzID0ge1xuICAgIHByZXZpb3VzQm9keVBhZGRpbmc6IG51bGxcbiAgfTtcblxuICAvKipcbiAgICogU2VjdXJlbHkgc2V0IGlubmVySFRNTCBvZiBhbiBlbGVtZW50XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTkyNlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAqL1xuICBjb25zdCBzZXRJbm5lckh0bWwgPSAoZWxlbSwgaHRtbCkgPT4ge1xuICAgIGVsZW0udGV4dENvbnRlbnQgPSAnJztcbiAgICBpZiAoaHRtbCkge1xuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sLCBgdGV4dC9odG1sYCk7XG4gICAgICBBcnJheS5mcm9tKHBhcnNlZC5xdWVyeVNlbGVjdG9yKCdoZWFkJykuY2hpbGROb2RlcykuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBBcnJheS5mcm9tKHBhcnNlZC5xdWVyeVNlbGVjdG9yKCdib2R5JykuY2hpbGROb2RlcykuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50KSB7XG4gICAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChjaGlsZC5jbG9uZU5vZGUodHJ1ZSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzI1MDdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBoYXNDbGFzcyA9IChlbGVtLCBjbGFzc05hbWUpID0+IHtcbiAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc0xpc3QgPSBjbGFzc05hbWUuc3BsaXQoL1xccysvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFlbGVtLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc0xpc3RbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCByZW1vdmVDdXN0b21DbGFzc2VzID0gKGVsZW0sIHBhcmFtcykgPT4ge1xuICAgIEFycmF5LmZyb20oZWxlbS5jbGFzc0xpc3QpLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICAgIGlmICghT2JqZWN0LnZhbHVlcyhzd2FsQ2xhc3NlcykuaW5jbHVkZXMoY2xhc3NOYW1lKSAmJiAhT2JqZWN0LnZhbHVlcyhpY29uVHlwZXMpLmluY2x1ZGVzKGNsYXNzTmFtZSkgJiYgIU9iamVjdC52YWx1ZXMocGFyYW1zLnNob3dDbGFzcykuaW5jbHVkZXMoY2xhc3NOYW1lKSkge1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgY29uc3QgYXBwbHlDdXN0b21DbGFzcyA9IChlbGVtLCBwYXJhbXMsIGNsYXNzTmFtZSkgPT4ge1xuICAgIHJlbW92ZUN1c3RvbUNsYXNzZXMoZWxlbSwgcGFyYW1zKTtcbiAgICBpZiAocGFyYW1zLmN1c3RvbUNsYXNzICYmIHBhcmFtcy5jdXN0b21DbGFzc1tjbGFzc05hbWVdKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy5jdXN0b21DbGFzc1tjbGFzc05hbWVdICE9PSAnc3RyaW5nJyAmJiAhcGFyYW1zLmN1c3RvbUNsYXNzW2NsYXNzTmFtZV0uZm9yRWFjaCkge1xuICAgICAgICB3YXJuKGBJbnZhbGlkIHR5cGUgb2YgY3VzdG9tQ2xhc3MuJHtjbGFzc05hbWV9ISBFeHBlY3RlZCBzdHJpbmcgb3IgaXRlcmFibGUgb2JqZWN0LCBnb3QgXCIke3R5cGVvZiBwYXJhbXMuY3VzdG9tQ2xhc3NbY2xhc3NOYW1lXX1cImApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhlbGVtLCBwYXJhbXMuY3VzdG9tQ2xhc3NbY2xhc3NOYW1lXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9yZW5kZXJlcnMvcmVuZGVySW5wdXQnKS5JbnB1dENsYXNzfSBpbnB1dENsYXNzXG4gICAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGdldElucHV0JDEgPSAocG9wdXAsIGlucHV0Q2xhc3MpID0+IHtcbiAgICBpZiAoIWlucHV0Q2xhc3MpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2ggKGlucHV0Q2xhc3MpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBjYXNlICdmaWxlJzpcbiAgICAgICAgcmV0dXJuIHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnBvcHVwfSA+IC4ke3N3YWxDbGFzc2VzW2lucHV0Q2xhc3NdfWApO1xuICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMuY2hlY2tib3h9IGlucHV0YCk7XG4gICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgIHJldHVybiBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5wb3B1cH0gPiAuJHtzd2FsQ2xhc3Nlcy5yYWRpb30gaW5wdXQ6Y2hlY2tlZGApIHx8IHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnBvcHVwfSA+IC4ke3N3YWxDbGFzc2VzLnJhZGlvfSBpbnB1dDpmaXJzdC1jaGlsZGApO1xuICAgICAgY2FzZSAncmFuZ2UnOlxuICAgICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMucmFuZ2V9IGlucHV0YCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMuaW5wdXR9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50IHwgSFRNTFNlbGVjdEVsZW1lbnR9IGlucHV0XG4gICAqL1xuICBjb25zdCBmb2N1c0lucHV0ID0gaW5wdXQgPT4ge1xuICAgIGlucHV0LmZvY3VzKCk7XG5cbiAgICAvLyBwbGFjZSBjdXJzb3IgYXQgZW5kIG9mIHRleHQgaW4gdGV4dCBpbnB1dFxuICAgIGlmIChpbnB1dC50eXBlICE9PSAnZmlsZScpIHtcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzNDU5MTVcbiAgICAgIGNvbnN0IHZhbCA9IGlucHV0LnZhbHVlO1xuICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICAgIGlucHV0LnZhbHVlID0gdmFsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IEhUTUxFbGVtZW50W10gfCBudWxsfSB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IHJlYWRvbmx5IHN0cmluZ1tdfSBjbGFzc0xpc3RcbiAgICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAgICovXG4gIGNvbnN0IHRvZ2dsZUNsYXNzID0gKHRhcmdldCwgY2xhc3NMaXN0LCBjb25kaXRpb24pID0+IHtcbiAgICBpZiAoIXRhcmdldCB8fCAhY2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2xhc3NMaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2xhc3NMaXN0ID0gY2xhc3NMaXN0LnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH1cbiAgICBjbGFzc0xpc3QuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQuZm9yRWFjaChlbGVtID0+IHtcbiAgICAgICAgICBjb25kaXRpb24gPyBlbGVtLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSA6IGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmRpdGlvbiA/IHRhcmdldC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkgOiB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgSFRNTEVsZW1lbnRbXSB8IG51bGx9IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgcmVhZG9ubHkgc3RyaW5nW119IGNsYXNzTGlzdFxuICAgKi9cbiAgY29uc3QgYWRkQ2xhc3MgPSAodGFyZ2V0LCBjbGFzc0xpc3QpID0+IHtcbiAgICB0b2dnbGVDbGFzcyh0YXJnZXQsIGNsYXNzTGlzdCwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBIVE1MRWxlbWVudFtdIHwgbnVsbH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW10gfCByZWFkb25seSBzdHJpbmdbXX0gY2xhc3NMaXN0XG4gICAqL1xuICBjb25zdCByZW1vdmVDbGFzcyA9ICh0YXJnZXQsIGNsYXNzTGlzdCkgPT4ge1xuICAgIHRvZ2dsZUNsYXNzKHRhcmdldCwgY2xhc3NMaXN0LCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBkaXJlY3QgY2hpbGQgb2YgYW4gZWxlbWVudCBieSBjbGFzcyBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdCBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MgPSAoZWxlbSwgY2xhc3NOYW1lKSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsZW0uY2hpbGRyZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBoYXNDbGFzcyhjaGlsZCwgY2xhc3NOYW1lKSkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBjb25zdCBhcHBseU51bWVyaWNhbFN0eWxlID0gKGVsZW0sIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gYCR7cGFyc2VJbnQodmFsdWUpfWApIHtcbiAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgfHwgcGFyc2VJbnQodmFsdWUpID09PSAwKSB7XG4gICAgICBlbGVtLnN0eWxlW3Byb3BlcnR5XSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBgJHt2YWx1ZX1weGAgOiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwbGF5XG4gICAqL1xuICBjb25zdCBzaG93ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICBsZXQgZGlzcGxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2ZsZXgnO1xuICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICovXG4gIGNvbnN0IGhpZGUgPSBlbGVtID0+IHtcbiAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgY29uc3Qgc2V0U3R5bGUgPSAocGFyZW50LCBzZWxlY3RvciwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICBjb25zdCBlbCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKiBAcGFyYW0ge2FueX0gY29uZGl0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwbGF5XG4gICAqL1xuICBjb25zdCB0b2dnbGUgPSBmdW5jdGlvbiAoZWxlbSwgY29uZGl0aW9uKSB7XG4gICAgbGV0IGRpc3BsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdmbGV4JztcbiAgICBjb25kaXRpb24gPyBzaG93KGVsZW0sIGRpc3BsYXkpIDogaGlkZShlbGVtKTtcbiAgfTtcblxuICAvKipcbiAgICogYm9ycm93ZWQgZnJvbSBqcXVlcnkgJChlbGVtKS5pcygnOnZpc2libGUnKSBpbXBsZW1lbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNWaXNpYmxlJDEgPSBlbGVtID0+ICEhKGVsZW0gJiYgKGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkpO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGFsbEJ1dHRvbnNBcmVIaWRkZW4gPSAoKSA9PiAhaXNWaXNpYmxlJDEoZ2V0Q29uZmlybUJ1dHRvbigpKSAmJiAhaXNWaXNpYmxlJDEoZ2V0RGVueUJ1dHRvbigpKSAmJiAhaXNWaXNpYmxlJDEoZ2V0Q2FuY2VsQnV0dG9uKCkpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNTY3JvbGxhYmxlID0gZWxlbSA9PiAhIShlbGVtLnNjcm9sbEhlaWdodCA+IGVsZW0uY2xpZW50SGVpZ2h0KTtcblxuICAvKipcbiAgICogYm9ycm93ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYzNTIxMTlcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGhhc0Nzc0FuaW1hdGlvbiA9IGVsZW0gPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgY29uc3QgYW5pbUR1cmF0aW9uID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdhbmltYXRpb24tZHVyYXRpb24nKSB8fCAnMCcpO1xuICAgIGNvbnN0IHRyYW5zRHVyYXRpb24gPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3RyYW5zaXRpb24tZHVyYXRpb24nKSB8fCAnMCcpO1xuICAgIHJldHVybiBhbmltRHVyYXRpb24gPiAwIHx8IHRyYW5zRHVyYXRpb24gPiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXJcbiAgICogQHBhcmFtIHtib29sZWFufSByZXNldFxuICAgKi9cbiAgY29uc3QgYW5pbWF0ZVRpbWVyUHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICBsZXQgcmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXIgPSBnZXRUaW1lclByb2dyZXNzQmFyKCk7XG4gICAgaWYgKGlzVmlzaWJsZSQxKHRpbWVyUHJvZ3Jlc3NCYXIpKSB7XG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgICAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUudHJhbnNpdGlvbiA9IGB3aWR0aCAke3RpbWVyIC8gMTAwMH1zIGxpbmVhcmA7XG4gICAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSAnMCUnO1xuICAgICAgfSwgMTApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RvcFRpbWVyUHJvZ3Jlc3NCYXIgPSAoKSA9PiB7XG4gICAgY29uc3QgdGltZXJQcm9ncmVzc0JhciA9IGdldFRpbWVyUHJvZ3Jlc3NCYXIoKTtcbiAgICBjb25zdCB0aW1lclByb2dyZXNzQmFyV2lkdGggPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aW1lclByb2dyZXNzQmFyKS53aWR0aCk7XG4gICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbicpO1xuICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgY29uc3QgdGltZXJQcm9ncmVzc0JhckZ1bGxXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpbWVyUHJvZ3Jlc3NCYXIpLndpZHRoKTtcbiAgICBjb25zdCB0aW1lclByb2dyZXNzQmFyUGVyY2VudCA9IHRpbWVyUHJvZ3Jlc3NCYXJXaWR0aCAvIHRpbWVyUHJvZ3Jlc3NCYXJGdWxsV2lkdGggKiAxMDA7XG4gICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS53aWR0aCA9IGAke3RpbWVyUHJvZ3Jlc3NCYXJQZXJjZW50fSVgO1xuICB9O1xuXG4gIGNvbnN0IFJFU1RPUkVfRk9DVVNfVElNRU9VVCA9IDEwMDtcblxuICAvKiogQHR5cGUge0dsb2JhbFN0YXRlfSAqL1xuICBjb25zdCBnbG9iYWxTdGF0ZSA9IHt9O1xuICBjb25zdCBmb2N1c1ByZXZpb3VzQWN0aXZlRWxlbWVudCA9ICgpID0+IHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgcHJldmlvdXMgYWN0aXZlIChmb2N1c2VkKSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0dXJuRm9jdXNcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjb25zdCByZXN0b3JlQWN0aXZlRWxlbWVudCA9IHJldHVybkZvY3VzID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpZiAoIXJldHVybkZvY3VzKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gd2luZG93LnNjcm9sbFg7XG4gICAgICBjb25zdCB5ID0gd2luZG93LnNjcm9sbFk7XG4gICAgICBnbG9iYWxTdGF0ZS5yZXN0b3JlRm9jdXNUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGZvY3VzUHJldmlvdXNBY3RpdmVFbGVtZW50KCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIFJFU1RPUkVfRk9DVVNfVElNRU9VVCk7IC8vIGlzc3Vlcy85MDBcblxuICAgICAgd2luZG93LnNjcm9sbFRvKHgsIHkpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZXRlY3QgTm9kZSBlbnZcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBpc05vZGVFbnYgPSAoKSA9PiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnO1xuXG4gIGNvbnN0IHN3ZWV0SFRNTCA9IGBcbiA8ZGl2IGFyaWEtbGFiZWxsZWRieT1cIiR7c3dhbENsYXNzZXMudGl0bGV9XCIgYXJpYS1kZXNjcmliZWRieT1cIiR7c3dhbENsYXNzZXNbJ2h0bWwtY29udGFpbmVyJ119XCIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLnBvcHVwfVwiIHRhYmluZGV4PVwiLTFcIj5cbiAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5jbG9zZX1cIj48L2J1dHRvbj5cbiAgIDx1bCBjbGFzcz1cIiR7c3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXBzJ119XCI+PC91bD5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmljb259XCI+PC9kaXY+XG4gICA8aW1nIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5pbWFnZX1cIiAvPlxuICAgPGgyIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy50aXRsZX1cIiBpZD1cIiR7c3dhbENsYXNzZXMudGl0bGV9XCI+PC9oMj5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzWydodG1sLWNvbnRhaW5lciddfVwiIGlkPVwiJHtzd2FsQ2xhc3Nlc1snaHRtbC1jb250YWluZXInXX1cIj48L2Rpdj5cbiAgIDxpbnB1dCBjbGFzcz1cIiR7c3dhbENsYXNzZXMuaW5wdXR9XCIgLz5cbiAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5maWxlfVwiIC8+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5yYW5nZX1cIj5cbiAgICAgPGlucHV0IHR5cGU9XCJyYW5nZVwiIC8+XG4gICAgIDxvdXRwdXQ+PC9vdXRwdXQ+XG4gICA8L2Rpdj5cbiAgIDxzZWxlY3QgY2xhc3M9XCIke3N3YWxDbGFzc2VzLnNlbGVjdH1cIj48L3NlbGVjdD5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLnJhZGlvfVwiPjwvZGl2PlxuICAgPGxhYmVsIGZvcj1cIiR7c3dhbENsYXNzZXMuY2hlY2tib3h9XCIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmNoZWNrYm94fVwiPlxuICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgLz5cbiAgICAgPHNwYW4gY2xhc3M9XCIke3N3YWxDbGFzc2VzLmxhYmVsfVwiPjwvc3Bhbj5cbiAgIDwvbGFiZWw+XG4gICA8dGV4dGFyZWEgY2xhc3M9XCIke3N3YWxDbGFzc2VzLnRleHRhcmVhfVwiPjwvdGV4dGFyZWE+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1sndmFsaWRhdGlvbi1tZXNzYWdlJ119XCIgaWQ9XCIke3N3YWxDbGFzc2VzWyd2YWxpZGF0aW9uLW1lc3NhZ2UnXX1cIj48L2Rpdj5cbiAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmFjdGlvbnN9XCI+XG4gICAgIDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmxvYWRlcn1cIj48L2Rpdj5cbiAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmNvbmZpcm19XCI+PC9idXR0b24+XG4gICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5kZW55fVwiPjwvYnV0dG9uPlxuICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuY2FuY2VsfVwiPjwvYnV0dG9uPlxuICAgPC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5mb290ZXJ9XCI+PC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lciddfVwiPlxuICAgICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyJ119XCI+PC9kaXY+XG4gICA8L2Rpdj5cbiA8L2Rpdj5cbmAucmVwbGFjZSgvKF58XFxuKVxccyovZywgJycpO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IHJlc2V0T2xkQ29udGFpbmVyID0gKCkgPT4ge1xuICAgIGNvbnN0IG9sZENvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgIGlmICghb2xkQ29udGFpbmVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9sZENvbnRhaW5lci5yZW1vdmUoKTtcbiAgICByZW1vdmVDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgW3N3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSwgc3dhbENsYXNzZXNbJ2hhcy1jb2x1bW4nXV0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBjb25zdCByZXNldFZhbGlkYXRpb25NZXNzYWdlJDEgPSAoKSA9PiB7XG4gICAgZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlLnJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UoKTtcbiAgfTtcbiAgY29uc3QgYWRkSW5wdXRDaGFuZ2VMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIGNvbnN0IGlucHV0ID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5pbnB1dCk7XG4gICAgY29uc3QgZmlsZSA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMuZmlsZSk7XG4gICAgLyoqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50fSAqL1xuICAgIGNvbnN0IHJhbmdlID0gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucmFuZ2V9IGlucHV0YCk7XG4gICAgLyoqIEB0eXBlIHtIVE1MT3V0cHV0RWxlbWVudH0gKi9cbiAgICBjb25zdCByYW5nZU91dHB1dCA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnJhbmdlfSBvdXRwdXRgKTtcbiAgICBjb25zdCBzZWxlY3QgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnNlbGVjdCk7XG4gICAgLyoqIEB0eXBlIHtIVE1MSW5wdXRFbGVtZW50fSAqL1xuICAgIGNvbnN0IGNoZWNrYm94ID0gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMuY2hlY2tib3h9IGlucHV0YCk7XG4gICAgY29uc3QgdGV4dGFyZWEgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnRleHRhcmVhKTtcbiAgICBpbnB1dC5vbmlucHV0ID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICAgIGZpbGUub25jaGFuZ2UgPSByZXNldFZhbGlkYXRpb25NZXNzYWdlJDE7XG4gICAgc2VsZWN0Lm9uY2hhbmdlID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICAgIHRleHRhcmVhLm9uaW5wdXQgPSByZXNldFZhbGlkYXRpb25NZXNzYWdlJDE7XG4gICAgcmFuZ2Uub25pbnB1dCA9ICgpID0+IHtcbiAgICAgIHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMSgpO1xuICAgICAgcmFuZ2VPdXRwdXQudmFsdWUgPSByYW5nZS52YWx1ZTtcbiAgICB9O1xuICAgIHJhbmdlLm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxKCk7XG4gICAgICByYW5nZU91dHB1dC52YWx1ZSA9IHJhbmdlLnZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgSFRNTEVsZW1lbnR9IHRhcmdldFxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBjb25zdCBnZXRUYXJnZXQgPSB0YXJnZXQgPT4gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCkgOiB0YXJnZXQ7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3Qgc2V0dXBBY2Nlc3NpYmlsaXR5ID0gcGFyYW1zID0+IHtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgcG9wdXAuc2V0QXR0cmlidXRlKCdyb2xlJywgcGFyYW1zLnRvYXN0ID8gJ2FsZXJ0JyA6ICdkaWFsb2cnKTtcbiAgICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsIHBhcmFtcy50b2FzdCA/ICdwb2xpdGUnIDogJ2Fzc2VydGl2ZScpO1xuICAgIGlmICghcGFyYW1zLnRvYXN0KSB7XG4gICAgICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCAndHJ1ZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0RWxlbWVudFxuICAgKi9cbiAgY29uc3Qgc2V0dXBSVEwgPSB0YXJnZXRFbGVtZW50ID0+IHtcbiAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0RWxlbWVudCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgYWRkQ2xhc3MoZ2V0Q29udGFpbmVyKCksIHN3YWxDbGFzc2VzLnJ0bCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgbW9kYWwgKyBiYWNrZHJvcCArIG5vLXdhciBtZXNzYWdlIGZvciBSdXNzaWFucyB0byBET01cbiAgICpcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCBpbml0ID0gcGFyYW1zID0+IHtcbiAgICAvLyBDbGVhbiB1cCB0aGUgb2xkIHBvcHVwIGNvbnRhaW5lciBpZiBpdCBleGlzdHNcbiAgICBjb25zdCBvbGRDb250YWluZXJFeGlzdGVkID0gcmVzZXRPbGRDb250YWluZXIoKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc05vZGVFbnYoKSkge1xuICAgICAgZXJyb3IoJ1N3ZWV0QWxlcnQyIHJlcXVpcmVzIGRvY3VtZW50IHRvIGluaXRpYWxpemUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzLmNvbnRhaW5lcjtcbiAgICBpZiAob2xkQ29udGFpbmVyRXhpc3RlZCkge1xuICAgICAgYWRkQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlc1snbm8tdHJhbnNpdGlvbiddKTtcbiAgICB9XG4gICAgc2V0SW5uZXJIdG1sKGNvbnRhaW5lciwgc3dlZXRIVE1MKTtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZ2V0VGFyZ2V0KHBhcmFtcy50YXJnZXQpO1xuICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICBzZXR1cEFjY2Vzc2liaWxpdHkocGFyYW1zKTtcbiAgICBzZXR1cFJUTCh0YXJnZXRFbGVtZW50KTtcbiAgICBhZGRJbnB1dENoYW5nZUxpc3RlbmVycygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgb2JqZWN0IHwgc3RyaW5nfSBwYXJhbVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAgICovXG4gIGNvbnN0IHBhcnNlSHRtbFRvQ29udGFpbmVyID0gKHBhcmFtLCB0YXJnZXQpID0+IHtcbiAgICAvLyBET00gZWxlbWVudFxuICAgIGlmIChwYXJhbSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQocGFyYW0pO1xuICAgIH1cblxuICAgIC8vIE9iamVjdFxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGhhbmRsZU9iamVjdChwYXJhbSwgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICAvLyBQbGFpbiBzdHJpbmdcbiAgICBlbHNlIGlmIChwYXJhbSkge1xuICAgICAgc2V0SW5uZXJIdG1sKHRhcmdldCwgcGFyYW0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldFxuICAgKi9cbiAgY29uc3QgaGFuZGxlT2JqZWN0ID0gKHBhcmFtLCB0YXJnZXQpID0+IHtcbiAgICAvLyBKUXVlcnkgZWxlbWVudChzKVxuICAgIGlmIChwYXJhbS5qcXVlcnkpIHtcbiAgICAgIGhhbmRsZUpxdWVyeUVsZW0odGFyZ2V0LCBwYXJhbSk7XG4gICAgfVxuXG4gICAgLy8gRm9yIG90aGVyIG9iamVjdHMgdXNlIHRoZWlyIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIGVsc2Uge1xuICAgICAgc2V0SW5uZXJIdG1sKHRhcmdldCwgcGFyYW0udG9TdHJpbmcoKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKi9cbiAgY29uc3QgaGFuZGxlSnF1ZXJ5RWxlbSA9ICh0YXJnZXQsIGVsZW0pID0+IHtcbiAgICB0YXJnZXQudGV4dENvbnRlbnQgPSAnJztcbiAgICBpZiAoMCBpbiBlbGVtKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgKGkgaW4gZWxlbSk7IGkrKykge1xuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbVtpXS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWxlbS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybnMgeyd3ZWJraXRBbmltYXRpb25FbmQnIHwgJ2FuaW1hdGlvbmVuZCcgfCBmYWxzZX1cbiAgICovXG4gIGNvbnN0IGFuaW1hdGlvbkVuZEV2ZW50ID0gKCgpID0+IHtcbiAgICAvLyBQcmV2ZW50IHJ1biBpbiBOb2RlIGVudlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc05vZGVFbnYoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB0ZXN0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCB0cmFuc0VuZEV2ZW50TmFtZXMgPSB7XG4gICAgICBXZWJraXRBbmltYXRpb246ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgICAgLy8gQ2hyb21lLCBTYWZhcmkgYW5kIE9wZXJhXG4gICAgICBhbmltYXRpb246ICdhbmltYXRpb25lbmQnIC8vIFN0YW5kYXJkIHN5bnRheFxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IGkgaW4gdHJhbnNFbmRFdmVudE5hbWVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRyYW5zRW5kRXZlbnROYW1lcywgaSkgJiYgdHlwZW9mIHRlc3RFbC5zdHlsZVtpXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zRW5kRXZlbnROYW1lc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KSgpO1xuXG4gIC8qKlxuICAgKiBNZWFzdXJlIHNjcm9sbGJhciB3aWR0aCBmb3IgcGFkZGluZyBib2R5IGR1cmluZyBtb2RhbCBzaG93L2hpZGVcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL2pzL3NyYy9tb2RhbC5qc1xuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgY29uc3QgbWVhc3VyZVNjcm9sbGJhciA9ICgpID0+IHtcbiAgICBjb25zdCBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gc3dhbENsYXNzZXNbJ3Njcm9sbGJhci1tZWFzdXJlJ107XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICByZXR1cm4gc2Nyb2xsYmFyV2lkdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgcmVuZGVyQWN0aW9ucyA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgYWN0aW9ucyA9IGdldEFjdGlvbnMoKTtcbiAgICBjb25zdCBsb2FkZXIgPSBnZXRMb2FkZXIoKTtcblxuICAgIC8vIEFjdGlvbnMgKGJ1dHRvbnMpIHdyYXBwZXJcbiAgICBpZiAoIXBhcmFtcy5zaG93Q29uZmlybUJ1dHRvbiAmJiAhcGFyYW1zLnNob3dEZW55QnV0dG9uICYmICFwYXJhbXMuc2hvd0NhbmNlbEJ1dHRvbikge1xuICAgICAgaGlkZShhY3Rpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdyhhY3Rpb25zKTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gY2xhc3NcbiAgICBhcHBseUN1c3RvbUNsYXNzKGFjdGlvbnMsIHBhcmFtcywgJ2FjdGlvbnMnKTtcblxuICAgIC8vIFJlbmRlciBhbGwgdGhlIGJ1dHRvbnNcbiAgICByZW5kZXJCdXR0b25zKGFjdGlvbnMsIGxvYWRlciwgcGFyYW1zKTtcblxuICAgIC8vIExvYWRlclxuICAgIHNldElubmVySHRtbChsb2FkZXIsIHBhcmFtcy5sb2FkZXJIdG1sKTtcbiAgICBhcHBseUN1c3RvbUNsYXNzKGxvYWRlciwgcGFyYW1zLCAnbG9hZGVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGFjdGlvbnNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbG9hZGVyXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyQnV0dG9ucyhhY3Rpb25zLCBsb2FkZXIsIHBhcmFtcykge1xuICAgIGNvbnN0IGNvbmZpcm1CdXR0b24gPSBnZXRDb25maXJtQnV0dG9uKCk7XG4gICAgY29uc3QgZGVueUJ1dHRvbiA9IGdldERlbnlCdXR0b24oKTtcbiAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBnZXRDYW5jZWxCdXR0b24oKTtcblxuICAgIC8vIFJlbmRlciBidXR0b25zXG4gICAgcmVuZGVyQnV0dG9uKGNvbmZpcm1CdXR0b24sICdjb25maXJtJywgcGFyYW1zKTtcbiAgICByZW5kZXJCdXR0b24oZGVueUJ1dHRvbiwgJ2RlbnknLCBwYXJhbXMpO1xuICAgIHJlbmRlckJ1dHRvbihjYW5jZWxCdXR0b24sICdjYW5jZWwnLCBwYXJhbXMpO1xuICAgIGhhbmRsZUJ1dHRvbnNTdHlsaW5nKGNvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbiwgcGFyYW1zKTtcbiAgICBpZiAocGFyYW1zLnJldmVyc2VCdXR0b25zKSB7XG4gICAgICBpZiAocGFyYW1zLnRvYXN0KSB7XG4gICAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGNhbmNlbEJ1dHRvbiwgY29uZmlybUJ1dHRvbik7XG4gICAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGRlbnlCdXR0b24sIGNvbmZpcm1CdXR0b24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9ucy5pbnNlcnRCZWZvcmUoY2FuY2VsQnV0dG9uLCBsb2FkZXIpO1xuICAgICAgICBhY3Rpb25zLmluc2VydEJlZm9yZShkZW55QnV0dG9uLCBsb2FkZXIpO1xuICAgICAgICBhY3Rpb25zLmluc2VydEJlZm9yZShjb25maXJtQnV0dG9uLCBsb2FkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb25maXJtQnV0dG9uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRlbnlCdXR0b25cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2FuY2VsQnV0dG9uXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlQnV0dG9uc1N0eWxpbmcoY29uZmlybUJ1dHRvbiwgZGVueUJ1dHRvbiwgY2FuY2VsQnV0dG9uLCBwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcy5idXR0b25zU3R5bGluZykge1xuICAgICAgcmVtb3ZlQ2xhc3MoW2NvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbl0sIHN3YWxDbGFzc2VzLnN0eWxlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFkZENsYXNzKFtjb25maXJtQnV0dG9uLCBkZW55QnV0dG9uLCBjYW5jZWxCdXR0b25dLCBzd2FsQ2xhc3Nlcy5zdHlsZWQpO1xuXG4gICAgLy8gQnV0dG9ucyBiYWNrZ3JvdW5kIGNvbG9yc1xuICAgIGlmIChwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yKSB7XG4gICAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBhcmFtcy5jb25maXJtQnV0dG9uQ29sb3I7XG4gICAgICBhZGRDbGFzcyhjb25maXJtQnV0dG9uLCBzd2FsQ2xhc3Nlc1snZGVmYXVsdC1vdXRsaW5lJ10pO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmRlbnlCdXR0b25Db2xvcikge1xuICAgICAgZGVueUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwYXJhbXMuZGVueUJ1dHRvbkNvbG9yO1xuICAgICAgYWRkQ2xhc3MoZGVueUJ1dHRvbiwgc3dhbENsYXNzZXNbJ2RlZmF1bHQtb3V0bGluZSddKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jYW5jZWxCdXR0b25Db2xvcikge1xuICAgICAgY2FuY2VsQnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHBhcmFtcy5jYW5jZWxCdXR0b25Db2xvcjtcbiAgICAgIGFkZENsYXNzKGNhbmNlbEJ1dHRvbiwgc3dhbENsYXNzZXNbJ2RlZmF1bHQtb3V0bGluZSddKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYnV0dG9uXG4gICAqIEBwYXJhbSB7J2NvbmZpcm0nIHwgJ2RlbnknIHwgJ2NhbmNlbCd9IGJ1dHRvblR5cGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJCdXR0b24oYnV0dG9uLCBidXR0b25UeXBlLCBwYXJhbXMpIHtcbiAgICB0b2dnbGUoYnV0dG9uLCBwYXJhbXNbYHNob3cke2NhcGl0YWxpemVGaXJzdExldHRlcihidXR0b25UeXBlKX1CdXR0b25gXSwgJ2lubGluZS1ibG9jaycpO1xuICAgIHNldElubmVySHRtbChidXR0b24sIHBhcmFtc1tgJHtidXR0b25UeXBlfUJ1dHRvblRleHRgXSk7IC8vIFNldCBjYXB0aW9uIHRleHRcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgcGFyYW1zW2Ake2J1dHRvblR5cGV9QnV0dG9uQXJpYUxhYmVsYF0pOyAvLyBBUklBIGxhYmVsXG5cbiAgICAvLyBBZGQgYnV0dG9ucyBjdXN0b20gY2xhc3Nlc1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlc1tidXR0b25UeXBlXTtcbiAgICBhcHBseUN1c3RvbUNsYXNzKGJ1dHRvbiwgcGFyYW1zLCBgJHtidXR0b25UeXBlfUJ1dHRvbmApO1xuICAgIGFkZENsYXNzKGJ1dHRvbiwgcGFyYW1zW2Ake2J1dHRvblR5cGV9QnV0dG9uQ2xhc3NgXSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCByZW5kZXJDbG9zZUJ1dHRvbiA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgY2xvc2VCdXR0b24gPSBnZXRDbG9zZUJ1dHRvbigpO1xuICAgIHNldElubmVySHRtbChjbG9zZUJ1dHRvbiwgcGFyYW1zLmNsb3NlQnV0dG9uSHRtbCk7XG5cbiAgICAvLyBDdXN0b20gY2xhc3NcbiAgICBhcHBseUN1c3RvbUNsYXNzKGNsb3NlQnV0dG9uLCBwYXJhbXMsICdjbG9zZUJ1dHRvbicpO1xuICAgIHRvZ2dsZShjbG9zZUJ1dHRvbiwgcGFyYW1zLnNob3dDbG9zZUJ1dHRvbik7XG4gICAgY2xvc2VCdXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgcGFyYW1zLmNsb3NlQnV0dG9uQXJpYUxhYmVsKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCByZW5kZXJDb250YWluZXIgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGhhbmRsZUJhY2tkcm9wUGFyYW0oY29udGFpbmVyLCBwYXJhbXMuYmFja2Ryb3ApO1xuICAgIGhhbmRsZVBvc2l0aW9uUGFyYW0oY29udGFpbmVyLCBwYXJhbXMucG9zaXRpb24pO1xuICAgIGhhbmRsZUdyb3dQYXJhbShjb250YWluZXIsIHBhcmFtcy5ncm93KTtcblxuICAgIC8vIEN1c3RvbSBjbGFzc1xuICAgIGFwcGx5Q3VzdG9tQ2xhc3MoY29udGFpbmVyLCBwYXJhbXMsICdjb250YWluZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ2JhY2tkcm9wJ119IGJhY2tkcm9wXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVCYWNrZHJvcFBhcmFtKGNvbnRhaW5lciwgYmFja2Ryb3ApIHtcbiAgICBpZiAodHlwZW9mIGJhY2tkcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmQgPSBiYWNrZHJvcDtcbiAgICB9IGVsc2UgaWYgKCFiYWNrZHJvcCkge1xuICAgICAgYWRkQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIHN3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ3Bvc2l0aW9uJ119IHBvc2l0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVQb3NpdGlvblBhcmFtKGNvbnRhaW5lciwgcG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gaW4gc3dhbENsYXNzZXMpIHtcbiAgICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbcG9zaXRpb25dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybignVGhlIFwicG9zaXRpb25cIiBwYXJhbWV0ZXIgaXMgbm90IHZhbGlkLCBkZWZhdWx0aW5nIHRvIFwiY2VudGVyXCInKTtcbiAgICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXMuY2VudGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ2dyb3cnXX0gZ3Jvd1xuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlR3Jvd1BhcmFtKGNvbnRhaW5lciwgZ3Jvdykge1xuICAgIGlmIChncm93ICYmIHR5cGVvZiBncm93ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZ3Jvd0NsYXNzID0gYGdyb3ctJHtncm93fWA7XG4gICAgICBpZiAoZ3Jvd0NsYXNzIGluIHN3YWxDbGFzc2VzKSB7XG4gICAgICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbZ3Jvd0NsYXNzXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uLy4uLy4uLy4uL3N3ZWV0YWxlcnQyLmQudHNcIi8+XG5cbiAgLyoqIEB0eXBlIHtJbnB1dENsYXNzW119ICovXG4gIGNvbnN0IGlucHV0Q2xhc3NlcyA9IFsnaW5wdXQnLCAnZmlsZScsICdyYW5nZScsICdzZWxlY3QnLCAncmFkaW8nLCAnY2hlY2tib3gnLCAndGV4dGFyZWEnXTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCByZW5kZXJJbnB1dCA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgY29uc3QgcmVyZW5kZXIgPSAhaW5uZXJQYXJhbXMgfHwgcGFyYW1zLmlucHV0ICE9PSBpbm5lclBhcmFtcy5pbnB1dDtcbiAgICBpbnB1dENsYXNzZXMuZm9yRWFjaChpbnB1dENsYXNzID0+IHtcbiAgICAgIGNvbnN0IGlucHV0Q29udGFpbmVyID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlc1tpbnB1dENsYXNzXSk7XG5cbiAgICAgIC8vIHNldCBhdHRyaWJ1dGVzXG4gICAgICBzZXRBdHRyaWJ1dGVzKGlucHV0Q2xhc3MsIHBhcmFtcy5pbnB1dEF0dHJpYnV0ZXMpO1xuXG4gICAgICAvLyBzZXQgY2xhc3NcbiAgICAgIGlucHV0Q29udGFpbmVyLmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzW2lucHV0Q2xhc3NdO1xuICAgICAgaWYgKHJlcmVuZGVyKSB7XG4gICAgICAgIGhpZGUoaW5wdXRDb250YWluZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChwYXJhbXMuaW5wdXQpIHtcbiAgICAgIGlmIChyZXJlbmRlcikge1xuICAgICAgICBzaG93SW5wdXQocGFyYW1zKTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCBjdXN0b20gY2xhc3NcbiAgICAgIHNldEN1c3RvbUNsYXNzKHBhcmFtcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHNob3dJbnB1dCA9IHBhcmFtcyA9PiB7XG4gICAgaWYgKCFyZW5kZXJJbnB1dFR5cGVbcGFyYW1zLmlucHV0XSkge1xuICAgICAgZXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBvZiBpbnB1dCEgRXhwZWN0ZWQgXCJ0ZXh0XCIsIFwiZW1haWxcIiwgXCJwYXNzd29yZFwiLCBcIm51bWJlclwiLCBcInRlbFwiLCBcInNlbGVjdFwiLCBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiwgXCJ0ZXh0YXJlYVwiLCBcImZpbGVcIiBvciBcInVybFwiLCBnb3QgXCIke3BhcmFtcy5pbnB1dH1cImApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dENvbnRhaW5lciA9IGdldElucHV0Q29udGFpbmVyKHBhcmFtcy5pbnB1dCk7XG4gICAgY29uc3QgaW5wdXQgPSByZW5kZXJJbnB1dFR5cGVbcGFyYW1zLmlucHV0XShpbnB1dENvbnRhaW5lciwgcGFyYW1zKTtcbiAgICBzaG93KGlucHV0Q29udGFpbmVyKTtcblxuICAgIC8vIGlucHV0IGF1dG9mb2N1c1xuICAgIGlmIChwYXJhbXMuaW5wdXRBdXRvRm9jdXMpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBmb2N1c0lucHV0KGlucHV0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICAgKi9cbiAgY29uc3QgcmVtb3ZlQXR0cmlidXRlcyA9IGlucHV0ID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0LmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJOYW1lID0gaW5wdXQuYXR0cmlidXRlc1tpXS5uYW1lO1xuICAgICAgaWYgKCFbJ3R5cGUnLCAndmFsdWUnLCAnc3R5bGUnXS5pbmNsdWRlcyhhdHRyTmFtZSkpIHtcbiAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SW5wdXRDbGFzc30gaW5wdXRDbGFzc1xuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydpbnB1dEF0dHJpYnV0ZXMnXX0gaW5wdXRBdHRyaWJ1dGVzXG4gICAqL1xuICBjb25zdCBzZXRBdHRyaWJ1dGVzID0gKGlucHV0Q2xhc3MsIGlucHV0QXR0cmlidXRlcykgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gZ2V0SW5wdXQkMShnZXRQb3B1cCgpLCBpbnB1dENsYXNzKTtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlbW92ZUF0dHJpYnV0ZXMoaW5wdXQpO1xuICAgIGZvciAoY29uc3QgYXR0ciBpbiBpbnB1dEF0dHJpYnV0ZXMpIHtcbiAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShhdHRyLCBpbnB1dEF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCBzZXRDdXN0b21DbGFzcyA9IHBhcmFtcyA9PiB7XG4gICAgY29uc3QgaW5wdXRDb250YWluZXIgPSBnZXRJbnB1dENvbnRhaW5lcihwYXJhbXMuaW5wdXQpO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLmN1c3RvbUNsYXNzID09PSAnb2JqZWN0Jykge1xuICAgICAgYWRkQ2xhc3MoaW5wdXRDb250YWluZXIsIHBhcmFtcy5jdXN0b21DbGFzcy5pbnB1dCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50fSBpbnB1dFxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHNldElucHV0UGxhY2Vob2xkZXIgPSAoaW5wdXQsIHBhcmFtcykgPT4ge1xuICAgIGlmICghaW5wdXQucGxhY2Vob2xkZXIgfHwgcGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpIHtcbiAgICAgIGlucHV0LnBsYWNlaG9sZGVyID0gcGFyYW1zLmlucHV0UGxhY2Vob2xkZXI7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lucHV0fSBpbnB1dFxuICAgKiBAcGFyYW0ge0lucHV0fSBwcmVwZW5kVG9cbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCBzZXRJbnB1dExhYmVsID0gKGlucHV0LCBwcmVwZW5kVG8sIHBhcmFtcykgPT4ge1xuICAgIGlmIChwYXJhbXMuaW5wdXRMYWJlbCkge1xuICAgICAgaW5wdXQuaWQgPSBzd2FsQ2xhc3Nlcy5pbnB1dDtcbiAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgIGNvbnN0IGxhYmVsQ2xhc3MgPSBzd2FsQ2xhc3Nlc1snaW5wdXQtbGFiZWwnXTtcbiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgnZm9yJywgaW5wdXQuaWQpO1xuICAgICAgbGFiZWwuY2xhc3NOYW1lID0gbGFiZWxDbGFzcztcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zLmN1c3RvbUNsYXNzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBhZGRDbGFzcyhsYWJlbCwgcGFyYW1zLmN1c3RvbUNsYXNzLmlucHV0TGFiZWwpO1xuICAgICAgfVxuICAgICAgbGFiZWwuaW5uZXJUZXh0ID0gcGFyYW1zLmlucHV0TGFiZWw7XG4gICAgICBwcmVwZW5kVG8uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdiZWZvcmViZWdpbicsIGxhYmVsKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0J119IGlucHV0VHlwZVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBjb25zdCBnZXRJbnB1dENvbnRhaW5lciA9IGlucHV0VHlwZSA9PiB7XG4gICAgcmV0dXJuIGdldERpcmVjdENoaWxkQnlDbGFzcyhnZXRQb3B1cCgpLCBzd2FsQ2xhc3Nlc1tpbnB1dFR5cGVdIHx8IHN3YWxDbGFzc2VzLmlucHV0KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50IHwgSFRNTE91dHB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50fSBpbnB1dFxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydpbnB1dFZhbHVlJ119IGlucHV0VmFsdWVcbiAgICovXG4gIGNvbnN0IGNoZWNrQW5kU2V0SW5wdXRWYWx1ZSA9IChpbnB1dCwgaW5wdXRWYWx1ZSkgPT4ge1xuICAgIGlmIChbJ3N0cmluZycsICdudW1iZXInXS5pbmNsdWRlcyh0eXBlb2YgaW5wdXRWYWx1ZSkpIHtcbiAgICAgIGlucHV0LnZhbHVlID0gYCR7aW5wdXRWYWx1ZX1gO1xuICAgIH0gZWxzZSBpZiAoIWlzUHJvbWlzZShpbnB1dFZhbHVlKSkge1xuICAgICAgd2FybihgVW5leHBlY3RlZCB0eXBlIG9mIGlucHV0VmFsdWUhIEV4cGVjdGVkIFwic3RyaW5nXCIsIFwibnVtYmVyXCIgb3IgXCJQcm9taXNlXCIsIGdvdCBcIiR7dHlwZW9mIGlucHV0VmFsdWV9XCJgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCAoaW5wdXQ6IElucHV0IHwgSFRNTEVsZW1lbnQsIHBhcmFtczogU3dlZXRBbGVydE9wdGlvbnMpID0+IElucHV0Pn0gKi9cbiAgY29uc3QgcmVuZGVySW5wdXRUeXBlID0ge307XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVySW5wdXRUeXBlLnRleHQgPSByZW5kZXJJbnB1dFR5cGUuZW1haWwgPSByZW5kZXJJbnB1dFR5cGUucGFzc3dvcmQgPSByZW5kZXJJbnB1dFR5cGUubnVtYmVyID0gcmVuZGVySW5wdXRUeXBlLnRlbCA9IHJlbmRlcklucHV0VHlwZS51cmwgPSAoaW5wdXQsIHBhcmFtcykgPT4ge1xuICAgIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZShpbnB1dCwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICAgIHNldElucHV0TGFiZWwoaW5wdXQsIGlucHV0LCBwYXJhbXMpO1xuICAgIHNldElucHV0UGxhY2Vob2xkZXIoaW5wdXQsIHBhcmFtcyk7XG4gICAgaW5wdXQudHlwZSA9IHBhcmFtcy5pbnB1dDtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVySW5wdXRUeXBlLmZpbGUgPSAoaW5wdXQsIHBhcmFtcykgPT4ge1xuICAgIHNldElucHV0TGFiZWwoaW5wdXQsIGlucHV0LCBwYXJhbXMpO1xuICAgIHNldElucHV0UGxhY2Vob2xkZXIoaW5wdXQsIHBhcmFtcyk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IHJhbmdlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAgICovXG4gIHJlbmRlcklucHV0VHlwZS5yYW5nZSA9IChyYW5nZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgcmFuZ2VJbnB1dCA9IHJhbmdlLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgY29uc3QgcmFuZ2VPdXRwdXQgPSByYW5nZS5xdWVyeVNlbGVjdG9yKCdvdXRwdXQnKTtcbiAgICBjaGVja0FuZFNldElucHV0VmFsdWUocmFuZ2VJbnB1dCwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICAgIHJhbmdlSW5wdXQudHlwZSA9IHBhcmFtcy5pbnB1dDtcbiAgICBjaGVja0FuZFNldElucHV0VmFsdWUocmFuZ2VPdXRwdXQsIHBhcmFtcy5pbnB1dFZhbHVlKTtcbiAgICBzZXRJbnB1dExhYmVsKHJhbmdlSW5wdXQsIHJhbmdlLCBwYXJhbXMpO1xuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MU2VsZWN0RWxlbWVudH0gc2VsZWN0XG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7SFRNTFNlbGVjdEVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJJbnB1dFR5cGUuc2VsZWN0ID0gKHNlbGVjdCwgcGFyYW1zKSA9PiB7XG4gICAgc2VsZWN0LnRleHRDb250ZW50ID0gJyc7XG4gICAgaWYgKHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyKSB7XG4gICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgc2V0SW5uZXJIdG1sKHBsYWNlaG9sZGVyLCBwYXJhbXMuaW5wdXRQbGFjZWhvbGRlcik7XG4gICAgICBwbGFjZWhvbGRlci52YWx1ZSA9ICcnO1xuICAgICAgcGxhY2Vob2xkZXIuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgcGxhY2Vob2xkZXIuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKHBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgc2V0SW5wdXRMYWJlbChzZWxlY3QsIHNlbGVjdCwgcGFyYW1zKTtcbiAgICByZXR1cm4gc2VsZWN0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IHJhZGlvXG4gICAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVySW5wdXRUeXBlLnJhZGlvID0gcmFkaW8gPT4ge1xuICAgIHJhZGlvLnRleHRDb250ZW50ID0gJyc7XG4gICAgcmV0dXJuIHJhZGlvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxMYWJlbEVsZW1lbnR9IGNoZWNrYm94Q29udGFpbmVyXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7SFRNTElucHV0RWxlbWVudH1cbiAgICovXG4gIHJlbmRlcklucHV0VHlwZS5jaGVja2JveCA9IChjaGVja2JveENvbnRhaW5lciwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgY2hlY2tib3ggPSBnZXRJbnB1dCQxKGdldFBvcHVwKCksICdjaGVja2JveCcpO1xuICAgIGNoZWNrYm94LnZhbHVlID0gJzEnO1xuICAgIGNoZWNrYm94LmlkID0gc3dhbENsYXNzZXMuY2hlY2tib3g7XG4gICAgY2hlY2tib3guY2hlY2tlZCA9IEJvb2xlYW4ocGFyYW1zLmlucHV0VmFsdWUpO1xuICAgIGNvbnN0IGxhYmVsID0gY2hlY2tib3hDb250YWluZXIucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgIHNldElubmVySHRtbChsYWJlbCwgcGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpO1xuICAgIHJldHVybiBjaGVja2JveDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MVGV4dEFyZWFFbGVtZW50fSB0ZXh0YXJlYVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICogQHJldHVybnMge0hUTUxUZXh0QXJlYUVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJJbnB1dFR5cGUudGV4dGFyZWEgPSAodGV4dGFyZWEsIHBhcmFtcykgPT4ge1xuICAgIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZSh0ZXh0YXJlYSwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICAgIHNldElucHV0UGxhY2Vob2xkZXIodGV4dGFyZWEsIHBhcmFtcyk7XG4gICAgc2V0SW5wdXRMYWJlbCh0ZXh0YXJlYSwgdGV4dGFyZWEsIHBhcmFtcyk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgY29uc3QgZ2V0TWFyZ2luID0gZWwgPT4gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLm1hcmdpbkxlZnQpICsgcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpLm1hcmdpblJpZ2h0KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjI5MVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xNjk5XG4gICAgICBpZiAoJ011dGF0aW9uT2JzZXJ2ZXInIGluIHdpbmRvdykge1xuICAgICAgICBjb25zdCBpbml0aWFsUG9wdXBXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGdldFBvcHVwKCkpLndpZHRoKTtcbiAgICAgICAgY29uc3QgdGV4dGFyZWFSZXNpemVIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRleHRhcmVhV2lkdGggPSB0ZXh0YXJlYS5vZmZzZXRXaWR0aCArIGdldE1hcmdpbih0ZXh0YXJlYSk7XG4gICAgICAgICAgaWYgKHRleHRhcmVhV2lkdGggPiBpbml0aWFsUG9wdXBXaWR0aCkge1xuICAgICAgICAgICAgZ2V0UG9wdXAoKS5zdHlsZS53aWR0aCA9IGAke3RleHRhcmVhV2lkdGh9cHhgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQb3B1cCgpLnN0eWxlLndpZHRoID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKHRleHRhcmVhUmVzaXplSGFuZGxlcikub2JzZXJ2ZSh0ZXh0YXJlYSwge1xuICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbJ3N0eWxlJ11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRleHRhcmVhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHJlbmRlckNvbnRlbnQgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGh0bWxDb250YWluZXIgPSBnZXRIdG1sQ29udGFpbmVyKCk7XG4gICAgYXBwbHlDdXN0b21DbGFzcyhodG1sQ29udGFpbmVyLCBwYXJhbXMsICdodG1sQ29udGFpbmVyJyk7XG5cbiAgICAvLyBDb250ZW50IGFzIEhUTUxcbiAgICBpZiAocGFyYW1zLmh0bWwpIHtcbiAgICAgIHBhcnNlSHRtbFRvQ29udGFpbmVyKHBhcmFtcy5odG1sLCBodG1sQ29udGFpbmVyKTtcbiAgICAgIHNob3coaHRtbENvbnRhaW5lciwgJ2Jsb2NrJyk7XG4gICAgfVxuXG4gICAgLy8gQ29udGVudCBhcyBwbGFpbiB0ZXh0XG4gICAgZWxzZSBpZiAocGFyYW1zLnRleHQpIHtcbiAgICAgIGh0bWxDb250YWluZXIudGV4dENvbnRlbnQgPSBwYXJhbXMudGV4dDtcbiAgICAgIHNob3coaHRtbENvbnRhaW5lciwgJ2Jsb2NrJyk7XG4gICAgfVxuXG4gICAgLy8gTm8gY29udGVudFxuICAgIGVsc2Uge1xuICAgICAgaGlkZShodG1sQ29udGFpbmVyKTtcbiAgICB9XG4gICAgcmVuZGVySW5wdXQoaW5zdGFuY2UsIHBhcmFtcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgcmVuZGVyRm9vdGVyID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBmb290ZXIgPSBnZXRGb290ZXIoKTtcbiAgICB0b2dnbGUoZm9vdGVyLCBwYXJhbXMuZm9vdGVyKTtcbiAgICBpZiAocGFyYW1zLmZvb3Rlcikge1xuICAgICAgcGFyc2VIdG1sVG9Db250YWluZXIocGFyYW1zLmZvb3RlciwgZm9vdGVyKTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gY2xhc3NcbiAgICBhcHBseUN1c3RvbUNsYXNzKGZvb3RlciwgcGFyYW1zLCAnZm9vdGVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgcmVuZGVySWNvbiA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgICBjb25zdCBpY29uID0gZ2V0SWNvbigpO1xuXG4gICAgLy8gaWYgdGhlIGdpdmVuIGljb24gYWxyZWFkeSByZW5kZXJlZCwgYXBwbHkgdGhlIHN0eWxpbmcgd2l0aG91dCByZS1yZW5kZXJpbmcgdGhlIGljb25cbiAgICBpZiAoaW5uZXJQYXJhbXMgJiYgcGFyYW1zLmljb24gPT09IGlubmVyUGFyYW1zLmljb24pIHtcbiAgICAgIC8vIEN1c3RvbSBvciBkZWZhdWx0IGNvbnRlbnRcbiAgICAgIHNldENvbnRlbnQoaWNvbiwgcGFyYW1zKTtcbiAgICAgIGFwcGx5U3R5bGVzKGljb24sIHBhcmFtcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcGFyYW1zLmljb24gJiYgIXBhcmFtcy5pY29uSHRtbCkge1xuICAgICAgaGlkZShpY29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5pY29uICYmIE9iamVjdC5rZXlzKGljb25UeXBlcykuaW5kZXhPZihwYXJhbXMuaWNvbikgPT09IC0xKSB7XG4gICAgICBlcnJvcihgVW5rbm93biBpY29uISBFeHBlY3RlZCBcInN1Y2Nlc3NcIiwgXCJlcnJvclwiLCBcIndhcm5pbmdcIiwgXCJpbmZvXCIgb3IgXCJxdWVzdGlvblwiLCBnb3QgXCIke3BhcmFtcy5pY29ufVwiYCk7XG4gICAgICBoaWRlKGljb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzaG93KGljb24pO1xuXG4gICAgLy8gQ3VzdG9tIG9yIGRlZmF1bHQgY29udGVudFxuICAgIHNldENvbnRlbnQoaWNvbiwgcGFyYW1zKTtcbiAgICBhcHBseVN0eWxlcyhpY29uLCBwYXJhbXMpO1xuXG4gICAgLy8gQW5pbWF0ZSBpY29uXG4gICAgYWRkQ2xhc3MoaWNvbiwgcGFyYW1zLnNob3dDbGFzcy5pY29uKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaWNvblxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IGFwcGx5U3R5bGVzID0gKGljb24sIHBhcmFtcykgPT4ge1xuICAgIGZvciAoY29uc3QgaWNvblR5cGUgaW4gaWNvblR5cGVzKSB7XG4gICAgICBpZiAocGFyYW1zLmljb24gIT09IGljb25UeXBlKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKGljb24sIGljb25UeXBlc1tpY29uVHlwZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBhZGRDbGFzcyhpY29uLCBpY29uVHlwZXNbcGFyYW1zLmljb25dKTtcblxuICAgIC8vIEljb24gY29sb3JcbiAgICBzZXRDb2xvcihpY29uLCBwYXJhbXMpO1xuXG4gICAgLy8gU3VjY2VzcyBpY29uIGJhY2tncm91bmQgY29sb3JcbiAgICBhZGp1c3RTdWNjZXNzSWNvbkJhY2tncm91bmRDb2xvcigpO1xuXG4gICAgLy8gQ3VzdG9tIGNsYXNzXG4gICAgYXBwbHlDdXN0b21DbGFzcyhpY29uLCBwYXJhbXMsICdpY29uJyk7XG4gIH07XG5cbiAgLy8gQWRqdXN0IHN1Y2Nlc3MgaWNvbiBiYWNrZ3JvdW5kIGNvbG9yIHRvIG1hdGNoIHRoZSBwb3B1cCBiYWNrZ3JvdW5kIGNvbG9yXG4gIGNvbnN0IGFkanVzdFN1Y2Nlc3NJY29uQmFja2dyb3VuZENvbG9yID0gKCkgPT4ge1xuICAgIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgICBjb25zdCBwb3B1cEJhY2tncm91bmRDb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBvcHVwKS5nZXRQcm9wZXJ0eVZhbHVlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgLyoqIEB0eXBlIHtOb2RlTGlzdE9mPEhUTUxFbGVtZW50Pn0gKi9cbiAgICBjb25zdCBzdWNjZXNzSWNvblBhcnRzID0gcG9wdXAucXVlcnlTZWxlY3RvckFsbCgnW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVdLCAuc3dhbDItc3VjY2Vzcy1maXgnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Y2Nlc3NJY29uUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1Y2Nlc3NJY29uUGFydHNbaV0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcG9wdXBCYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICB9O1xuICBjb25zdCBzdWNjZXNzSWNvbkh0bWwgPSBgXG4gIDxkaXYgY2xhc3M9XCJzd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmUtbGVmdFwiPjwvZGl2PlxuICA8c3BhbiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtbGluZS10aXBcIj48L3NwYW4+IDxzcGFuIGNsYXNzPVwic3dhbDItc3VjY2Vzcy1saW5lLWxvbmdcIj48L3NwYW4+XG4gIDxkaXYgY2xhc3M9XCJzd2FsMi1zdWNjZXNzLXJpbmdcIj48L2Rpdj4gPGRpdiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtZml4XCI+PC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJzd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmUtcmlnaHRcIj48L2Rpdj5cbmA7XG4gIGNvbnN0IGVycm9ySWNvbkh0bWwgPSBgXG4gIDxzcGFuIGNsYXNzPVwic3dhbDIteC1tYXJrXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJzd2FsMi14LW1hcmstbGluZS1sZWZ0XCI+PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwic3dhbDIteC1tYXJrLWxpbmUtcmlnaHRcIj48L3NwYW4+XG4gIDwvc3Bhbj5cbmA7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGljb25cbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCBzZXRDb250ZW50ID0gKGljb24sIHBhcmFtcykgPT4ge1xuICAgIGxldCBvbGRDb250ZW50ID0gaWNvbi5pbm5lckhUTUw7XG4gICAgbGV0IG5ld0NvbnRlbnQ7XG4gICAgaWYgKHBhcmFtcy5pY29uSHRtbCkge1xuICAgICAgbmV3Q29udGVudCA9IGljb25Db250ZW50KHBhcmFtcy5pY29uSHRtbCk7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMuaWNvbiA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICBuZXdDb250ZW50ID0gc3VjY2Vzc0ljb25IdG1sO1xuICAgICAgb2xkQ29udGVudCA9IG9sZENvbnRlbnQucmVwbGFjZSgvIHN0eWxlPVwiLio/XCIvZywgJycpOyAvLyB1bmRvIGFkanVzdFN1Y2Nlc3NJY29uQmFja2dyb3VuZENvbG9yKClcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5pY29uID09PSAnZXJyb3InKSB7XG4gICAgICBuZXdDb250ZW50ID0gZXJyb3JJY29uSHRtbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZGVmYXVsdEljb25IdG1sID0ge1xuICAgICAgICBxdWVzdGlvbjogJz8nLFxuICAgICAgICB3YXJuaW5nOiAnIScsXG4gICAgICAgIGluZm86ICdpJ1xuICAgICAgfTtcbiAgICAgIG5ld0NvbnRlbnQgPSBpY29uQ29udGVudChkZWZhdWx0SWNvbkh0bWxbcGFyYW1zLmljb25dKTtcbiAgICB9XG4gICAgaWYgKG9sZENvbnRlbnQudHJpbSgpICE9PSBuZXdDb250ZW50LnRyaW0oKSkge1xuICAgICAgc2V0SW5uZXJIdG1sKGljb24sIG5ld0NvbnRlbnQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaWNvblxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHNldENvbG9yID0gKGljb24sIHBhcmFtcykgPT4ge1xuICAgIGlmICghcGFyYW1zLmljb25Db2xvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpY29uLnN0eWxlLmNvbG9yID0gcGFyYW1zLmljb25Db2xvcjtcbiAgICBpY29uLnN0eWxlLmJvcmRlckNvbG9yID0gcGFyYW1zLmljb25Db2xvcjtcbiAgICBmb3IgKGNvbnN0IHNlbCBvZiBbJy5zd2FsMi1zdWNjZXNzLWxpbmUtdGlwJywgJy5zd2FsMi1zdWNjZXNzLWxpbmUtbG9uZycsICcuc3dhbDIteC1tYXJrLWxpbmUtbGVmdCcsICcuc3dhbDIteC1tYXJrLWxpbmUtcmlnaHQnXSkge1xuICAgICAgc2V0U3R5bGUoaWNvbiwgc2VsLCAnYmFja2dyb3VuZENvbG9yJywgcGFyYW1zLmljb25Db2xvcik7XG4gICAgfVxuICAgIHNldFN0eWxlKGljb24sICcuc3dhbDItc3VjY2Vzcy1yaW5nJywgJ2JvcmRlckNvbG9yJywgcGFyYW1zLmljb25Db2xvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjb25zdCBpY29uQ29udGVudCA9IGNvbnRlbnQgPT4gYDxkaXYgY2xhc3M9XCIke3N3YWxDbGFzc2VzWydpY29uLWNvbnRlbnQnXX1cIj4ke2NvbnRlbnR9PC9kaXY+YDtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCByZW5kZXJJbWFnZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgaW1hZ2UgPSBnZXRJbWFnZSgpO1xuICAgIGlmICghcGFyYW1zLmltYWdlVXJsKSB7XG4gICAgICBoaWRlKGltYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2hvdyhpbWFnZSwgJycpO1xuXG4gICAgLy8gU3JjLCBhbHRcbiAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHBhcmFtcy5pbWFnZVVybCk7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKCdhbHQnLCBwYXJhbXMuaW1hZ2VBbHQpO1xuXG4gICAgLy8gV2lkdGgsIGhlaWdodFxuICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUoaW1hZ2UsICd3aWR0aCcsIHBhcmFtcy5pbWFnZVdpZHRoKTtcbiAgICBhcHBseU51bWVyaWNhbFN0eWxlKGltYWdlLCAnaGVpZ2h0JywgcGFyYW1zLmltYWdlSGVpZ2h0KTtcblxuICAgIC8vIENsYXNzXG4gICAgaW1hZ2UuY2xhc3NOYW1lID0gc3dhbENsYXNzZXMuaW1hZ2U7XG4gICAgYXBwbHlDdXN0b21DbGFzcyhpbWFnZSwgcGFyYW1zLCAnaW1hZ2UnKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCByZW5kZXJQb3B1cCA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuXG4gICAgLy8gV2lkdGhcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzIxNzBcbiAgICBpZiAocGFyYW1zLnRvYXN0KSB7XG4gICAgICBhcHBseU51bWVyaWNhbFN0eWxlKGNvbnRhaW5lciwgJ3dpZHRoJywgcGFyYW1zLndpZHRoKTtcbiAgICAgIHBvcHVwLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgcG9wdXAuaW5zZXJ0QmVmb3JlKGdldExvYWRlcigpLCBnZXRJY29uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBseU51bWVyaWNhbFN0eWxlKHBvcHVwLCAnd2lkdGgnLCBwYXJhbXMud2lkdGgpO1xuICAgIH1cblxuICAgIC8vIFBhZGRpbmdcbiAgICBhcHBseU51bWVyaWNhbFN0eWxlKHBvcHVwLCAncGFkZGluZycsIHBhcmFtcy5wYWRkaW5nKTtcblxuICAgIC8vIENvbG9yXG4gICAgaWYgKHBhcmFtcy5jb2xvcikge1xuICAgICAgcG9wdXAuc3R5bGUuY29sb3IgPSBwYXJhbXMuY29sb3I7XG4gICAgfVxuXG4gICAgLy8gQmFja2dyb3VuZFxuICAgIGlmIChwYXJhbXMuYmFja2dyb3VuZCkge1xuICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZCA9IHBhcmFtcy5iYWNrZ3JvdW5kO1xuICAgIH1cbiAgICBoaWRlKGdldFZhbGlkYXRpb25NZXNzYWdlKCkpO1xuXG4gICAgLy8gQ2xhc3Nlc1xuICAgIGFkZENsYXNzZXMkMShwb3B1cCwgcGFyYW1zKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCBhZGRDbGFzc2VzJDEgPSAocG9wdXAsIHBhcmFtcykgPT4ge1xuICAgIC8vIERlZmF1bHQgQ2xhc3MgKyBzaG93Q2xhc3Mgd2hlbiB1cGRhdGluZyBTd2FsLnVwZGF0ZSh7fSlcbiAgICBwb3B1cC5jbGFzc05hbWUgPSBgJHtzd2FsQ2xhc3Nlcy5wb3B1cH0gJHtpc1Zpc2libGUkMShwb3B1cCkgPyBwYXJhbXMuc2hvd0NsYXNzLnBvcHVwIDogJyd9YDtcbiAgICBpZiAocGFyYW1zLnRvYXN0KSB7XG4gICAgICBhZGRDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgc3dhbENsYXNzZXNbJ3RvYXN0LXNob3duJ10pO1xuICAgICAgYWRkQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnRvYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkQ2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLm1vZGFsKTtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gY2xhc3NcbiAgICBhcHBseUN1c3RvbUNsYXNzKHBvcHVwLCBwYXJhbXMsICdwb3B1cCcpO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLmN1c3RvbUNsYXNzID09PSAnc3RyaW5nJykge1xuICAgICAgYWRkQ2xhc3MocG9wdXAsIHBhcmFtcy5jdXN0b21DbGFzcyk7XG4gICAgfVxuXG4gICAgLy8gSWNvbiBjbGFzcyAoIzE4NDIpXG4gICAgaWYgKHBhcmFtcy5pY29uKSB7XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXNbYGljb24tJHtwYXJhbXMuaWNvbn1gXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHJlbmRlclByb2dyZXNzU3RlcHMgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHByb2dyZXNzU3RlcHNDb250YWluZXIgPSBnZXRQcm9ncmVzc1N0ZXBzKCk7XG4gICAgaWYgKCFwYXJhbXMucHJvZ3Jlc3NTdGVwcyB8fCBwYXJhbXMucHJvZ3Jlc3NTdGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGhpZGUocHJvZ3Jlc3NTdGVwc0NvbnRhaW5lcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNob3cocHJvZ3Jlc3NTdGVwc0NvbnRhaW5lcik7XG4gICAgcHJvZ3Jlc3NTdGVwc0NvbnRhaW5lci50ZXh0Q29udGVudCA9ICcnO1xuICAgIGlmIChwYXJhbXMuY3VycmVudFByb2dyZXNzU3RlcCA+PSBwYXJhbXMucHJvZ3Jlc3NTdGVwcy5sZW5ndGgpIHtcbiAgICAgIHdhcm4oJ0ludmFsaWQgY3VycmVudFByb2dyZXNzU3RlcCBwYXJhbWV0ZXIsIGl0IHNob3VsZCBiZSBsZXNzIHRoYW4gcHJvZ3Jlc3NTdGVwcy5sZW5ndGggJyArICcoY3VycmVudFByb2dyZXNzU3RlcCBsaWtlIEpTIGFycmF5cyBzdGFydHMgZnJvbSAwKScpO1xuICAgIH1cbiAgICBwYXJhbXMucHJvZ3Jlc3NTdGVwcy5mb3JFYWNoKChzdGVwLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qgc3RlcEVsID0gY3JlYXRlU3RlcEVsZW1lbnQoc3RlcCk7XG4gICAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLmFwcGVuZENoaWxkKHN0ZXBFbCk7XG4gICAgICBpZiAoaW5kZXggPT09IHBhcmFtcy5jdXJyZW50UHJvZ3Jlc3NTdGVwKSB7XG4gICAgICAgIGFkZENsYXNzKHN0ZXBFbCwgc3dhbENsYXNzZXNbJ2FjdGl2ZS1wcm9ncmVzcy1zdGVwJ10pO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ICE9PSBwYXJhbXMucHJvZ3Jlc3NTdGVwcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IGxpbmVFbCA9IGNyZWF0ZUxpbmVFbGVtZW50KHBhcmFtcyk7XG4gICAgICAgIHByb2dyZXNzU3RlcHNDb250YWluZXIuYXBwZW5kQ2hpbGQobGluZUVsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ZXBcbiAgICogQHJldHVybnMge0hUTUxMSUVsZW1lbnR9XG4gICAqL1xuICBjb25zdCBjcmVhdGVTdGVwRWxlbWVudCA9IHN0ZXAgPT4ge1xuICAgIGNvbnN0IHN0ZXBFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgYWRkQ2xhc3Moc3RlcEVsLCBzd2FsQ2xhc3Nlc1sncHJvZ3Jlc3Mtc3RlcCddKTtcbiAgICBzZXRJbm5lckh0bWwoc3RlcEVsLCBzdGVwKTtcbiAgICByZXR1cm4gc3RlcEVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICogQHJldHVybnMge0hUTUxMSUVsZW1lbnR9XG4gICAqL1xuICBjb25zdCBjcmVhdGVMaW5lRWxlbWVudCA9IHBhcmFtcyA9PiB7XG4gICAgY29uc3QgbGluZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICBhZGRDbGFzcyhsaW5lRWwsIHN3YWxDbGFzc2VzWydwcm9ncmVzcy1zdGVwLWxpbmUnXSk7XG4gICAgaWYgKHBhcmFtcy5wcm9ncmVzc1N0ZXBzRGlzdGFuY2UpIHtcbiAgICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUobGluZUVsLCAnd2lkdGgnLCBwYXJhbXMucHJvZ3Jlc3NTdGVwc0Rpc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVFbDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCByZW5kZXJUaXRsZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgdGl0bGUgPSBnZXRUaXRsZSgpO1xuICAgIHRvZ2dsZSh0aXRsZSwgcGFyYW1zLnRpdGxlIHx8IHBhcmFtcy50aXRsZVRleHQsICdibG9jaycpO1xuICAgIGlmIChwYXJhbXMudGl0bGUpIHtcbiAgICAgIHBhcnNlSHRtbFRvQ29udGFpbmVyKHBhcmFtcy50aXRsZSwgdGl0bGUpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnRpdGxlVGV4dCkge1xuICAgICAgdGl0bGUuaW5uZXJUZXh0ID0gcGFyYW1zLnRpdGxlVGV4dDtcbiAgICB9XG5cbiAgICAvLyBDdXN0b20gY2xhc3NcbiAgICBhcHBseUN1c3RvbUNsYXNzKHRpdGxlLCBwYXJhbXMsICd0aXRsZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHJlbmRlciA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgcmVuZGVyUG9wdXAoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgcmVuZGVyQ29udGFpbmVyKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlclByb2dyZXNzU3RlcHMoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgcmVuZGVySWNvbihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJJbWFnZShpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJUaXRsZShpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJDbG9zZUJ1dHRvbihpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJDb250ZW50KGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlckFjdGlvbnMoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgcmVuZGVyRm9vdGVyKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLmRpZFJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGFyYW1zLmRpZFJlbmRlcihnZXRQb3B1cCgpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEhpZGVzIGxvYWRlciBhbmQgc2hvd3MgYmFjayB0aGUgYnV0dG9uIHdoaWNoIHdhcyBoaWRkZW4gYnkgLnNob3dMb2FkaW5nKClcbiAgICovXG4gIGZ1bmN0aW9uIGhpZGVMb2FkaW5nKCkge1xuICAgIC8vIGRvIG5vdGhpbmcgaWYgcG9wdXAgaXMgY2xvc2VkXG4gICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KHRoaXMpO1xuICAgIGlmICghaW5uZXJQYXJhbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICAgIGhpZGUoZG9tQ2FjaGUubG9hZGVyKTtcbiAgICBpZiAoaXNUb2FzdCgpKSB7XG4gICAgICBpZiAoaW5uZXJQYXJhbXMuaWNvbikge1xuICAgICAgICBzaG93KGdldEljb24oKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3dSZWxhdGVkQnV0dG9uKGRvbUNhY2hlKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MoW2RvbUNhY2hlLnBvcHVwLCBkb21DYWNoZS5hY3Rpb25zXSwgc3dhbENsYXNzZXMubG9hZGluZyk7XG4gICAgZG9tQ2FjaGUucG9wdXAucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWJ1c3knKTtcbiAgICBkb21DYWNoZS5wb3B1cC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbG9hZGluZycpO1xuICAgIGRvbUNhY2hlLmNvbmZpcm1CdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICBkb21DYWNoZS5kZW55QnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gICAgZG9tQ2FjaGUuY2FuY2VsQnV0dG9uLmRpc2FibGVkID0gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc2hvd1JlbGF0ZWRCdXR0b24gPSBkb21DYWNoZSA9PiB7XG4gICAgY29uc3QgYnV0dG9uVG9SZXBsYWNlID0gZG9tQ2FjaGUucG9wdXAuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShkb21DYWNoZS5sb2FkZXIuZ2V0QXR0cmlidXRlKCdkYXRhLWJ1dHRvbi10by1yZXBsYWNlJykpO1xuICAgIGlmIChidXR0b25Ub1JlcGxhY2UubGVuZ3RoKSB7XG4gICAgICBzaG93KGJ1dHRvblRvUmVwbGFjZVswXSwgJ2lubGluZS1ibG9jaycpO1xuICAgIH0gZWxzZSBpZiAoYWxsQnV0dG9uc0FyZUhpZGRlbigpKSB7XG4gICAgICBoaWRlKGRvbUNhY2hlLmFjdGlvbnMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5wdXQgRE9NIG5vZGUsIHRoaXMgbWV0aG9kIHdvcmtzIHdpdGggaW5wdXQgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SW5wdXQoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UgfHwgdGhpcyk7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KGluc3RhbmNlIHx8IHRoaXMpO1xuICAgIGlmICghZG9tQ2FjaGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SW5wdXQkMShkb21DYWNoZS5wb3B1cCwgaW5uZXJQYXJhbXMuaW5wdXQpO1xuICB9XG5cbiAgLypcbiAgICogR2xvYmFsIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBTd2VldEFsZXJ0MiBwb3B1cCBpcyBzaG93blxuICAgKi9cbiAgY29uc3QgaXNWaXNpYmxlID0gKCkgPT4ge1xuICAgIHJldHVybiBpc1Zpc2libGUkMShnZXRQb3B1cCgpKTtcbiAgfTtcblxuICAvKlxuICAgKiBHbG9iYWwgZnVuY3Rpb24gdG8gY2xpY2sgJ0NvbmZpcm0nIGJ1dHRvblxuICAgKi9cbiAgY29uc3QgY2xpY2tDb25maXJtID0gKCkgPT4gZ2V0Q29uZmlybUJ1dHRvbigpICYmIGdldENvbmZpcm1CdXR0b24oKS5jbGljaygpO1xuXG4gIC8qXG4gICAqIEdsb2JhbCBmdW5jdGlvbiB0byBjbGljayAnRGVueScgYnV0dG9uXG4gICAqL1xuICBjb25zdCBjbGlja0RlbnkgPSAoKSA9PiBnZXREZW55QnV0dG9uKCkgJiYgZ2V0RGVueUJ1dHRvbigpLmNsaWNrKCk7XG5cbiAgLypcbiAgICogR2xvYmFsIGZ1bmN0aW9uIHRvIGNsaWNrICdDYW5jZWwnIGJ1dHRvblxuICAgKi9cbiAgY29uc3QgY2xpY2tDYW5jZWwgPSAoKSA9PiBnZXRDYW5jZWxCdXR0b24oKSAmJiBnZXRDYW5jZWxCdXR0b24oKS5jbGljaygpO1xuXG4gIGNvbnN0IERpc21pc3NSZWFzb24gPSBPYmplY3QuZnJlZXplKHtcbiAgICBjYW5jZWw6ICdjYW5jZWwnLFxuICAgIGJhY2tkcm9wOiAnYmFja2Ryb3AnLFxuICAgIGNsb3NlOiAnY2xvc2UnLFxuICAgIGVzYzogJ2VzYycsXG4gICAgdGltZXI6ICd0aW1lcidcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7R2xvYmFsU3RhdGV9IGdsb2JhbFN0YXRlXG4gICAqL1xuICBjb25zdCByZW1vdmVLZXlkb3duSGFuZGxlciA9IGdsb2JhbFN0YXRlID0+IHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUua2V5ZG93blRhcmdldCAmJiBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlckFkZGVkKSB7XG4gICAgICBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlciwge1xuICAgICAgICBjYXB0dXJlOiBnbG9iYWxTdGF0ZS5rZXlkb3duTGlzdGVuZXJDYXB0dXJlXG4gICAgICB9KTtcbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyQWRkZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7R2xvYmFsU3RhdGV9IGdsb2JhbFN0YXRlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gICAqIEBwYXJhbSB7Kn0gZGlzbWlzc1dpdGhcbiAgICovXG4gIGNvbnN0IGFkZEtleWRvd25IYW5kbGVyID0gKGluc3RhbmNlLCBnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKSA9PiB7XG4gICAgcmVtb3ZlS2V5ZG93bkhhbmRsZXIoZ2xvYmFsU3RhdGUpO1xuICAgIGlmICghaW5uZXJQYXJhbXMudG9hc3QpIHtcbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyID0gZSA9PiBrZXlkb3duSGFuZGxlcihpbnN0YW5jZSwgZSwgZGlzbWlzc1dpdGgpO1xuICAgICAgZ2xvYmFsU3RhdGUua2V5ZG93blRhcmdldCA9IGlubmVyUGFyYW1zLmtleWRvd25MaXN0ZW5lckNhcHR1cmUgPyB3aW5kb3cgOiBnZXRQb3B1cCgpO1xuICAgICAgZ2xvYmFsU3RhdGUua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSA9IGlubmVyUGFyYW1zLmtleWRvd25MaXN0ZW5lckNhcHR1cmU7XG4gICAgICBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlciwge1xuICAgICAgICBjYXB0dXJlOiBnbG9iYWxTdGF0ZS5rZXlkb3duTGlzdGVuZXJDYXB0dXJlXG4gICAgICB9KTtcbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmNyZW1lbnRcbiAgICovXG4gIGNvbnN0IHNldEZvY3VzID0gKGluZGV4LCBpbmNyZW1lbnQpID0+IHtcbiAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgLy8gc2VhcmNoIGZvciB2aXNpYmxlIGVsZW1lbnRzIGFuZCBzZWxlY3QgdGhlIG5leHQgcG9zc2libGUgbWF0Y2hcbiAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICBpbmRleCA9IGluZGV4ICsgaW5jcmVtZW50O1xuXG4gICAgICAvLyByb2xsb3ZlciB0byBmaXJzdCBpdGVtXG4gICAgICBpZiAoaW5kZXggPT09IGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgICAgLy8gZ28gdG8gbGFzdCBpdGVtXG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBpbmRleCA9IGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICBmb2N1c2FibGVFbGVtZW50c1tpbmRleF0uZm9jdXMoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gbm8gdmlzaWJsZSBmb2N1c2FibGUgZWxlbWVudHMsIGZvY3VzIHRoZSBwb3B1cFxuICAgIGdldFBvcHVwKCkuZm9jdXMoKTtcbiAgfTtcbiAgY29uc3QgYXJyb3dLZXlzTmV4dEJ1dHRvbiA9IFsnQXJyb3dSaWdodCcsICdBcnJvd0Rvd24nXTtcbiAgY29uc3QgYXJyb3dLZXlzUHJldmlvdXNCdXR0b24gPSBbJ0Fycm93TGVmdCcsICdBcnJvd1VwJ107XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAgICovXG4gIGNvbnN0IGtleWRvd25IYW5kbGVyID0gKGluc3RhbmNlLCBldmVudCwgZGlzbWlzc1dpdGgpID0+IHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgIGlmICghaW5uZXJQYXJhbXMpIHtcbiAgICAgIHJldHVybjsgLy8gVGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZFxuICAgIH1cblxuICAgIC8vIElnbm9yZSBrZXlkb3duIGR1cmluZyBJTUUgY29tcG9zaXRpb25cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQva2V5ZG93bl9ldmVudCNpZ25vcmluZ19rZXlkb3duX2R1cmluZ19pbWVfY29tcG9zaXRpb25cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzcyMFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjQwNlxuICAgIGlmIChldmVudC5pc0NvbXBvc2luZyB8fCBldmVudC5rZXlDb2RlID09PSAyMjkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlubmVyUGFyYW1zLnN0b3BLZXlkb3duUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8vIEVOVEVSXG4gICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgaGFuZGxlRW50ZXIoaW5zdGFuY2UsIGV2ZW50LCBpbm5lclBhcmFtcyk7XG4gICAgfVxuXG4gICAgLy8gVEFCXG4gICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgaGFuZGxlVGFiKGV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBBUlJPV1MgLSBzd2l0Y2ggZm9jdXMgYmV0d2VlbiBidXR0b25zXG4gICAgZWxzZSBpZiAoWy4uLmFycm93S2V5c05leHRCdXR0b24sIC4uLmFycm93S2V5c1ByZXZpb3VzQnV0dG9uXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICBoYW5kbGVBcnJvd3MoZXZlbnQua2V5KTtcbiAgICB9XG5cbiAgICAvLyBFU0NcbiAgICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICBoYW5kbGVFc2MoZXZlbnQsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gICAqL1xuICBjb25zdCBoYW5kbGVFbnRlciA9IChpbnN0YW5jZSwgZXZlbnQsIGlubmVyUGFyYW1zKSA9PiB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yMzg2XG4gICAgaWYgKCFjYWxsSWZGdW5jdGlvbihpbm5lclBhcmFtcy5hbGxvd0VudGVyS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICYmIGluc3RhbmNlLmdldElucHV0KCkgJiYgZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgZXZlbnQudGFyZ2V0Lm91dGVySFRNTCA9PT0gaW5zdGFuY2UuZ2V0SW5wdXQoKS5vdXRlckhUTUwpIHtcbiAgICAgIGlmIChbJ3RleHRhcmVhJywgJ2ZpbGUnXS5pbmNsdWRlcyhpbm5lclBhcmFtcy5pbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBkbyBub3Qgc3VibWl0XG4gICAgICB9XG5cbiAgICAgIGNsaWNrQ29uZmlybSgpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICovXG4gIGNvbnN0IGhhbmRsZVRhYiA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0Rm9jdXNhYmxlRWxlbWVudHMoKTtcbiAgICBsZXQgYnRuSW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGFyZ2V0RWxlbWVudCA9PT0gZm9jdXNhYmxlRWxlbWVudHNbaV0pIHtcbiAgICAgICAgYnRuSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDeWNsZSB0byB0aGUgbmV4dCBidXR0b25cbiAgICBpZiAoIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBzZXRGb2N1cyhidG5JbmRleCwgMSk7XG4gICAgfVxuXG4gICAgLy8gQ3ljbGUgdG8gdGhlIHByZXYgYnV0dG9uXG4gICAgZWxzZSB7XG4gICAgICBzZXRGb2N1cyhidG5JbmRleCwgLTEpO1xuICAgIH1cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICBjb25zdCBoYW5kbGVBcnJvd3MgPSBrZXkgPT4ge1xuICAgIGNvbnN0IGNvbmZpcm1CdXR0b24gPSBnZXRDb25maXJtQnV0dG9uKCk7XG4gICAgY29uc3QgZGVueUJ1dHRvbiA9IGdldERlbnlCdXR0b24oKTtcbiAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBnZXRDYW5jZWxCdXR0b24oKTtcbiAgICAvKiogQHR5cGUgSFRNTEVsZW1lbnRbXSAqL1xuICAgIGNvbnN0IGJ1dHRvbnMgPSBbY29uZmlybUJ1dHRvbiwgZGVueUJ1dHRvbiwgY2FuY2VsQnV0dG9uXTtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmICFidXR0b25zLmluY2x1ZGVzKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNpYmxpbmcgPSBhcnJvd0tleXNOZXh0QnV0dG9uLmluY2x1ZGVzKGtleSkgPyAnbmV4dEVsZW1lbnRTaWJsaW5nJyA6ICdwcmV2aW91c0VsZW1lbnRTaWJsaW5nJztcbiAgICBsZXQgYnV0dG9uVG9Gb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnZXRBY3Rpb25zKCkuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1dHRvblRvRm9jdXMgPSBidXR0b25Ub0ZvY3VzW3NpYmxpbmddO1xuICAgICAgaWYgKCFidXR0b25Ub0ZvY3VzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChidXR0b25Ub0ZvY3VzIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQgJiYgaXNWaXNpYmxlJDEoYnV0dG9uVG9Gb2N1cykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChidXR0b25Ub0ZvY3VzIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpIHtcbiAgICAgIGJ1dHRvblRvRm9jdXMuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAgICovXG4gIGNvbnN0IGhhbmRsZUVzYyA9IChldmVudCwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKSA9PiB7XG4gICAgaWYgKGNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93RXNjYXBlS2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uZXNjKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGBXZWFrTWFwYHMgZm9yIGVhY2ggZWZmZWN0aXZlbHktXCJwcml2YXRlICBwcm9wZXJ0eVwiIHRoYXQgYSBgU3dhbGAgaGFzLlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBwcml2YXRlIHByb3BlcnR5IFwiZm9vXCIgb2YgYHRoaXNgIHRvIFwiYmFyXCIsIHlvdSBjYW4gYHByaXZhdGVQcm9wcy5mb28uc2V0KHRoaXMsICdiYXInKWBcbiAgICogVGhpcyBpcyB0aGUgYXBwcm9hY2ggdGhhdCBCYWJlbCB3aWxsIHByb2JhYmx5IHRha2UgdG8gaW1wbGVtZW50IHByaXZhdGUgbWV0aG9kcy9maWVsZHNcbiAgICogICBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcml2YXRlLW1ldGhvZHNcbiAgICogICBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvcHVsbC83NTU1XG4gICAqIE9uY2Ugd2UgaGF2ZSB0aGUgY2hhbmdlcyBmcm9tIHRoYXQgUFIgaW4gQmFiZWwsIGFuZCBvdXIgY29yZSBjbGFzcyBmaXRzIHJlYXNvbmFibGUgaW4gKm9uZSBtb2R1bGUqXG4gICAqICAgdGhlbiB3ZSBjYW4gdXNlIHRoYXQgbGFuZ3VhZ2UgZmVhdHVyZS5cbiAgICovXG5cbiAgdmFyIHByaXZhdGVNZXRob2RzID0ge1xuICAgIHN3YWxQcm9taXNlUmVzb2x2ZTogbmV3IFdlYWtNYXAoKSxcbiAgICBzd2FsUHJvbWlzZVJlamVjdDogbmV3IFdlYWtNYXAoKVxuICB9O1xuXG4gIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIucGFjaWVsbG9ncm91cC5jb20vYmxvZy8yMDE4LzA2L3RoZS1jdXJyZW50LXN0YXRlLW9mLW1vZGFsLWRpYWxvZy1hY2Nlc3NpYmlsaXR5L1xuICAvLyBBZGRpbmcgYXJpYS1oaWRkZW49XCJ0cnVlXCIgdG8gZWxlbWVudHMgb3V0c2lkZSBvZiB0aGUgYWN0aXZlIG1vZGFsIGRpYWxvZyBlbnN1cmVzIHRoYXRcbiAgLy8gZWxlbWVudHMgbm90IHdpdGhpbiB0aGUgYWN0aXZlIG1vZGFsIGRpYWxvZyB3aWxsIG5vdCBiZSBzdXJmYWNlZCBpZiBhIHVzZXIgb3BlbnMgYSBzY3JlZW5cbiAgLy8gcmVhZGVy4oCZcyBsaXN0IG9mIGVsZW1lbnRzIChoZWFkaW5ncywgZm9ybSBjb250cm9scywgbGFuZG1hcmtzLCBldGMuKSBpbiB0aGUgZG9jdW1lbnQuXG5cbiAgY29uc3Qgc2V0QXJpYUhpZGRlbiA9ICgpID0+IHtcbiAgICBjb25zdCBib2R5Q2hpbGRyZW4gPSBBcnJheS5mcm9tKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgIGJvZHlDaGlsZHJlbi5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGlmIChlbCA9PT0gZ2V0Q29udGFpbmVyKCkgfHwgZWwuY29udGFpbnMoZ2V0Q29udGFpbmVyKCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXByZXZpb3VzLWFyaWEtaGlkZGVuJywgZWwuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKTtcbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCB1bnNldEFyaWFIaWRkZW4gPSAoKSA9PiB7XG4gICAgY29uc3QgYm9keUNoaWxkcmVuID0gQXJyYXkuZnJvbShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICBib2R5Q2hpbGRyZW4uZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdkYXRhLXByZXZpb3VzLWFyaWEtaGlkZGVuJykpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wcmV2aW91cy1hcmlhLWhpZGRlbicpKTtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXByZXZpb3VzLWFyaWEtaGlkZGVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cblxuICAvLyBGaXggaU9TIHNjcm9sbGluZyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTYyNjMwMlxuXG4gIGNvbnN0IGlPU2ZpeCA9ICgpID0+IHtcbiAgICBjb25zdCBpT1MgPVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtIHx8IG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ01hY0ludGVsJyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxO1xuICAgIGlmIChpT1MgJiYgIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3AgPSBgJHtvZmZzZXQgKiAtMX1weGA7XG4gICAgICBhZGRDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5pb3NmaXgpO1xuICAgICAgbG9ja0JvZHlTY3JvbGwoKTtcbiAgICAgIGFkZEJvdHRvbVBhZGRpbmdGb3JUYWxsUG9wdXBzKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzE5NDhcbiAgICovXG4gIGNvbnN0IGFkZEJvdHRvbVBhZGRpbmdGb3JUYWxsUG9wdXBzID0gKCkgPT4ge1xuICAgIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICBjb25zdCBpT1MgPSAhIXVhLm1hdGNoKC9pUGFkL2kpIHx8ICEhdWEubWF0Y2goL2lQaG9uZS9pKTtcbiAgICBjb25zdCB3ZWJraXQgPSAhIXVhLm1hdGNoKC9XZWJLaXQvaSk7XG4gICAgY29uc3QgaU9TU2FmYXJpID0gaU9TICYmIHdlYmtpdCAmJiAhdWEubWF0Y2goL0NyaU9TL2kpO1xuICAgIGlmIChpT1NTYWZhcmkpIHtcbiAgICAgIGNvbnN0IGJvdHRvbVBhbmVsSGVpZ2h0ID0gNDQ7XG4gICAgICBpZiAoZ2V0UG9wdXAoKS5zY3JvbGxIZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBib3R0b21QYW5lbEhlaWdodCkge1xuICAgICAgICBnZXRDb250YWluZXIoKS5zdHlsZS5wYWRkaW5nQm90dG9tID0gYCR7Ym90dG9tUGFuZWxIZWlnaHR9cHhgO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xMjQ2XG4gICAqL1xuICBjb25zdCBsb2NrQm9keVNjcm9sbCA9ICgpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICBsZXQgcHJldmVudFRvdWNoTW92ZTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50XG4gICAgICovXG4gICAgY29udGFpbmVyLm9udG91Y2hzdGFydCA9IGV2ZW50ID0+IHtcbiAgICAgIHByZXZlbnRUb3VjaE1vdmUgPSBzaG91bGRQcmV2ZW50VG91Y2hNb3ZlKGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgICBjb250YWluZXIub250b3VjaG1vdmUgPSBldmVudCA9PiB7XG4gICAgICBpZiAocHJldmVudFRvdWNoTW92ZSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3Qgc2hvdWxkUHJldmVudFRvdWNoTW92ZSA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgaWYgKGlzU3R5bHVzKGV2ZW50KSB8fCBpc1pvb20oZXZlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPT09IGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghaXNTY3JvbGxhYmxlKGNvbnRhaW5lcikgJiYgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0LnRhZ05hbWUgIT09ICdJTlBVVCcgJiZcbiAgICAvLyAjMTYwM1xuICAgIHRhcmdldC50YWdOYW1lICE9PSAnVEVYVEFSRUEnICYmXG4gICAgLy8gIzIyNjZcbiAgICAhKGlzU2Nyb2xsYWJsZShnZXRIdG1sQ29udGFpbmVyKCkpICYmXG4gICAgLy8gIzE5NDRcbiAgICBnZXRIdG1sQ29udGFpbmVyKCkuY29udGFpbnModGFyZ2V0KSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTc4NlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNTdHlsdXMgPSBldmVudCA9PiB7XG4gICAgcmV0dXJuIGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggJiYgZXZlbnQudG91Y2hlc1swXS50b3VjaFR5cGUgPT09ICdzdHlsdXMnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzE4OTFcbiAgICpcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGlzWm9vbSA9IGV2ZW50ID0+IHtcbiAgICByZXR1cm4gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDE7XG4gIH07XG4gIGNvbnN0IHVuZG9JT1NmaXggPSAoKSA9PiB7XG4gICAgaWYgKGhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KGRvY3VtZW50LmJvZHkuc3R5bGUudG9wLCAxMCk7XG4gICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5pb3NmaXgpO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3AgPSAnJztcbiAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gb2Zmc2V0ICogLTE7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGZpeFNjcm9sbGJhciA9ICgpID0+IHtcbiAgICAvLyBmb3IgcXVldWVzLCBkbyBub3QgZG8gdGhpcyBtb3JlIHRoYW4gb25jZVxuICAgIGlmIChzdGF0ZXMucHJldmlvdXNCb2R5UGFkZGluZyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgYm9keSBoYXMgb3ZlcmZsb3dcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgIC8vIGFkZCBwYWRkaW5nIHNvIHRoZSBjb250ZW50IGRvZXNuJ3Qgc2hpZnQgYWZ0ZXIgcmVtb3ZhbCBvZiBzY3JvbGxiYXJcbiAgICAgIHN0YXRlcy5wcmV2aW91c0JvZHlQYWRkaW5nID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7c3RhdGVzLnByZXZpb3VzQm9keVBhZGRpbmcgKyBtZWFzdXJlU2Nyb2xsYmFyKCl9cHhgO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5kb1Njcm9sbGJhciA9ICgpID0+IHtcbiAgICBpZiAoc3RhdGVzLnByZXZpb3VzQm9keVBhZGRpbmcgIT09IG51bGwpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7c3RhdGVzLnByZXZpb3VzQm9keVBhZGRpbmd9cHhgO1xuICAgICAgc3RhdGVzLnByZXZpb3VzQm9keVBhZGRpbmcgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBJbnN0YW5jZSBtZXRob2QgdG8gY2xvc2Ugc3dlZXRBbGVydFxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVQb3B1cEFuZFJlc2V0U3RhdGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgcmV0dXJuRm9jdXMsIGRpZENsb3NlKSB7XG4gICAgaWYgKGlzVG9hc3QoKSkge1xuICAgICAgdHJpZ2dlckRpZENsb3NlQW5kRGlzcG9zZShpbnN0YW5jZSwgZGlkQ2xvc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlQWN0aXZlRWxlbWVudChyZXR1cm5Gb2N1cykudGhlbigoKSA9PiB0cmlnZ2VyRGlkQ2xvc2VBbmREaXNwb3NlKGluc3RhbmNlLCBkaWRDbG9zZSkpO1xuICAgICAgcmVtb3ZlS2V5ZG93bkhhbmRsZXIoZ2xvYmFsU3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgLy8gd29ya2Fyb3VuZCBmb3IgIzIwODhcbiAgICAvLyBmb3Igc29tZSByZWFzb24gcmVtb3ZpbmcgdGhlIGNvbnRhaW5lciBpbiBTYWZhcmkgd2lsbCBzY3JvbGwgdGhlIGRvY3VtZW50IHRvIGJvdHRvbVxuICAgIGlmIChpc1NhZmFyaSkge1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpub25lICFpbXBvcnRhbnQnKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKGlzTW9kYWwoKSkge1xuICAgICAgdW5kb1Njcm9sbGJhcigpO1xuICAgICAgdW5kb0lPU2ZpeCgpO1xuICAgICAgdW5zZXRBcmlhSGlkZGVuKCk7XG4gICAgfVxuICAgIHJlbW92ZUJvZHlDbGFzc2VzKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlQm9keUNsYXNzZXMoKSB7XG4gICAgcmVtb3ZlQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIFtzd2FsQ2xhc3Nlcy5zaG93biwgc3dhbENsYXNzZXNbJ2hlaWdodC1hdXRvJ10sIHN3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXV0pO1xuICB9XG4gIGZ1bmN0aW9uIGNsb3NlKHJlc29sdmVWYWx1ZSkge1xuICAgIHJlc29sdmVWYWx1ZSA9IHByZXBhcmVSZXNvbHZlVmFsdWUocmVzb2x2ZVZhbHVlKTtcbiAgICBjb25zdCBzd2FsUHJvbWlzZVJlc29sdmUgPSBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlc29sdmUuZ2V0KHRoaXMpO1xuICAgIGNvbnN0IGRpZENsb3NlID0gdHJpZ2dlckNsb3NlUG9wdXAodGhpcyk7XG4gICAgaWYgKHRoaXMuaXNBd2FpdGluZ1Byb21pc2UoKSkge1xuICAgICAgLy8gQSBzd2FsIGF3YWl0aW5nIGZvciBhIHByb21pc2UgKGFmdGVyIGEgY2xpY2sgb24gQ29uZmlybSBvciBEZW55KSBjYW5ub3QgYmUgZGlzbWlzc2VkIGFueW1vcmUgIzIzMzVcbiAgICAgIGlmICghcmVzb2x2ZVZhbHVlLmlzRGlzbWlzc2VkKSB7XG4gICAgICAgIGhhbmRsZUF3YWl0aW5nUHJvbWlzZSh0aGlzKTtcbiAgICAgICAgc3dhbFByb21pc2VSZXNvbHZlKHJlc29sdmVWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaWRDbG9zZSkge1xuICAgICAgLy8gUmVzb2x2ZSBTd2FsIHByb21pc2VcbiAgICAgIHN3YWxQcm9taXNlUmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc0F3YWl0aW5nUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gISFwcml2YXRlUHJvcHMuYXdhaXRpbmdQcm9taXNlLmdldCh0aGlzKTtcbiAgfVxuICBjb25zdCB0cmlnZ2VyQ2xvc2VQb3B1cCA9IGluc3RhbmNlID0+IHtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgaWYgKCFwb3B1cCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgIGlmICghaW5uZXJQYXJhbXMgfHwgaGFzQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5wb3B1cCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7XG4gICAgYWRkQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5wb3B1cCk7XG4gICAgY29uc3QgYmFja2Ryb3AgPSBnZXRDb250YWluZXIoKTtcbiAgICByZW1vdmVDbGFzcyhiYWNrZHJvcCwgaW5uZXJQYXJhbXMuc2hvd0NsYXNzLmJhY2tkcm9wKTtcbiAgICBhZGRDbGFzcyhiYWNrZHJvcCwgaW5uZXJQYXJhbXMuaGlkZUNsYXNzLmJhY2tkcm9wKTtcbiAgICBoYW5kbGVQb3B1cEFuaW1hdGlvbihpbnN0YW5jZSwgcG9wdXAsIGlubmVyUGFyYW1zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShlcnJvcikge1xuICAgIGNvbnN0IHJlamVjdFByb21pc2UgPSBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlamVjdC5nZXQodGhpcyk7XG4gICAgaGFuZGxlQXdhaXRpbmdQcm9taXNlKHRoaXMpO1xuICAgIGlmIChyZWplY3RQcm9taXNlKSB7XG4gICAgICAvLyBSZWplY3QgU3dhbCBwcm9taXNlXG4gICAgICByZWplY3RQcm9taXNlKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFuZGxlQXdhaXRpbmdQcm9taXNlID0gaW5zdGFuY2UgPT4ge1xuICAgIGlmIChpbnN0YW5jZS5pc0F3YWl0aW5nUHJvbWlzZSgpKSB7XG4gICAgICBwcml2YXRlUHJvcHMuYXdhaXRpbmdQcm9taXNlLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgICAvLyBUaGUgaW5zdGFuY2UgbWlnaHQgaGF2ZSBiZWVuIHByZXZpb3VzbHkgcGFydGx5IGRlc3Ryb3llZCwgd2UgbXVzdCByZXN1bWUgdGhlIGRlc3Ryb3kgcHJvY2VzcyBpbiB0aGlzIGNhc2UgIzIzMzVcbiAgICAgIGlmICghcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSkpIHtcbiAgICAgICAgaW5zdGFuY2UuX2Rlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByZXBhcmVSZXNvbHZlVmFsdWUgPSByZXNvbHZlVmFsdWUgPT4ge1xuICAgIC8vIFdoZW4gdXNlciBjYWxscyBTd2FsLmNsb3NlKClcbiAgICBpZiAodHlwZW9mIHJlc29sdmVWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQ29uZmlybWVkOiBmYWxzZSxcbiAgICAgICAgaXNEZW5pZWQ6IGZhbHNlLFxuICAgICAgICBpc0Rpc21pc3NlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgaXNDb25maXJtZWQ6IGZhbHNlLFxuICAgICAgaXNEZW5pZWQ6IGZhbHNlLFxuICAgICAgaXNEaXNtaXNzZWQ6IGZhbHNlXG4gICAgfSwgcmVzb2x2ZVZhbHVlKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlUG9wdXBBbmltYXRpb24gPSAoaW5zdGFuY2UsIHBvcHVwLCBpbm5lclBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgIC8vIElmIGFuaW1hdGlvbiBpcyBzdXBwb3J0ZWQsIGFuaW1hdGVcbiAgICBjb25zdCBhbmltYXRpb25Jc1N1cHBvcnRlZCA9IGFuaW1hdGlvbkVuZEV2ZW50ICYmIGhhc0Nzc0FuaW1hdGlvbihwb3B1cCk7XG4gICAgaWYgKHR5cGVvZiBpbm5lclBhcmFtcy53aWxsQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlubmVyUGFyYW1zLndpbGxDbG9zZShwb3B1cCk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25Jc1N1cHBvcnRlZCkge1xuICAgICAgYW5pbWF0ZVBvcHVwKGluc3RhbmNlLCBwb3B1cCwgY29udGFpbmVyLCBpbm5lclBhcmFtcy5yZXR1cm5Gb2N1cywgaW5uZXJQYXJhbXMuZGlkQ2xvc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHJlbW92ZSBpbW1lZGlhdGVseVxuICAgICAgcmVtb3ZlUG9wdXBBbmRSZXNldFN0YXRlKGluc3RhbmNlLCBjb250YWluZXIsIGlubmVyUGFyYW1zLnJldHVybkZvY3VzLCBpbm5lclBhcmFtcy5kaWRDbG9zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBhbmltYXRlUG9wdXAgPSAoaW5zdGFuY2UsIHBvcHVwLCBjb250YWluZXIsIHJldHVybkZvY3VzLCBkaWRDbG9zZSkgPT4ge1xuICAgIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjayA9IHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZS5iaW5kKG51bGwsIGluc3RhbmNlLCBjb250YWluZXIsIHJldHVybkZvY3VzLCBkaWRDbG9zZSk7XG4gICAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcihhbmltYXRpb25FbmRFdmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gcG9wdXApIHtcbiAgICAgICAgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrKCk7XG4gICAgICAgIGRlbGV0ZSBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2s7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHRyaWdnZXJEaWRDbG9zZUFuZERpc3Bvc2UgPSAoaW5zdGFuY2UsIGRpZENsb3NlKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRpZENsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpZENsb3NlLmJpbmQoaW5zdGFuY2UucGFyYW1zKSgpO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UuX2Rlc3Ryb3koKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gYnV0dG9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gICAqL1xuICBmdW5jdGlvbiBzZXRCdXR0b25zRGlzYWJsZWQoaW5zdGFuY2UsIGJ1dHRvbnMsIGRpc2FibGVkKSB7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KGluc3RhbmNlKTtcbiAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGRvbUNhY2hlW2J1dHRvbl0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNldElucHV0RGlzYWJsZWQoaW5wdXQsIGRpc2FibGVkKSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgY29uc3QgcmFkaW9zQ29udGFpbmVyID0gaW5wdXQucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgcmFkaW9zID0gcmFkaW9zQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Jyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhZGlvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByYWRpb3NbaV0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZW5hYmxlQnV0dG9ucygpIHtcbiAgICBzZXRCdXR0b25zRGlzYWJsZWQodGhpcywgWydjb25maXJtQnV0dG9uJywgJ2RlbnlCdXR0b24nLCAnY2FuY2VsQnV0dG9uJ10sIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNhYmxlQnV0dG9ucygpIHtcbiAgICBzZXRCdXR0b25zRGlzYWJsZWQodGhpcywgWydjb25maXJtQnV0dG9uJywgJ2RlbnlCdXR0b24nLCAnY2FuY2VsQnV0dG9uJ10sIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGVuYWJsZUlucHV0KCkge1xuICAgIHNldElucHV0RGlzYWJsZWQodGhpcy5nZXRJbnB1dCgpLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzYWJsZUlucHV0KCkge1xuICAgIHNldElucHV0RGlzYWJsZWQodGhpcy5nZXRJbnB1dCgpLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IGJsb2NrIHdpdGggdmFsaWRhdGlvbiBtZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvclxuICAgKi9cbiAgZnVuY3Rpb24gc2hvd1ZhbGlkYXRpb25NZXNzYWdlKGVycm9yKSB7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG4gICAgc2V0SW5uZXJIdG1sKGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlLCBlcnJvcik7XG4gICAgZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UuY2xhc3NOYW1lID0gc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddO1xuICAgIGlmIChwYXJhbXMuY3VzdG9tQ2xhc3MgJiYgcGFyYW1zLmN1c3RvbUNsYXNzLnZhbGlkYXRpb25NZXNzYWdlKSB7XG4gICAgICBhZGRDbGFzcyhkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSwgcGFyYW1zLmN1c3RvbUNsYXNzLnZhbGlkYXRpb25NZXNzYWdlKTtcbiAgICB9XG4gICAgc2hvdyhkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSk7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmdldElucHV0KCk7XG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsIHRydWUpO1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jywgc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddKTtcbiAgICAgIGZvY3VzSW5wdXQoaW5wdXQpO1xuICAgICAgYWRkQ2xhc3MoaW5wdXQsIHN3YWxDbGFzc2VzLmlucHV0ZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIGJsb2NrIHdpdGggdmFsaWRhdGlvbiBtZXNzYWdlXG4gICAqL1xuICBmdW5jdGlvbiByZXNldFZhbGlkYXRpb25NZXNzYWdlKCkge1xuICAgIGNvbnN0IGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldCh0aGlzKTtcbiAgICBpZiAoZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UpIHtcbiAgICAgIGhpZGUoZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZ2V0SW5wdXQoKTtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJyk7XG4gICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgIHJlbW92ZUNsYXNzKGlucHV0LCBzd2FsQ2xhc3Nlcy5pbnB1dGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UGFyYW1zID0ge1xuICAgIHRpdGxlOiAnJyxcbiAgICB0aXRsZVRleHQ6ICcnLFxuICAgIHRleHQ6ICcnLFxuICAgIGh0bWw6ICcnLFxuICAgIGZvb3RlcjogJycsXG4gICAgaWNvbjogdW5kZWZpbmVkLFxuICAgIGljb25Db2xvcjogdW5kZWZpbmVkLFxuICAgIGljb25IdG1sOiB1bmRlZmluZWQsXG4gICAgdGVtcGxhdGU6IHVuZGVmaW5lZCxcbiAgICB0b2FzdDogZmFsc2UsXG4gICAgc2hvd0NsYXNzOiB7XG4gICAgICBwb3B1cDogJ3N3YWwyLXNob3cnLFxuICAgICAgYmFja2Ryb3A6ICdzd2FsMi1iYWNrZHJvcC1zaG93JyxcbiAgICAgIGljb246ICdzd2FsMi1pY29uLXNob3cnXG4gICAgfSxcbiAgICBoaWRlQ2xhc3M6IHtcbiAgICAgIHBvcHVwOiAnc3dhbDItaGlkZScsXG4gICAgICBiYWNrZHJvcDogJ3N3YWwyLWJhY2tkcm9wLWhpZGUnLFxuICAgICAgaWNvbjogJ3N3YWwyLWljb24taGlkZSdcbiAgICB9LFxuICAgIGN1c3RvbUNsYXNzOiB7fSxcbiAgICB0YXJnZXQ6ICdib2R5JyxcbiAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGhlaWdodEF1dG86IHRydWUsXG4gICAgYWxsb3dPdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgYWxsb3dFc2NhcGVLZXk6IHRydWUsXG4gICAgYWxsb3dFbnRlcktleTogdHJ1ZSxcbiAgICBzdG9wS2V5ZG93blByb3BhZ2F0aW9uOiB0cnVlLFxuICAgIGtleWRvd25MaXN0ZW5lckNhcHR1cmU6IGZhbHNlLFxuICAgIHNob3dDb25maXJtQnV0dG9uOiB0cnVlLFxuICAgIHNob3dEZW55QnV0dG9uOiBmYWxzZSxcbiAgICBzaG93Q2FuY2VsQnV0dG9uOiBmYWxzZSxcbiAgICBwcmVDb25maXJtOiB1bmRlZmluZWQsXG4gICAgcHJlRGVueTogdW5kZWZpbmVkLFxuICAgIGNvbmZpcm1CdXR0b25UZXh0OiAnT0snLFxuICAgIGNvbmZpcm1CdXR0b25BcmlhTGFiZWw6ICcnLFxuICAgIGNvbmZpcm1CdXR0b25Db2xvcjogdW5kZWZpbmVkLFxuICAgIGRlbnlCdXR0b25UZXh0OiAnTm8nLFxuICAgIGRlbnlCdXR0b25BcmlhTGFiZWw6ICcnLFxuICAgIGRlbnlCdXR0b25Db2xvcjogdW5kZWZpbmVkLFxuICAgIGNhbmNlbEJ1dHRvblRleHQ6ICdDYW5jZWwnLFxuICAgIGNhbmNlbEJ1dHRvbkFyaWFMYWJlbDogJycsXG4gICAgY2FuY2VsQnV0dG9uQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBidXR0b25zU3R5bGluZzogdHJ1ZSxcbiAgICByZXZlcnNlQnV0dG9uczogZmFsc2UsXG4gICAgZm9jdXNDb25maXJtOiB0cnVlLFxuICAgIGZvY3VzRGVueTogZmFsc2UsXG4gICAgZm9jdXNDYW5jZWw6IGZhbHNlLFxuICAgIHJldHVybkZvY3VzOiB0cnVlLFxuICAgIHNob3dDbG9zZUJ1dHRvbjogZmFsc2UsXG4gICAgY2xvc2VCdXR0b25IdG1sOiAnJnRpbWVzOycsXG4gICAgY2xvc2VCdXR0b25BcmlhTGFiZWw6ICdDbG9zZSB0aGlzIGRpYWxvZycsXG4gICAgbG9hZGVySHRtbDogJycsXG4gICAgc2hvd0xvYWRlck9uQ29uZmlybTogZmFsc2UsXG4gICAgc2hvd0xvYWRlck9uRGVueTogZmFsc2UsXG4gICAgaW1hZ2VVcmw6IHVuZGVmaW5lZCxcbiAgICBpbWFnZVdpZHRoOiB1bmRlZmluZWQsXG4gICAgaW1hZ2VIZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBpbWFnZUFsdDogJycsXG4gICAgdGltZXI6IHVuZGVmaW5lZCxcbiAgICB0aW1lclByb2dyZXNzQmFyOiBmYWxzZSxcbiAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIHBhZGRpbmc6IHVuZGVmaW5lZCxcbiAgICBiYWNrZ3JvdW5kOiB1bmRlZmluZWQsXG4gICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICBpbnB1dFBsYWNlaG9sZGVyOiAnJyxcbiAgICBpbnB1dExhYmVsOiAnJyxcbiAgICBpbnB1dFZhbHVlOiAnJyxcbiAgICBpbnB1dE9wdGlvbnM6IHt9LFxuICAgIGlucHV0QXV0b0ZvY3VzOiB0cnVlLFxuICAgIGlucHV0QXV0b1RyaW06IHRydWUsXG4gICAgaW5wdXRBdHRyaWJ1dGVzOiB7fSxcbiAgICBpbnB1dFZhbGlkYXRvcjogdW5kZWZpbmVkLFxuICAgIHJldHVybklucHV0VmFsdWVPbkRlbnk6IGZhbHNlLFxuICAgIHZhbGlkYXRpb25NZXNzYWdlOiB1bmRlZmluZWQsXG4gICAgZ3JvdzogZmFsc2UsXG4gICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgIHByb2dyZXNzU3RlcHM6IFtdLFxuICAgIGN1cnJlbnRQcm9ncmVzc1N0ZXA6IHVuZGVmaW5lZCxcbiAgICBwcm9ncmVzc1N0ZXBzRGlzdGFuY2U6IHVuZGVmaW5lZCxcbiAgICB3aWxsT3BlbjogdW5kZWZpbmVkLFxuICAgIGRpZE9wZW46IHVuZGVmaW5lZCxcbiAgICBkaWRSZW5kZXI6IHVuZGVmaW5lZCxcbiAgICB3aWxsQ2xvc2U6IHVuZGVmaW5lZCxcbiAgICBkaWRDbG9zZTogdW5kZWZpbmVkLFxuICAgIGRpZERlc3Ryb3k6IHVuZGVmaW5lZCxcbiAgICBzY3JvbGxiYXJQYWRkaW5nOiB0cnVlXG4gIH07XG4gIGNvbnN0IHVwZGF0YWJsZVBhcmFtcyA9IFsnYWxsb3dFc2NhcGVLZXknLCAnYWxsb3dPdXRzaWRlQ2xpY2snLCAnYmFja2dyb3VuZCcsICdidXR0b25zU3R5bGluZycsICdjYW5jZWxCdXR0b25BcmlhTGFiZWwnLCAnY2FuY2VsQnV0dG9uQ29sb3InLCAnY2FuY2VsQnV0dG9uVGV4dCcsICdjbG9zZUJ1dHRvbkFyaWFMYWJlbCcsICdjbG9zZUJ1dHRvbkh0bWwnLCAnY29sb3InLCAnY29uZmlybUJ1dHRvbkFyaWFMYWJlbCcsICdjb25maXJtQnV0dG9uQ29sb3InLCAnY29uZmlybUJ1dHRvblRleHQnLCAnY3VycmVudFByb2dyZXNzU3RlcCcsICdjdXN0b21DbGFzcycsICdkZW55QnV0dG9uQXJpYUxhYmVsJywgJ2RlbnlCdXR0b25Db2xvcicsICdkZW55QnV0dG9uVGV4dCcsICdkaWRDbG9zZScsICdkaWREZXN0cm95JywgJ2Zvb3RlcicsICdoaWRlQ2xhc3MnLCAnaHRtbCcsICdpY29uJywgJ2ljb25Db2xvcicsICdpY29uSHRtbCcsICdpbWFnZUFsdCcsICdpbWFnZUhlaWdodCcsICdpbWFnZVVybCcsICdpbWFnZVdpZHRoJywgJ3ByZUNvbmZpcm0nLCAncHJlRGVueScsICdwcm9ncmVzc1N0ZXBzJywgJ3JldHVybkZvY3VzJywgJ3JldmVyc2VCdXR0b25zJywgJ3Nob3dDYW5jZWxCdXR0b24nLCAnc2hvd0Nsb3NlQnV0dG9uJywgJ3Nob3dDb25maXJtQnV0dG9uJywgJ3Nob3dEZW55QnV0dG9uJywgJ3RleHQnLCAndGl0bGUnLCAndGl0bGVUZXh0JywgJ3dpbGxDbG9zZSddO1xuICBjb25zdCBkZXByZWNhdGVkUGFyYW1zID0ge307XG4gIGNvbnN0IHRvYXN0SW5jb21wYXRpYmxlUGFyYW1zID0gWydhbGxvd091dHNpZGVDbGljaycsICdhbGxvd0VudGVyS2V5JywgJ2JhY2tkcm9wJywgJ2ZvY3VzQ29uZmlybScsICdmb2N1c0RlbnknLCAnZm9jdXNDYW5jZWwnLCAncmV0dXJuRm9jdXMnLCAnaGVpZ2h0QXV0bycsICdrZXlkb3duTGlzdGVuZXJDYXB0dXJlJ107XG5cbiAgLyoqXG4gICAqIElzIHZhbGlkIHBhcmFtZXRlclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNWYWxpZFBhcmFtZXRlciA9IHBhcmFtTmFtZSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZhdWx0UGFyYW1zLCBwYXJhbU5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB2YWxpZCBwYXJhbWV0ZXIgZm9yIFN3YWwudXBkYXRlKCkgbWV0aG9kXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBpc1VwZGF0YWJsZVBhcmFtZXRlciA9IHBhcmFtTmFtZSA9PiB7XG4gICAgcmV0dXJuIHVwZGF0YWJsZVBhcmFtcy5pbmRleE9mKHBhcmFtTmFtZSkgIT09IC0xO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJcyBkZXByZWNhdGVkIHBhcmFtZXRlclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdCBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIgPSBwYXJhbU5hbWUgPT4ge1xuICAgIHJldHVybiBkZXByZWNhdGVkUGFyYW1zW3BhcmFtTmFtZV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbVxuICAgKi9cbiAgY29uc3QgY2hlY2tJZlBhcmFtSXNWYWxpZCA9IHBhcmFtID0+IHtcbiAgICBpZiAoIWlzVmFsaWRQYXJhbWV0ZXIocGFyYW0pKSB7XG4gICAgICB3YXJuKGBVbmtub3duIHBhcmFtZXRlciBcIiR7cGFyYW19XCJgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbVxuICAgKi9cbiAgY29uc3QgY2hlY2tJZlRvYXN0UGFyYW1Jc1ZhbGlkID0gcGFyYW0gPT4ge1xuICAgIGlmICh0b2FzdEluY29tcGF0aWJsZVBhcmFtcy5pbmNsdWRlcyhwYXJhbSkpIHtcbiAgICAgIHdhcm4oYFRoZSBwYXJhbWV0ZXIgXCIke3BhcmFtfVwiIGlzIGluY29tcGF0aWJsZSB3aXRoIHRvYXN0c2ApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtXG4gICAqL1xuICBjb25zdCBjaGVja0lmUGFyYW1Jc0RlcHJlY2F0ZWQgPSBwYXJhbSA9PiB7XG4gICAgaWYgKGlzRGVwcmVjYXRlZFBhcmFtZXRlcihwYXJhbSkpIHtcbiAgICAgIHdhcm5BYm91dERlcHJlY2F0aW9uKHBhcmFtLCBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIocGFyYW0pKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgcmVsZXZhbnQgd2FybmluZ3MgZm9yIGdpdmVuIHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHNob3dXYXJuaW5nc0ZvclBhcmFtcyA9IHBhcmFtcyA9PiB7XG4gICAgaWYgKHBhcmFtcy5iYWNrZHJvcCA9PT0gZmFsc2UgJiYgcGFyYW1zLmFsbG93T3V0c2lkZUNsaWNrKSB7XG4gICAgICB3YXJuKCdcImFsbG93T3V0c2lkZUNsaWNrXCIgcGFyYW1ldGVyIHJlcXVpcmVzIGBiYWNrZHJvcGAgcGFyYW1ldGVyIHRvIGJlIHNldCB0byBgdHJ1ZWAnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgIGNoZWNrSWZQYXJhbUlzVmFsaWQocGFyYW0pO1xuICAgICAgaWYgKHBhcmFtcy50b2FzdCkge1xuICAgICAgICBjaGVja0lmVG9hc3RQYXJhbUlzVmFsaWQocGFyYW0pO1xuICAgICAgfVxuICAgICAgY2hlY2tJZlBhcmFtSXNEZXByZWNhdGVkKHBhcmFtKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgcG9wdXAgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGUocGFyYW1zKSB7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldCh0aGlzKTtcbiAgICBpZiAoIXBvcHVwIHx8IGhhc0NsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApKSB7XG4gICAgICB3YXJuKGBZb3UncmUgdHJ5aW5nIHRvIHVwZGF0ZSB0aGUgY2xvc2VkIG9yIGNsb3NpbmcgcG9wdXAsIHRoYXQgd29uJ3Qgd29yay4gVXNlIHRoZSB1cGRhdGUoKSBtZXRob2QgaW4gcHJlQ29uZmlybSBwYXJhbWV0ZXIgb3Igc2hvdyBhIG5ldyBwb3B1cC5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRVcGRhdGFibGVQYXJhbXMgPSBmaWx0ZXJWYWxpZFBhcmFtcyhwYXJhbXMpO1xuICAgIGNvbnN0IHVwZGF0ZWRQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lclBhcmFtcywgdmFsaWRVcGRhdGFibGVQYXJhbXMpO1xuICAgIHJlbmRlcih0aGlzLCB1cGRhdGVkUGFyYW1zKTtcbiAgICBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuc2V0KHRoaXMsIHVwZGF0ZWRQYXJhbXMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB2YWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHBhcmFtcyksXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gICAqL1xuICBjb25zdCBmaWx0ZXJWYWxpZFBhcmFtcyA9IHBhcmFtcyA9PiB7XG4gICAgY29uc3QgdmFsaWRVcGRhdGFibGVQYXJhbXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgaWYgKGlzVXBkYXRhYmxlUGFyYW1ldGVyKHBhcmFtKSkge1xuICAgICAgICB2YWxpZFVwZGF0YWJsZVBhcmFtc1twYXJhbV0gPSBwYXJhbXNbcGFyYW1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihgSW52YWxpZCBwYXJhbWV0ZXIgdG8gdXBkYXRlOiAke3BhcmFtfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWxpZFVwZGF0YWJsZVBhcmFtcztcbiAgfTtcblxuICAvKipcbiAgICogRGlzcG9zZSB0aGUgY3VycmVudCBTd2VldEFsZXJ0MiBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldCh0aGlzKTtcbiAgICBpZiAoIWlubmVyUGFyYW1zKSB7XG4gICAgICBkaXNwb3NlV2Vha01hcHModGhpcyk7IC8vIFRoZSBXZWFrTWFwcyBtaWdodCBoYXZlIGJlZW4gcGFydGx5IGRlc3Ryb3llZCwgd2UgbXVzdCByZWNhbGwgaXQgdG8gZGlzcG9zZSBhbnkgcmVtYWluaW5nIFdlYWtNYXBzICMyMzM1XG4gICAgICByZXR1cm47IC8vIFRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWRcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBhbm90aGVyIFN3YWwgY2xvc2luZ1xuICAgIGlmIChkb21DYWNoZS5wb3B1cCAmJiBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2spIHtcbiAgICAgIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjaygpO1xuICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjaztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbm5lclBhcmFtcy5kaWREZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbm5lclBhcmFtcy5kaWREZXN0cm95KCk7XG4gICAgfVxuICAgIGRpc3Bvc2VTd2FsKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqL1xuICBjb25zdCBkaXNwb3NlU3dhbCA9IGluc3RhbmNlID0+IHtcbiAgICBkaXNwb3NlV2Vha01hcHMoaW5zdGFuY2UpO1xuICAgIC8vIFVuc2V0IHRoaXMucGFyYW1zIHNvIEdDIHdpbGwgZGlzcG9zZSBpdCAoIzE1NjkpXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGRlbGV0ZSBpbnN0YW5jZS5wYXJhbXM7XG4gICAgLy8gVW5zZXQgZ2xvYmFsU3RhdGUgcHJvcHMgc28gR0Mgd2lsbCBkaXNwb3NlIGdsb2JhbFN0YXRlICgjMTU2OSlcbiAgICBkZWxldGUgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXI7XG4gICAgZGVsZXRlIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQ7XG4gICAgLy8gVW5zZXQgY3VycmVudEluc3RhbmNlXG4gICAgZGVsZXRlIGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0IGRpc3Bvc2VXZWFrTWFwcyA9IGluc3RhbmNlID0+IHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCBpbnN0YW5jZSBpcyBhd2FpdGluZyBhIHByb21pc2UgcmVzdWx0LCB3ZSBrZWVwIHRoZSBwcml2YXRlTWV0aG9kcyB0byBjYWxsIHRoZW0gb25jZSB0aGUgcHJvbWlzZSByZXN1bHQgaXMgcmV0cmlldmVkICMyMzM1XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChpbnN0YW5jZS5pc0F3YWl0aW5nUHJvbWlzZSgpKSB7XG4gICAgICB1bnNldFdlYWtNYXBzKHByaXZhdGVQcm9wcywgaW5zdGFuY2UpO1xuICAgICAgcHJpdmF0ZVByb3BzLmF3YWl0aW5nUHJvbWlzZS5zZXQoaW5zdGFuY2UsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bnNldFdlYWtNYXBzKHByaXZhdGVNZXRob2RzLCBpbnN0YW5jZSk7XG4gICAgICB1bnNldFdlYWtNYXBzKHByaXZhdGVQcm9wcywgaW5zdGFuY2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3QgdW5zZXRXZWFrTWFwcyA9IChvYmosIGluc3RhbmNlKSA9PiB7XG4gICAgZm9yIChjb25zdCBpIGluIG9iaikge1xuICAgICAgb2JqW2ldLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbnN0YW5jZU1ldGhvZHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGhpZGVMb2FkaW5nOiBoaWRlTG9hZGluZyxcbiAgICBkaXNhYmxlTG9hZGluZzogaGlkZUxvYWRpbmcsXG4gICAgZ2V0SW5wdXQ6IGdldElucHV0LFxuICAgIGNsb3NlOiBjbG9zZSxcbiAgICBpc0F3YWl0aW5nUHJvbWlzZTogaXNBd2FpdGluZ1Byb21pc2UsXG4gICAgcmVqZWN0UHJvbWlzZTogcmVqZWN0UHJvbWlzZSxcbiAgICBoYW5kbGVBd2FpdGluZ1Byb21pc2U6IGhhbmRsZUF3YWl0aW5nUHJvbWlzZSxcbiAgICBjbG9zZVBvcHVwOiBjbG9zZSxcbiAgICBjbG9zZU1vZGFsOiBjbG9zZSxcbiAgICBjbG9zZVRvYXN0OiBjbG9zZSxcbiAgICBlbmFibGVCdXR0b25zOiBlbmFibGVCdXR0b25zLFxuICAgIGRpc2FibGVCdXR0b25zOiBkaXNhYmxlQnV0dG9ucyxcbiAgICBlbmFibGVJbnB1dDogZW5hYmxlSW5wdXQsXG4gICAgZGlzYWJsZUlucHV0OiBkaXNhYmxlSW5wdXQsXG4gICAgc2hvd1ZhbGlkYXRpb25NZXNzYWdlOiBzaG93VmFsaWRhdGlvbk1lc3NhZ2UsXG4gICAgcmVzZXRWYWxpZGF0aW9uTWVzc2FnZTogcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSxcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICBfZGVzdHJveTogX2Rlc3Ryb3lcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNob3dzIGxvYWRlciAoc3Bpbm5lciksIHRoaXMgaXMgdXNlZnVsIHdpdGggQUpBWCByZXF1ZXN0cy5cbiAgICogQnkgZGVmYXVsdCB0aGUgbG9hZGVyIGJlIHNob3duIGluc3RlYWQgb2YgdGhlIFwiQ29uZmlybVwiIGJ1dHRvbi5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MQnV0dG9uRWxlbWVudH0gW2J1dHRvblRvUmVwbGFjZV1cbiAgICovXG4gIGNvbnN0IHNob3dMb2FkaW5nID0gYnV0dG9uVG9SZXBsYWNlID0+IHtcbiAgICBsZXQgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIGlmICghcG9wdXApIHtcbiAgICAgIG5ldyBTd2FsKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuXG4gICAgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcigpO1xuICAgIGlmIChpc1RvYXN0KCkpIHtcbiAgICAgIGhpZGUoZ2V0SWNvbigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZUJ1dHRvbihwb3B1cCwgYnV0dG9uVG9SZXBsYWNlKTtcbiAgICB9XG4gICAgc2hvdyhsb2FkZXIpO1xuICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgnZGF0YS1sb2FkaW5nJywgJ3RydWUnKTtcbiAgICBwb3B1cC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYnVzeScsICd0cnVlJyk7XG4gICAgcG9wdXAuZm9jdXMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAgICogQHBhcmFtIHtIVE1MQnV0dG9uRWxlbWVudH0gW2J1dHRvblRvUmVwbGFjZV1cbiAgICovXG4gIGNvbnN0IHJlcGxhY2VCdXR0b24gPSAocG9wdXAsIGJ1dHRvblRvUmVwbGFjZSkgPT4ge1xuICAgIGNvbnN0IGFjdGlvbnMgPSBnZXRBY3Rpb25zKCk7XG4gICAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKCk7XG4gICAgaWYgKCFidXR0b25Ub1JlcGxhY2UgJiYgaXNWaXNpYmxlJDEoZ2V0Q29uZmlybUJ1dHRvbigpKSkge1xuICAgICAgYnV0dG9uVG9SZXBsYWNlID0gZ2V0Q29uZmlybUJ1dHRvbigpO1xuICAgIH1cbiAgICBzaG93KGFjdGlvbnMpO1xuICAgIGlmIChidXR0b25Ub1JlcGxhY2UpIHtcbiAgICAgIGhpZGUoYnV0dG9uVG9SZXBsYWNlKTtcbiAgICAgIGxvYWRlci5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnV0dG9uLXRvLXJlcGxhY2UnLCBidXR0b25Ub1JlcGxhY2UuY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgbG9hZGVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGxvYWRlciwgYnV0dG9uVG9SZXBsYWNlKTtcbiAgICBhZGRDbGFzcyhbcG9wdXAsIGFjdGlvbnNdLCBzd2FsQ2xhc3Nlcy5sb2FkaW5nKTtcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGVkZWYgeyBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIH0gSW5wdXRWYWx1ZVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCBoYW5kbGVJbnB1dE9wdGlvbnNBbmRWYWx1ZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgaWYgKHBhcmFtcy5pbnB1dCA9PT0gJ3NlbGVjdCcgfHwgcGFyYW1zLmlucHV0ID09PSAncmFkaW8nKSB7XG4gICAgICBoYW5kbGVJbnB1dE9wdGlvbnMoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChbJ3RleHQnLCAnZW1haWwnLCAnbnVtYmVyJywgJ3RlbCcsICd0ZXh0YXJlYSddLmluY2x1ZGVzKHBhcmFtcy5pbnB1dCkgJiYgKGhhc1RvUHJvbWlzZUZuKHBhcmFtcy5pbnB1dFZhbHVlKSB8fCBpc1Byb21pc2UocGFyYW1zLmlucHV0VmFsdWUpKSkge1xuICAgICAgc2hvd0xvYWRpbmcoZ2V0Q29uZmlybUJ1dHRvbigpKTtcbiAgICAgIGhhbmRsZUlucHV0VmFsdWUoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVtYmVyIHwgRmlsZSB8IEZpbGVMaXN0IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGdldElucHV0VmFsdWUgPSAoaW5zdGFuY2UsIGlubmVyUGFyYW1zKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBpbnN0YW5jZS5nZXRJbnB1dCgpO1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2ggKGlubmVyUGFyYW1zLmlucHV0KSB7XG4gICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgIHJldHVybiBnZXRDaGVja2JveFZhbHVlKGlucHV0KTtcbiAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgcmV0dXJuIGdldFJhZGlvVmFsdWUoaW5wdXQpO1xuICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgIHJldHVybiBnZXRGaWxlVmFsdWUoaW5wdXQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGlubmVyUGFyYW1zLmlucHV0QXV0b1RyaW0gPyBpbnB1dC52YWx1ZS50cmltKCkgOiBpbnB1dC52YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGNvbnN0IGdldENoZWNrYm94VmFsdWUgPSBpbnB1dCA9PiBpbnB1dC5jaGVja2VkID8gMSA6IDA7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAgICogQHJldHVybnMge3N0cmluZyB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXRSYWRpb1ZhbHVlID0gaW5wdXQgPT4gaW5wdXQuY2hlY2tlZCA/IGlucHV0LnZhbHVlIDogbnVsbDtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICAgKiBAcmV0dXJucyB7RmlsZUxpc3QgfCBGaWxlIHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGdldEZpbGVWYWx1ZSA9IGlucHV0ID0+IGlucHV0LmZpbGVzLmxlbmd0aCA/IGlucHV0LmdldEF0dHJpYnV0ZSgnbXVsdGlwbGUnKSAhPT0gbnVsbCA/IGlucHV0LmZpbGVzIDogaW5wdXQuZmlsZXNbMF0gOiBudWxsO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IGhhbmRsZUlucHV0T3B0aW9ucyA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gaW5wdXRPcHRpb25zXG4gICAgICovXG4gICAgY29uc3QgcHJvY2Vzc0lucHV0T3B0aW9ucyA9IGlucHV0T3B0aW9ucyA9PiB7XG4gICAgICBwb3B1bGF0ZUlucHV0T3B0aW9uc1twYXJhbXMuaW5wdXRdKHBvcHVwLCBmb3JtYXRJbnB1dE9wdGlvbnMoaW5wdXRPcHRpb25zKSwgcGFyYW1zKTtcbiAgICB9O1xuICAgIGlmIChoYXNUb1Byb21pc2VGbihwYXJhbXMuaW5wdXRPcHRpb25zKSB8fCBpc1Byb21pc2UocGFyYW1zLmlucHV0T3B0aW9ucykpIHtcbiAgICAgIHNob3dMb2FkaW5nKGdldENvbmZpcm1CdXR0b24oKSk7XG4gICAgICBhc1Byb21pc2UocGFyYW1zLmlucHV0T3B0aW9ucykudGhlbihpbnB1dE9wdGlvbnMgPT4ge1xuICAgICAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICAgICAgICBwcm9jZXNzSW5wdXRPcHRpb25zKGlucHV0T3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMuaW5wdXRPcHRpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgcHJvY2Vzc0lucHV0T3B0aW9ucyhwYXJhbXMuaW5wdXRPcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBvZiBpbnB1dE9wdGlvbnMhIEV4cGVjdGVkIG9iamVjdCwgTWFwIG9yIFByb21pc2UsIGdvdCAke3R5cGVvZiBwYXJhbXMuaW5wdXRPcHRpb25zfWApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCBoYW5kbGVJbnB1dFZhbHVlID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IGluc3RhbmNlLmdldElucHV0KCk7XG4gICAgaGlkZShpbnB1dCk7XG4gICAgYXNQcm9taXNlKHBhcmFtcy5pbnB1dFZhbHVlKS50aGVuKGlucHV0VmFsdWUgPT4ge1xuICAgICAgaW5wdXQudmFsdWUgPSBwYXJhbXMuaW5wdXQgPT09ICdudW1iZXInID8gYCR7cGFyc2VGbG9hdChpbnB1dFZhbHVlKSB8fCAwfWAgOiBgJHtpbnB1dFZhbHVlfWA7XG4gICAgICBzaG93KGlucHV0KTtcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICBlcnJvcihgRXJyb3IgaW4gaW5wdXRWYWx1ZSBwcm9taXNlOiAke2Vycn1gKTtcbiAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgICBzaG93KGlucHV0KTtcbiAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICAgIH0pO1xuICB9O1xuICBjb25zdCBwb3B1bGF0ZUlucHV0T3B0aW9ucyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gaW5wdXRPcHRpb25zXG4gICAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAgICovXG4gICAgc2VsZWN0OiAocG9wdXAsIGlucHV0T3B0aW9ucywgcGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3QgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnNlbGVjdCk7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbkxhYmVsXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uVmFsdWVcbiAgICAgICAqL1xuICAgICAgY29uc3QgcmVuZGVyT3B0aW9uID0gKHBhcmVudCwgb3B0aW9uTGFiZWwsIG9wdGlvblZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xuICAgICAgICBvcHRpb24udmFsdWUgPSBvcHRpb25WYWx1ZTtcbiAgICAgICAgc2V0SW5uZXJIdG1sKG9wdGlvbiwgb3B0aW9uTGFiZWwpO1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpc1NlbGVjdGVkKG9wdGlvblZhbHVlLCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgfTtcbiAgICAgIGlucHV0T3B0aW9ucy5mb3JFYWNoKGlucHV0T3B0aW9uID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBpbnB1dE9wdGlvblswXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uTGFiZWwgPSBpbnB1dE9wdGlvblsxXTtcbiAgICAgICAgLy8gPG9wdGdyb3VwPiBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDQwMS9pbnRlcmFjdC9mb3Jtcy5odG1sI2gtMTcuNlxuICAgICAgICAvLyBcIi4uLmFsbCBPUFRHUk9VUCBlbGVtZW50cyBtdXN0IGJlIHNwZWNpZmllZCBkaXJlY3RseSB3aXRoaW4gYSBTRUxFQ1QgZWxlbWVudCAoaS5lLiwgZ3JvdXBzIG1heSBub3QgYmUgbmVzdGVkKS4uLlwiXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhpcyBpcyBhIDxvcHRncm91cD5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9uTGFiZWwpKSB7XG4gICAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXksIHRoZW4gaXQgaXMgYW4gPG9wdGdyb3VwPlxuICAgICAgICAgIGNvbnN0IG9wdGdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0Z3JvdXAnKTtcbiAgICAgICAgICBvcHRncm91cC5sYWJlbCA9IG9wdGlvblZhbHVlO1xuICAgICAgICAgIG9wdGdyb3VwLmRpc2FibGVkID0gZmFsc2U7IC8vIG5vdCBjb25maWd1cmFibGUgZm9yIG5vd1xuICAgICAgICAgIHNlbGVjdC5hcHBlbmRDaGlsZChvcHRncm91cCk7XG4gICAgICAgICAgb3B0aW9uTGFiZWwuZm9yRWFjaChvID0+IHJlbmRlck9wdGlvbihvcHRncm91cCwgb1sxXSwgb1swXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhc2Ugb2YgPG9wdGlvbj5cbiAgICAgICAgICByZW5kZXJPcHRpb24oc2VsZWN0LCBvcHRpb25MYWJlbCwgb3B0aW9uVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdC5mb2N1cygpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGlucHV0T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgICAqL1xuICAgIHJhZGlvOiAocG9wdXAsIGlucHV0T3B0aW9ucywgcGFyYW1zKSA9PiB7XG4gICAgICBjb25zdCByYWRpbyA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMucmFkaW8pO1xuICAgICAgaW5wdXRPcHRpb25zLmZvckVhY2goaW5wdXRPcHRpb24gPT4ge1xuICAgICAgICBjb25zdCByYWRpb1ZhbHVlID0gaW5wdXRPcHRpb25bMF07XG4gICAgICAgIGNvbnN0IHJhZGlvTGFiZWwgPSBpbnB1dE9wdGlvblsxXTtcbiAgICAgICAgY29uc3QgcmFkaW9JbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGNvbnN0IHJhZGlvTGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgcmFkaW9JbnB1dC50eXBlID0gJ3JhZGlvJztcbiAgICAgICAgcmFkaW9JbnB1dC5uYW1lID0gc3dhbENsYXNzZXMucmFkaW87XG4gICAgICAgIHJhZGlvSW5wdXQudmFsdWUgPSByYWRpb1ZhbHVlO1xuICAgICAgICBpZiAoaXNTZWxlY3RlZChyYWRpb1ZhbHVlLCBwYXJhbXMuaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICByYWRpb0lucHV0LmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzZXRJbm5lckh0bWwobGFiZWwsIHJhZGlvTGFiZWwpO1xuICAgICAgICBsYWJlbC5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlcy5sYWJlbDtcbiAgICAgICAgcmFkaW9MYWJlbEVsZW1lbnQuYXBwZW5kQ2hpbGQocmFkaW9JbnB1dCk7XG4gICAgICAgIHJhZGlvTGFiZWxFbGVtZW50LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgcmFkaW8uYXBwZW5kQ2hpbGQocmFkaW9MYWJlbEVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByYWRpb3MgPSByYWRpby5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpO1xuICAgICAgaWYgKHJhZGlvcy5sZW5ndGgpIHtcbiAgICAgICAgcmFkaW9zWzBdLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBgaW5wdXRPcHRpb25zYCBpbnRvIGFuIGFycmF5IG9mIGBbdmFsdWUsIGxhYmVsXWBzXG4gICAqXG4gICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgYW55Pn0gaW5wdXRPcHRpb25zXG4gICAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxzdHJpbmc+Pn1cbiAgICovXG4gIGNvbnN0IGZvcm1hdElucHV0T3B0aW9ucyA9IGlucHV0T3B0aW9ucyA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKHR5cGVvZiBNYXAgIT09ICd1bmRlZmluZWQnICYmIGlucHV0T3B0aW9ucyBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgaW5wdXRPcHRpb25zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlRm9ybWF0dGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWVGb3JtYXR0ZWQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gY2FzZSBvZiA8b3B0Z3JvdXA+XG4gICAgICAgICAgdmFsdWVGb3JtYXR0ZWQgPSBmb3JtYXRJbnB1dE9wdGlvbnModmFsdWVGb3JtYXR0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKFtrZXksIHZhbHVlRm9ybWF0dGVkXSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmtleXMoaW5wdXRPcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZUZvcm1hdHRlZCA9IGlucHV0T3B0aW9uc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlRm9ybWF0dGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIGNhc2Ugb2YgPG9wdGdyb3VwPlxuICAgICAgICAgIHZhbHVlRm9ybWF0dGVkID0gZm9ybWF0SW5wdXRPcHRpb25zKHZhbHVlRm9ybWF0dGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChba2V5LCB2YWx1ZUZvcm1hdHRlZF0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25WYWx1ZVxuICAgKiBAcGFyYW0ge0lucHV0VmFsdWUgfCBQcm9taXNlPElucHV0VmFsdWU+IHwgeyB0b1Byb21pc2U6ICgpID0+IElucHV0VmFsdWUgfX0gaW5wdXRWYWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGlzU2VsZWN0ZWQgPSAob3B0aW9uVmFsdWUsIGlucHV0VmFsdWUpID0+IHtcbiAgICByZXR1cm4gaW5wdXRWYWx1ZSAmJiBpbnB1dFZhbHVlLnRvU3RyaW5nKCkgPT09IG9wdGlvblZhbHVlLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqL1xuICBjb25zdCBoYW5kbGVDb25maXJtQnV0dG9uQ2xpY2sgPSBpbnN0YW5jZSA9PiB7XG4gICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgICBpbnN0YW5jZS5kaXNhYmxlQnV0dG9ucygpO1xuICAgIGlmIChpbm5lclBhcmFtcy5pbnB1dCkge1xuICAgICAgaGFuZGxlQ29uZmlybU9yRGVueVdpdGhJbnB1dChpbnN0YW5jZSwgJ2NvbmZpcm0nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZmlybShpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3QgaGFuZGxlRGVueUJ1dHRvbkNsaWNrID0gaW5zdGFuY2UgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgaW5zdGFuY2UuZGlzYWJsZUJ1dHRvbnMoKTtcbiAgICBpZiAoaW5uZXJQYXJhbXMucmV0dXJuSW5wdXRWYWx1ZU9uRGVueSkge1xuICAgICAgaGFuZGxlQ29uZmlybU9yRGVueVdpdGhJbnB1dChpbnN0YW5jZSwgJ2RlbnknKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVueShpbnN0YW5jZSwgZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAgICovXG4gIGNvbnN0IGhhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrID0gKGluc3RhbmNlLCBkaXNtaXNzV2l0aCkgPT4ge1xuICAgIGluc3RhbmNlLmRpc2FibGVCdXR0b25zKCk7XG4gICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5jYW5jZWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0geydjb25maXJtJyB8ICdkZW55J30gdHlwZVxuICAgKi9cbiAgY29uc3QgaGFuZGxlQ29uZmlybU9yRGVueVdpdGhJbnB1dCA9IChpbnN0YW5jZSwgdHlwZSkgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgaWYgKCFpbm5lclBhcmFtcy5pbnB1dCkge1xuICAgICAgZXJyb3IoYFRoZSBcImlucHV0XCIgcGFyYW1ldGVyIGlzIG5lZWRlZCB0byBiZSBzZXQgd2hlbiB1c2luZyByZXR1cm5JbnB1dFZhbHVlT24ke2NhcGl0YWxpemVGaXJzdExldHRlcih0eXBlKX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRWYWx1ZSA9IGdldElucHV0VmFsdWUoaW5zdGFuY2UsIGlubmVyUGFyYW1zKTtcbiAgICBpZiAoaW5uZXJQYXJhbXMuaW5wdXRWYWxpZGF0b3IpIHtcbiAgICAgIGhhbmRsZUlucHV0VmFsaWRhdG9yKGluc3RhbmNlLCBpbnB1dFZhbHVlLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKCFpbnN0YW5jZS5nZXRJbnB1dCgpLmNoZWNrVmFsaWRpdHkoKSkge1xuICAgICAgaW5zdGFuY2UuZW5hYmxlQnV0dG9ucygpO1xuICAgICAgaW5zdGFuY2Uuc2hvd1ZhbGlkYXRpb25NZXNzYWdlKGlubmVyUGFyYW1zLnZhbGlkYXRpb25NZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdkZW55Jykge1xuICAgICAgZGVueShpbnN0YW5jZSwgaW5wdXRWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpcm0oaW5zdGFuY2UsIGlucHV0VmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBGaWxlIHwgRmlsZUxpc3QgfCBudWxsfSBpbnB1dFZhbHVlXG4gICAqIEBwYXJhbSB7J2NvbmZpcm0nIHwgJ2RlbnknfSB0eXBlXG4gICAqL1xuICBjb25zdCBoYW5kbGVJbnB1dFZhbGlkYXRvciA9IChpbnN0YW5jZSwgaW5wdXRWYWx1ZSwgdHlwZSkgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgaW5zdGFuY2UuZGlzYWJsZUlucHV0KCk7XG4gICAgY29uc3QgdmFsaWRhdGlvblByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGFzUHJvbWlzZShpbm5lclBhcmFtcy5pbnB1dFZhbGlkYXRvcihpbnB1dFZhbHVlLCBpbm5lclBhcmFtcy52YWxpZGF0aW9uTWVzc2FnZSkpKTtcbiAgICB2YWxpZGF0aW9uUHJvbWlzZS50aGVuKHZhbGlkYXRpb25NZXNzYWdlID0+IHtcbiAgICAgIGluc3RhbmNlLmVuYWJsZUJ1dHRvbnMoKTtcbiAgICAgIGluc3RhbmNlLmVuYWJsZUlucHV0KCk7XG4gICAgICBpZiAodmFsaWRhdGlvbk1lc3NhZ2UpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2hvd1ZhbGlkYXRpb25NZXNzYWdlKHZhbGlkYXRpb25NZXNzYWdlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2RlbnknKSB7XG4gICAgICAgIGRlbnkoaW5zdGFuY2UsIGlucHV0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlybShpbnN0YW5jZSwgaW5wdXRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKi9cbiAgY29uc3QgZGVueSA9IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UgfHwgdW5kZWZpbmVkKTtcbiAgICBpZiAoaW5uZXJQYXJhbXMuc2hvd0xvYWRlck9uRGVueSkge1xuICAgICAgc2hvd0xvYWRpbmcoZ2V0RGVueUJ1dHRvbigpKTtcbiAgICB9XG4gICAgaWYgKGlubmVyUGFyYW1zLnByZURlbnkpIHtcbiAgICAgIHByaXZhdGVQcm9wcy5hd2FpdGluZ1Byb21pc2Uuc2V0KGluc3RhbmNlIHx8IHVuZGVmaW5lZCwgdHJ1ZSk7IC8vIEZsYWdnaW5nIHRoZSBpbnN0YW5jZSBhcyBhd2FpdGluZyBhIHByb21pc2Ugc28gaXQncyBvd24gcHJvbWlzZSdzIHJlamVjdC9yZXNvbHZlIG1ldGhvZHMgZG9lc24ndCBnZXQgZGVzdHJveWVkIHVudGlsIHRoZSByZXN1bHQgZnJvbSB0aGlzIHByZURlbnkncyBwcm9taXNlIGlzIHJlY2VpdmVkXG4gICAgICBjb25zdCBwcmVEZW55UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gYXNQcm9taXNlKGlubmVyUGFyYW1zLnByZURlbnkodmFsdWUsIGlubmVyUGFyYW1zLnZhbGlkYXRpb25NZXNzYWdlKSkpO1xuICAgICAgcHJlRGVueVByb21pc2UudGhlbihwcmVEZW55VmFsdWUgPT4ge1xuICAgICAgICBpZiAocHJlRGVueVZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIGluc3RhbmNlLmhpZGVMb2FkaW5nKCk7XG4gICAgICAgICAgaGFuZGxlQXdhaXRpbmdQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZS5jbG9zZSh7XG4gICAgICAgICAgICBpc0RlbmllZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB0eXBlb2YgcHJlRGVueVZhbHVlID09PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogcHJlRGVueVZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHJlamVjdFdpdGgoaW5zdGFuY2UgfHwgdW5kZWZpbmVkLCBlcnJvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5jbG9zZSh7XG4gICAgICAgIGlzRGVuaWVkOiB0cnVlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICovXG4gIGNvbnN0IHN1Y2NlZWRXaXRoID0gKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICAgIGluc3RhbmNlLmNsb3NlKHtcbiAgICAgIGlzQ29uZmlybWVkOiB0cnVlLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVycm9yXG4gICAqL1xuICBjb25zdCByZWplY3RXaXRoID0gKGluc3RhbmNlLCBlcnJvcikgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnN0YW5jZS5yZWplY3RQcm9taXNlKGVycm9yKTtcbiAgfTtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqL1xuICBjb25zdCBjb25maXJtID0gKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSB8fCB1bmRlZmluZWQpO1xuICAgIGlmIChpbm5lclBhcmFtcy5zaG93TG9hZGVyT25Db25maXJtKSB7XG4gICAgICBzaG93TG9hZGluZygpO1xuICAgIH1cbiAgICBpZiAoaW5uZXJQYXJhbXMucHJlQ29uZmlybSkge1xuICAgICAgaW5zdGFuY2UucmVzZXRWYWxpZGF0aW9uTWVzc2FnZSgpO1xuICAgICAgcHJpdmF0ZVByb3BzLmF3YWl0aW5nUHJvbWlzZS5zZXQoaW5zdGFuY2UgfHwgdW5kZWZpbmVkLCB0cnVlKTsgLy8gRmxhZ2dpbmcgdGhlIGluc3RhbmNlIGFzIGF3YWl0aW5nIGEgcHJvbWlzZSBzbyBpdCdzIG93biBwcm9taXNlJ3MgcmVqZWN0L3Jlc29sdmUgbWV0aG9kcyBkb2Vzbid0IGdldCBkZXN0cm95ZWQgdW50aWwgdGhlIHJlc3VsdCBmcm9tIHRoaXMgcHJlQ29uZmlybSdzIHByb21pc2UgaXMgcmVjZWl2ZWRcbiAgICAgIGNvbnN0IHByZUNvbmZpcm1Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBhc1Byb21pc2UoaW5uZXJQYXJhbXMucHJlQ29uZmlybSh2YWx1ZSwgaW5uZXJQYXJhbXMudmFsaWRhdGlvbk1lc3NhZ2UpKSk7XG4gICAgICBwcmVDb25maXJtUHJvbWlzZS50aGVuKHByZUNvbmZpcm1WYWx1ZSA9PiB7XG4gICAgICAgIGlmIChpc1Zpc2libGUkMShnZXRWYWxpZGF0aW9uTWVzc2FnZSgpKSB8fCBwcmVDb25maXJtVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICAgICAgICBoYW5kbGVBd2FpdGluZ1Byb21pc2UoaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Y2NlZWRXaXRoKGluc3RhbmNlLCB0eXBlb2YgcHJlQ29uZmlybVZhbHVlID09PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogcHJlQ29uZmlybVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4gcmVqZWN0V2l0aChpbnN0YW5jZSB8fCB1bmRlZmluZWQsIGVycm9yKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1Y2NlZWRXaXRoKGluc3RhbmNlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVBvcHVwQ2xpY2sgPSAoaW5zdGFuY2UsIGRvbUNhY2hlLCBkaXNtaXNzV2l0aCkgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgaWYgKGlubmVyUGFyYW1zLnRvYXN0KSB7XG4gICAgICBoYW5kbGVUb2FzdENsaWNrKGluc3RhbmNlLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZ25vcmUgY2xpY2sgZXZlbnRzIHRoYXQgaGFkIG1vdXNlZG93biBvbiB0aGUgcG9wdXAgYnV0IG1vdXNldXAgb24gdGhlIGNvbnRhaW5lclxuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIHVzZXIgZHJhZ3MgYSBzbGlkZXJcbiAgICAgIGhhbmRsZU1vZGFsTW91c2Vkb3duKGRvbUNhY2hlKTtcblxuICAgICAgLy8gSWdub3JlIGNsaWNrIGV2ZW50cyB0aGF0IGhhZCBtb3VzZWRvd24gb24gdGhlIGNvbnRhaW5lciBidXQgbW91c2V1cCBvbiB0aGUgcG9wdXBcbiAgICAgIGhhbmRsZUNvbnRhaW5lck1vdXNlZG93bihkb21DYWNoZSk7XG4gICAgICBoYW5kbGVNb2RhbENsaWNrKGluc3RhbmNlLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgaGFuZGxlVG9hc3RDbGljayA9IChpbnN0YW5jZSwgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gICAgLy8gQ2xvc2luZyB0b2FzdCBieSBpbnRlcm5hbCBjbGlja1xuICAgIGRvbUNhY2hlLnBvcHVwLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgICAgaWYgKGlubmVyUGFyYW1zICYmIChpc0FueUJ1dHRvblNob3duKGlubmVyUGFyYW1zKSB8fCBpbm5lclBhcmFtcy50aW1lciB8fCBpbm5lclBhcmFtcy5pbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5jbG9zZSk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBpbm5lclBhcmFtc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGlzQW55QnV0dG9uU2hvd24gPSBpbm5lclBhcmFtcyA9PiB7XG4gICAgcmV0dXJuIGlubmVyUGFyYW1zLnNob3dDb25maXJtQnV0dG9uIHx8IGlubmVyUGFyYW1zLnNob3dEZW55QnV0dG9uIHx8IGlubmVyUGFyYW1zLnNob3dDYW5jZWxCdXR0b24gfHwgaW5uZXJQYXJhbXMuc2hvd0Nsb3NlQnV0dG9uO1xuICB9O1xuICBsZXQgaWdub3JlT3V0c2lkZUNsaWNrID0gZmFsc2U7XG4gIGNvbnN0IGhhbmRsZU1vZGFsTW91c2Vkb3duID0gZG9tQ2FjaGUgPT4ge1xuICAgIGRvbUNhY2hlLnBvcHVwLm9ubW91c2Vkb3duID0gKCkgPT4ge1xuICAgICAgZG9tQ2FjaGUuY29udGFpbmVyLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRvbUNhY2hlLmNvbnRhaW5lci5vbm1vdXNldXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFdlIG9ubHkgY2hlY2sgaWYgdGhlIG1vdXNldXAgdGFyZ2V0IGlzIHRoZSBjb250YWluZXIgYmVjYXVzZSB1c3VhbGx5IGl0IGRvZXNuJ3RcbiAgICAgICAgLy8gaGF2ZSBhbnkgb3RoZXIgZGlyZWN0IGNoaWxkcmVuIGFzaWRlIG9mIHRoZSBwb3B1cFxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGRvbUNhY2hlLmNvbnRhaW5lcikge1xuICAgICAgICAgIGlnbm9yZU91dHNpZGVDbGljayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlQ29udGFpbmVyTW91c2Vkb3duID0gZG9tQ2FjaGUgPT4ge1xuICAgIGRvbUNhY2hlLmNvbnRhaW5lci5vbm1vdXNlZG93biA9ICgpID0+IHtcbiAgICAgIGRvbUNhY2hlLnBvcHVwLm9ubW91c2V1cCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGRvbUNhY2hlLnBvcHVwLm9ubW91c2V1cCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBtb3VzZXVwIHRhcmdldCBpcyBhIGNoaWxkIG9mIHRoZSBwb3B1cFxuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGRvbUNhY2hlLnBvcHVwIHx8IGRvbUNhY2hlLnBvcHVwLmNvbnRhaW5zKGUudGFyZ2V0KSkge1xuICAgICAgICAgIGlnbm9yZU91dHNpZGVDbGljayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlTW9kYWxDbGljayA9IChpbnN0YW5jZSwgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKSA9PiB7XG4gICAgZG9tQ2FjaGUuY29udGFpbmVyLm9uY2xpY2sgPSBlID0+IHtcbiAgICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgICBpZiAoaWdub3JlT3V0c2lkZUNsaWNrKSB7XG4gICAgICAgIGlnbm9yZU91dHNpZGVDbGljayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZS50YXJnZXQgPT09IGRvbUNhY2hlLmNvbnRhaW5lciAmJiBjYWxsSWZGdW5jdGlvbihpbm5lclBhcmFtcy5hbGxvd091dHNpZGVDbGljaykpIHtcbiAgICAgICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5iYWNrZHJvcCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBjb25zdCBpc0pxdWVyeUVsZW1lbnQgPSBlbGVtID0+IHR5cGVvZiBlbGVtID09PSAnb2JqZWN0JyAmJiBlbGVtLmpxdWVyeTtcbiAgY29uc3QgaXNFbGVtZW50ID0gZWxlbSA9PiBlbGVtIGluc3RhbmNlb2YgRWxlbWVudCB8fCBpc0pxdWVyeUVsZW1lbnQoZWxlbSk7XG4gIGNvbnN0IGFyZ3NUb1BhcmFtcyA9IGFyZ3MgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudChhcmdzWzBdKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihwYXJhbXMsIGFyZ3NbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBbJ3RpdGxlJywgJ2h0bWwnLCAnaWNvbiddLmZvckVhY2goKG5hbWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwgaXNFbGVtZW50KGFyZykpIHtcbiAgICAgICAgICBwYXJhbXNbbmFtZV0gPSBhcmc7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlcnJvcihgVW5leHBlY3RlZCB0eXBlIG9mICR7bmFtZX0hIEV4cGVjdGVkIFwic3RyaW5nXCIgb3IgXCJFbGVtZW50XCIsIGdvdCAke3R5cGVvZiBhcmd9YCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgY29uc3QgU3dhbCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgU3dhbCguLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4dGVuZGVkIHZlcnNpb24gb2YgYFN3YWxgIGNvbnRhaW5pbmcgYHBhcmFtc2AgYXMgZGVmYXVsdHMuXG4gICAqIFVzZWZ1bCBmb3IgcmV1c2luZyBTd2FsIGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiBCZWZvcmU6XG4gICAqIGNvbnN0IHRleHRQcm9tcHRPcHRpb25zID0geyBpbnB1dDogJ3RleHQnLCBzaG93Q2FuY2VsQnV0dG9uOiB0cnVlIH1cbiAgICogY29uc3Qge3ZhbHVlOiBmaXJzdE5hbWV9ID0gYXdhaXQgU3dhbC5maXJlKHsgLi4udGV4dFByb21wdE9wdGlvbnMsIHRpdGxlOiAnV2hhdCBpcyB5b3VyIGZpcnN0IG5hbWU/JyB9KVxuICAgKiBjb25zdCB7dmFsdWU6IGxhc3ROYW1lfSA9IGF3YWl0IFN3YWwuZmlyZSh7IC4uLnRleHRQcm9tcHRPcHRpb25zLCB0aXRsZTogJ1doYXQgaXMgeW91ciBsYXN0IG5hbWU/JyB9KVxuICAgKlxuICAgKiBBZnRlcjpcbiAgICogY29uc3QgVGV4dFByb21wdCA9IFN3YWwubWl4aW4oeyBpbnB1dDogJ3RleHQnLCBzaG93Q2FuY2VsQnV0dG9uOiB0cnVlIH0pXG4gICAqIGNvbnN0IHt2YWx1ZTogZmlyc3ROYW1lfSA9IGF3YWl0IFRleHRQcm9tcHQoJ1doYXQgaXMgeW91ciBmaXJzdCBuYW1lPycpXG4gICAqIGNvbnN0IHt2YWx1ZTogbGFzdE5hbWV9ID0gYXdhaXQgVGV4dFByb21wdCgnV2hhdCBpcyB5b3VyIGxhc3QgbmFtZT8nKVxuICAgKlxuICAgKiBAcGFyYW0gbWl4aW5QYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIG1peGluKG1peGluUGFyYW1zKSB7XG4gICAgY2xhc3MgTWl4aW5Td2FsIGV4dGVuZHMgdGhpcyB7XG4gICAgICBfbWFpbihwYXJhbXMsIHByaW9yaXR5TWl4aW5QYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9tYWluKHBhcmFtcywgT2JqZWN0LmFzc2lnbih7fSwgbWl4aW5QYXJhbXMsIHByaW9yaXR5TWl4aW5QYXJhbXMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1peGluU3dhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpcyBzZXQsIHJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAgICogT3RoZXJ3aXNlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGNvbnN0IGdldFRpbWVyTGVmdCA9ICgpID0+IHtcbiAgICByZXR1cm4gZ2xvYmFsU3RhdGUudGltZW91dCAmJiBnbG9iYWxTdGF0ZS50aW1lb3V0LmdldFRpbWVyTGVmdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdG9wIHRpbWVyLiBSZXR1cm5zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb2YgdGltZXIgcmVtYWluZWQuXG4gICAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdCBzdG9wVGltZXIgPSAoKSA9PiB7XG4gICAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQpIHtcbiAgICAgIHN0b3BUaW1lclByb2dyZXNzQmFyKCk7XG4gICAgICByZXR1cm4gZ2xvYmFsU3RhdGUudGltZW91dC5zdG9wKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGltZXIuIFJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAgICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXNuJ3Qgc2V0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGNvbnN0IHJlc3VtZVRpbWVyID0gKCkgPT4ge1xuICAgIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0KSB7XG4gICAgICBjb25zdCByZW1haW5pbmcgPSBnbG9iYWxTdGF0ZS50aW1lb3V0LnN0YXJ0KCk7XG4gICAgICBhbmltYXRlVGltZXJQcm9ncmVzc0JhcihyZW1haW5pbmcpO1xuICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc3VtZSB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIHRpbWVyIHJlbWFpbmVkLlxuICAgKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgY29uc3QgdG9nZ2xlVGltZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgdGltZXIgPSBnbG9iYWxTdGF0ZS50aW1lb3V0O1xuICAgIHJldHVybiB0aW1lciAmJiAodGltZXIucnVubmluZyA/IHN0b3BUaW1lcigpIDogcmVzdW1lVGltZXIoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEluY3JlYXNlIHRpbWVyLiBSZXR1cm5zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb2YgYW4gdXBkYXRlZCB0aW1lci5cbiAgICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXNuJ3Qgc2V0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGNvbnN0IGluY3JlYXNlVGltZXIgPSBuID0+IHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUudGltZW91dCkge1xuICAgICAgY29uc3QgcmVtYWluaW5nID0gZ2xvYmFsU3RhdGUudGltZW91dC5pbmNyZWFzZShuKTtcbiAgICAgIGFuaW1hdGVUaW1lclByb2dyZXNzQmFyKHJlbWFpbmluZywgdHJ1ZSk7XG4gICAgICByZXR1cm4gcmVtYWluaW5nO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGltZXIgaXMgcnVubmluZy4gUmV0dXJucyB0cnVlIGlmIHRpbWVyIGlzIHJ1bm5pbmdcbiAgICogb3IgZmFsc2UgaWYgdGltZXIgaXMgcGF1c2VkIG9yIHN0b3BwZWQuXG4gICAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWRcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBpc1RpbWVyUnVubmluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gZ2xvYmFsU3RhdGUudGltZW91dCAmJiBnbG9iYWxTdGF0ZS50aW1lb3V0LmlzUnVubmluZygpO1xuICB9O1xuXG4gIGxldCBib2R5Q2xpY2tMaXN0ZW5lckFkZGVkID0gZmFsc2U7XG4gIGNvbnN0IGNsaWNrSGFuZGxlcnMgPSB7fTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRDbGlja0hhbmRsZXIoKSB7XG4gICAgbGV0IGF0dHIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdkYXRhLXN3YWwtdGVtcGxhdGUnO1xuICAgIGNsaWNrSGFuZGxlcnNbYXR0cl0gPSB0aGlzO1xuICAgIGlmICghYm9keUNsaWNrTGlzdGVuZXJBZGRlZCkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGJvZHlDbGlja0xpc3RlbmVyKTtcbiAgICAgIGJvZHlDbGlja0xpc3RlbmVyQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb25zdCBib2R5Q2xpY2tMaXN0ZW5lciA9IGV2ZW50ID0+IHtcbiAgICBmb3IgKGxldCBlbCA9IGV2ZW50LnRhcmdldDsgZWwgJiYgZWwgIT09IGRvY3VtZW50OyBlbCA9IGVsLnBhcmVudE5vZGUpIHtcbiAgICAgIGZvciAoY29uc3QgYXR0ciBpbiBjbGlja0hhbmRsZXJzKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZWwuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgICBjbGlja0hhbmRsZXJzW2F0dHJdLmZpcmUoe1xuICAgICAgICAgICAgdGVtcGxhdGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHN0YXRpY01ldGhvZHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGlzVmFsaWRQYXJhbWV0ZXI6IGlzVmFsaWRQYXJhbWV0ZXIsXG4gICAgaXNVcGRhdGFibGVQYXJhbWV0ZXI6IGlzVXBkYXRhYmxlUGFyYW1ldGVyLFxuICAgIGlzRGVwcmVjYXRlZFBhcmFtZXRlcjogaXNEZXByZWNhdGVkUGFyYW1ldGVyLFxuICAgIGFyZ3NUb1BhcmFtczogYXJnc1RvUGFyYW1zLFxuICAgIGdldENvbnRhaW5lcjogZ2V0Q29udGFpbmVyLFxuICAgIGdldFBvcHVwOiBnZXRQb3B1cCxcbiAgICBnZXRUaXRsZTogZ2V0VGl0bGUsXG4gICAgZ2V0SHRtbENvbnRhaW5lcjogZ2V0SHRtbENvbnRhaW5lcixcbiAgICBnZXRJbWFnZTogZ2V0SW1hZ2UsXG4gICAgZ2V0SWNvbjogZ2V0SWNvbixcbiAgICBnZXRJY29uQ29udGVudDogZ2V0SWNvbkNvbnRlbnQsXG4gICAgZ2V0SW5wdXRMYWJlbDogZ2V0SW5wdXRMYWJlbCxcbiAgICBnZXRDbG9zZUJ1dHRvbjogZ2V0Q2xvc2VCdXR0b24sXG4gICAgZ2V0QWN0aW9uczogZ2V0QWN0aW9ucyxcbiAgICBnZXRDb25maXJtQnV0dG9uOiBnZXRDb25maXJtQnV0dG9uLFxuICAgIGdldERlbnlCdXR0b246IGdldERlbnlCdXR0b24sXG4gICAgZ2V0Q2FuY2VsQnV0dG9uOiBnZXRDYW5jZWxCdXR0b24sXG4gICAgZ2V0TG9hZGVyOiBnZXRMb2FkZXIsXG4gICAgZ2V0Rm9vdGVyOiBnZXRGb290ZXIsXG4gICAgZ2V0VGltZXJQcm9ncmVzc0JhcjogZ2V0VGltZXJQcm9ncmVzc0JhcixcbiAgICBnZXRGb2N1c2FibGVFbGVtZW50czogZ2V0Rm9jdXNhYmxlRWxlbWVudHMsXG4gICAgZ2V0VmFsaWRhdGlvbk1lc3NhZ2U6IGdldFZhbGlkYXRpb25NZXNzYWdlLFxuICAgIGdldFByb2dyZXNzU3RlcHM6IGdldFByb2dyZXNzU3RlcHMsXG4gICAgaXNMb2FkaW5nOiBpc0xvYWRpbmcsXG4gICAgaXNWaXNpYmxlOiBpc1Zpc2libGUsXG4gICAgY2xpY2tDb25maXJtOiBjbGlja0NvbmZpcm0sXG4gICAgY2xpY2tEZW55OiBjbGlja0RlbnksXG4gICAgY2xpY2tDYW5jZWw6IGNsaWNrQ2FuY2VsLFxuICAgIGZpcmU6IGZpcmUsXG4gICAgbWl4aW46IG1peGluLFxuICAgIHNob3dMb2FkaW5nOiBzaG93TG9hZGluZyxcbiAgICBlbmFibGVMb2FkaW5nOiBzaG93TG9hZGluZyxcbiAgICBnZXRUaW1lckxlZnQ6IGdldFRpbWVyTGVmdCxcbiAgICBzdG9wVGltZXI6IHN0b3BUaW1lcixcbiAgICByZXN1bWVUaW1lcjogcmVzdW1lVGltZXIsXG4gICAgdG9nZ2xlVGltZXI6IHRvZ2dsZVRpbWVyLFxuICAgIGluY3JlYXNlVGltZXI6IGluY3JlYXNlVGltZXIsXG4gICAgaXNUaW1lclJ1bm5pbmc6IGlzVGltZXJSdW5uaW5nLFxuICAgIGJpbmRDbGlja0hhbmRsZXI6IGJpbmRDbGlja0hhbmRsZXJcbiAgfSk7XG5cbiAgY2xhc3MgVGltZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLnJlbWFpbmluZyA9IGRlbGF5O1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgaWYgKCF0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5pZCA9IHNldFRpbWVvdXQodGhpcy5jYWxsYmFjaywgdGhpcy5yZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xuICAgICAgICB0aGlzLnJlbWFpbmluZyAtPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuc3RhcnRlZC5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gICAgfVxuICAgIGluY3JlYXNlKG4pIHtcbiAgICAgIGNvbnN0IHJ1bm5pbmcgPSB0aGlzLnJ1bm5pbmc7XG4gICAgICBpZiAocnVubmluZykge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtYWluaW5nICs9IG47XG4gICAgICBpZiAocnVubmluZykge1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gICAgfVxuICAgIGdldFRpbWVyTGVmdCgpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgICB9XG4gICAgaXNSdW5uaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMucnVubmluZztcbiAgICB9XG4gIH1cblxuICBjb25zdCBzd2FsU3RyaW5nUGFyYW1zID0gWydzd2FsLXRpdGxlJywgJ3N3YWwtaHRtbCcsICdzd2FsLWZvb3RlciddO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICogQHJldHVybnMge1N3ZWV0QWxlcnRPcHRpb25zfVxuICAgKi9cbiAgY29uc3QgZ2V0VGVtcGxhdGVQYXJhbXMgPSBwYXJhbXMgPT4ge1xuICAgIC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi9cbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHR5cGVvZiBwYXJhbXMudGVtcGxhdGUgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihwYXJhbXMudGVtcGxhdGUpIDogcGFyYW1zLnRlbXBsYXRlO1xuICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqL1xuICAgIGNvbnN0IHRlbXBsYXRlQ29udGVudCA9IHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgc2hvd1dhcm5pbmdzRm9yRWxlbWVudHModGVtcGxhdGVDb250ZW50KTtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKGdldFN3YWxQYXJhbXModGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbEZ1bmN0aW9uUGFyYW1zKHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxCdXR0b25zKHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxJbWFnZSh0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsSWNvbih0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsSW5wdXQodGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbFN0cmluZ1BhcmFtcyh0ZW1wbGF0ZUNvbnRlbnQsIHN3YWxTdHJpbmdQYXJhbXMpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICAgKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gICAqL1xuICBjb25zdCBnZXRTd2FsUGFyYW1zID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50W119ICovXG4gICAgY29uc3Qgc3dhbFBhcmFtcyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtcGFyYW0nKSk7XG4gICAgc3dhbFBhcmFtcy5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMocGFyYW0sIFsnbmFtZScsICd2YWx1ZSddKTtcbiAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHBhcmFtLmdldEF0dHJpYnV0ZSgnbmFtZScpO1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICBpZiAodHlwZW9mIGRlZmF1bHRQYXJhbXNbcGFyYW1OYW1lXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJlc3VsdFtwYXJhbU5hbWVdID0gdmFsdWUgIT09ICdmYWxzZSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZhdWx0UGFyYW1zW3BhcmFtTmFtZV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJlc3VsdFtwYXJhbU5hbWVdID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbcGFyYW1OYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gICAqIEByZXR1cm5zIHtTd2VldEFsZXJ0T3B0aW9uc31cbiAgICovXG4gIGNvbnN0IGdldFN3YWxGdW5jdGlvblBhcmFtcyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudFtdfSAqL1xuICAgIGNvbnN0IHN3YWxGdW5jdGlvbnMgPSBBcnJheS5mcm9tKHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzd2FsLWZ1bmN0aW9uLXBhcmFtJykpO1xuICAgIHN3YWxGdW5jdGlvbnMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgICBjb25zdCBwYXJhbU5hbWUgPSBwYXJhbS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW0uZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgcmVzdWx0W3BhcmFtTmFtZV0gPSBuZXcgRnVuY3Rpb24oYHJldHVybiAke3ZhbHVlfWApKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAgICogQHJldHVybnMge1N3ZWV0QWxlcnRPcHRpb25zfVxuICAgKi9cbiAgY29uc3QgZ2V0U3dhbEJ1dHRvbnMgPSB0ZW1wbGF0ZUNvbnRlbnQgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX0gKi9cbiAgICBjb25zdCBzd2FsQnV0dG9ucyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtYnV0dG9uJykpO1xuICAgIHN3YWxCdXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMoYnV0dG9uLCBbJ3R5cGUnLCAnY29sb3InLCAnYXJpYS1sYWJlbCddKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBidXR0b24uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICByZXN1bHRbYCR7dHlwZX1CdXR0b25UZXh0YF0gPSBidXR0b24uaW5uZXJIVE1MO1xuICAgICAgcmVzdWx0W2BzaG93JHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIodHlwZSl9QnV0dG9uYF0gPSB0cnVlO1xuICAgICAgaWYgKGJ1dHRvbi5oYXNBdHRyaWJ1dGUoJ2NvbG9yJykpIHtcbiAgICAgICAgcmVzdWx0W2Ake3R5cGV9QnV0dG9uQ29sb3JgXSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICB9XG4gICAgICBpZiAoYnV0dG9uLmhhc0F0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpKSB7XG4gICAgICAgIHJlc3VsdFtgJHt0eXBlfUJ1dHRvbkFyaWFMYWJlbGBdID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gICAqIEByZXR1cm5zIHtTd2VldEFsZXJ0T3B0aW9uc31cbiAgICovXG4gIGNvbnN0IGdldFN3YWxJbWFnZSA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICBjb25zdCBpbWFnZSA9IHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yKCdzd2FsLWltYWdlJyk7XG4gICAgaWYgKGltYWdlKSB7XG4gICAgICBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzKGltYWdlLCBbJ3NyYycsICd3aWR0aCcsICdoZWlnaHQnLCAnYWx0J10pO1xuICAgICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnc3JjJykpIHtcbiAgICAgICAgcmVzdWx0LmltYWdlVXJsID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZS5oYXNBdHRyaWJ1dGUoJ3dpZHRoJykpIHtcbiAgICAgICAgcmVzdWx0LmltYWdlV2lkdGggPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgICB9XG4gICAgICBpZiAoaW1hZ2UuaGFzQXR0cmlidXRlKCdoZWlnaHQnKSkge1xuICAgICAgICByZXN1bHQuaW1hZ2VIZWlnaHQgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICAgICAgfVxuICAgICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnYWx0JykpIHtcbiAgICAgICAgcmVzdWx0LmltYWdlQWx0ID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdhbHQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAgICogQHJldHVybnMge1N3ZWV0QWxlcnRPcHRpb25zfVxuICAgKi9cbiAgY29uc3QgZ2V0U3dhbEljb24gPSB0ZW1wbGF0ZUNvbnRlbnQgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovXG4gICAgY29uc3QgaWNvbiA9IHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yKCdzd2FsLWljb24nKTtcbiAgICBpZiAoaWNvbikge1xuICAgICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhpY29uLCBbJ3R5cGUnLCAnY29sb3InXSk7XG4gICAgICBpZiAoaWNvbi5oYXNBdHRyaWJ1dGUoJ3R5cGUnKSkge1xuICAgICAgICAvKiogQHR5cGUge1N3ZWV0QWxlcnRJY29ufSAqL1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJlc3VsdC5pY29uID0gaWNvbi5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpY29uLmhhc0F0dHJpYnV0ZSgnY29sb3InKSkge1xuICAgICAgICByZXN1bHQuaWNvbkNvbG9yID0gaWNvbi5nZXRBdHRyaWJ1dGUoJ2NvbG9yJyk7XG4gICAgICB9XG4gICAgICByZXN1bHQuaWNvbkh0bWwgPSBpY29uLmlubmVySFRNTDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAgICogQHJldHVybnMge1N3ZWV0QWxlcnRPcHRpb25zfVxuICAgKi9cbiAgY29uc3QgZ2V0U3dhbElucHV0ID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xuICAgIGNvbnN0IGlucHV0ID0gdGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3N3YWwtaW5wdXQnKTtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMoaW5wdXQsIFsndHlwZScsICdsYWJlbCcsICdwbGFjZWhvbGRlcicsICd2YWx1ZSddKTtcbiAgICAgIC8qKiBAdHlwZSB7U3dlZXRBbGVydElucHV0fSAqL1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmVzdWx0LmlucHV0ID0gaW5wdXQuZ2V0QXR0cmlidXRlKCd0eXBlJykgfHwgJ3RleHQnO1xuICAgICAgaWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgnbGFiZWwnKSkge1xuICAgICAgICByZXN1bHQuaW5wdXRMYWJlbCA9IGlucHV0LmdldEF0dHJpYnV0ZSgnbGFiZWwnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgcmVzdWx0LmlucHV0UGxhY2Vob2xkZXIgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgIHJlc3VsdC5pbnB1dFZhbHVlID0gaW5wdXQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50W119ICovXG4gICAgY29uc3QgaW5wdXRPcHRpb25zID0gQXJyYXkuZnJvbSh0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3dhbC1pbnB1dC1vcHRpb24nKSk7XG4gICAgaWYgKGlucHV0T3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5pbnB1dE9wdGlvbnMgPSB7fTtcbiAgICAgIGlucHV0T3B0aW9ucy5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMob3B0aW9uLCBbJ3ZhbHVlJ10pO1xuICAgICAgICBjb25zdCBvcHRpb25WYWx1ZSA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIGNvbnN0IG9wdGlvbk5hbWUgPSBvcHRpb24uaW5uZXJIVE1MO1xuICAgICAgICByZXN1bHQuaW5wdXRPcHRpb25zW29wdGlvblZhbHVlXSA9IG9wdGlvbk5hbWU7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1OYW1lc1xuICAgKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gICAqL1xuICBjb25zdCBnZXRTd2FsU3RyaW5nUGFyYW1zID0gKHRlbXBsYXRlQ29udGVudCwgcGFyYW1OYW1lcykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgaSBpbiBwYXJhbU5hbWVzKSB7XG4gICAgICBjb25zdCBwYXJhbU5hbWUgPSBwYXJhbU5hbWVzW2ldO1xuICAgICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICAgIGNvbnN0IHRhZyA9IHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yKHBhcmFtTmFtZSk7XG4gICAgICBpZiAodGFnKSB7XG4gICAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXModGFnLCBbXSk7XG4gICAgICAgIHJlc3VsdFtwYXJhbU5hbWUucmVwbGFjZSgvXnN3YWwtLywgJycpXSA9IHRhZy5pbm5lckhUTUwudHJpbSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICAgKi9cbiAgY29uc3Qgc2hvd1dhcm5pbmdzRm9yRWxlbWVudHMgPSB0ZW1wbGF0ZUNvbnRlbnQgPT4ge1xuICAgIGNvbnN0IGFsbG93ZWRFbGVtZW50cyA9IHN3YWxTdHJpbmdQYXJhbXMuY29uY2F0KFsnc3dhbC1wYXJhbScsICdzd2FsLWZ1bmN0aW9uLXBhcmFtJywgJ3N3YWwtYnV0dG9uJywgJ3N3YWwtaW1hZ2UnLCAnc3dhbC1pY29uJywgJ3N3YWwtaW5wdXQnLCAnc3dhbC1pbnB1dC1vcHRpb24nXSk7XG4gICAgQXJyYXkuZnJvbSh0ZW1wbGF0ZUNvbnRlbnQuY2hpbGRyZW4pLmZvckVhY2goZWwgPT4ge1xuICAgICAgY29uc3QgdGFnTmFtZSA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICghYWxsb3dlZEVsZW1lbnRzLmluY2x1ZGVzKHRhZ05hbWUpKSB7XG4gICAgICAgIHdhcm4oYFVucmVjb2duaXplZCBlbGVtZW50IDwke3RhZ05hbWV9PmApO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhbGxvd2VkQXR0cmlidXRlc1xuICAgKi9cbiAgY29uc3Qgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyA9IChlbCwgYWxsb3dlZEF0dHJpYnV0ZXMpID0+IHtcbiAgICBBcnJheS5mcm9tKGVsLmF0dHJpYnV0ZXMpLmZvckVhY2goYXR0cmlidXRlID0+IHtcbiAgICAgIGlmIChhbGxvd2VkQXR0cmlidXRlcy5pbmRleE9mKGF0dHJpYnV0ZS5uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgd2FybihbYFVucmVjb2duaXplZCBhdHRyaWJ1dGUgXCIke2F0dHJpYnV0ZS5uYW1lfVwiIG9uIDwke2VsLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0+LmAsIGAke2FsbG93ZWRBdHRyaWJ1dGVzLmxlbmd0aCA/IGBBbGxvd2VkIGF0dHJpYnV0ZXMgYXJlOiAke2FsbG93ZWRBdHRyaWJ1dGVzLmpvaW4oJywgJyl9YCA6ICdUbyBzZXQgdGhlIHZhbHVlLCB1c2UgSFRNTCB3aXRoaW4gdGhlIGVsZW1lbnQuJ31gXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3QgU0hPV19DTEFTU19USU1FT1VUID0gMTA7XG5cbiAgLyoqXG4gICAqIE9wZW4gcG9wdXAsIGFkZCBuZWNlc3NhcnkgY2xhc3NlcyBhbmQgc3R5bGVzLCBmaXggc2Nyb2xsYmFyXG4gICAqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3Qgb3BlblBvcHVwID0gcGFyYW1zID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMud2lsbE9wZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBhcmFtcy53aWxsT3Blbihwb3B1cCk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHlTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KTtcbiAgICBjb25zdCBpbml0aWFsQm9keU92ZXJmbG93ID0gYm9keVN0eWxlcy5vdmVyZmxvd1k7XG4gICAgYWRkQ2xhc3Nlcyhjb250YWluZXIsIHBvcHVwLCBwYXJhbXMpO1xuXG4gICAgLy8gc2Nyb2xsaW5nIGlzICdoaWRkZW4nIHVudGlsIGFuaW1hdGlvbiBpcyBkb25lLCBhZnRlciB0aGF0ICdhdXRvJ1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0U2Nyb2xsaW5nVmlzaWJpbGl0eShjb250YWluZXIsIHBvcHVwKTtcbiAgICB9LCBTSE9XX0NMQVNTX1RJTUVPVVQpO1xuICAgIGlmIChpc01vZGFsKCkpIHtcbiAgICAgIGZpeFNjcm9sbENvbnRhaW5lcihjb250YWluZXIsIHBhcmFtcy5zY3JvbGxiYXJQYWRkaW5nLCBpbml0aWFsQm9keU92ZXJmbG93KTtcbiAgICAgIHNldEFyaWFIaWRkZW4oKTtcbiAgICB9XG4gICAgaWYgKCFpc1RvYXN0KCkgJiYgIWdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCkge1xuICAgICAgZ2xvYmFsU3RhdGUucHJldmlvdXNBY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuZGlkT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBwYXJhbXMuZGlkT3Blbihwb3B1cCkpO1xuICAgIH1cbiAgICByZW1vdmVDbGFzcyhjb250YWluZXIsIHN3YWxDbGFzc2VzWyduby10cmFuc2l0aW9uJ10pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FuaW1hdGlvbkV2ZW50fSBldmVudFxuICAgKi9cbiAgY29uc3Qgc3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZCA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgcG9wdXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihhbmltYXRpb25FbmRFdmVudCwgc3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZCk7XG4gICAgY29udGFpbmVyLnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gICAqL1xuICBjb25zdCBzZXRTY3JvbGxpbmdWaXNpYmlsaXR5ID0gKGNvbnRhaW5lciwgcG9wdXApID0+IHtcbiAgICBpZiAoYW5pbWF0aW9uRW5kRXZlbnQgJiYgaGFzQ3NzQW5pbWF0aW9uKHBvcHVwKSkge1xuICAgICAgY29udGFpbmVyLnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nO1xuICAgICAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcihhbmltYXRpb25FbmRFdmVudCwgc3dhbE9wZW5BbmltYXRpb25GaW5pc2hlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjb250YWluZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBzY3JvbGxiYXJQYWRkaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsQm9keU92ZXJmbG93XG4gICAqL1xuICBjb25zdCBmaXhTY3JvbGxDb250YWluZXIgPSAoY29udGFpbmVyLCBzY3JvbGxiYXJQYWRkaW5nLCBpbml0aWFsQm9keU92ZXJmbG93KSA9PiB7XG4gICAgaU9TZml4KCk7XG4gICAgaWYgKHNjcm9sbGJhclBhZGRpbmcgJiYgaW5pdGlhbEJvZHlPdmVyZmxvdyAhPT0gJ2hpZGRlbicpIHtcbiAgICAgIGZpeFNjcm9sbGJhcigpO1xuICAgIH1cblxuICAgIC8vIHN3ZWV0YWxlcnQyL2lzc3Vlcy8xMjQ3XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb250YWluZXIuc2Nyb2xsVG9wID0gMDtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgYWRkQ2xhc3NlcyA9IChjb250YWluZXIsIHBvcHVwLCBwYXJhbXMpID0+IHtcbiAgICBhZGRDbGFzcyhjb250YWluZXIsIHBhcmFtcy5zaG93Q2xhc3MuYmFja2Ryb3ApO1xuICAgIC8vIHRoaXMgd29ya2Fyb3VuZCB3aXRoIG9wYWNpdHkgaXMgbmVlZGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzIwNTlcbiAgICBwb3B1cC5zdHlsZS5zZXRQcm9wZXJ0eSgnb3BhY2l0eScsICcwJywgJ2ltcG9ydGFudCcpO1xuICAgIHNob3cocG9wdXAsICdncmlkJyk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBBbmltYXRlIHBvcHVwIHJpZ2h0IGFmdGVyIHNob3dpbmcgaXRcbiAgICAgIGFkZENsYXNzKHBvcHVwLCBwYXJhbXMuc2hvd0NsYXNzLnBvcHVwKTtcbiAgICAgIC8vIGFuZCByZW1vdmUgdGhlIG9wYWNpdHkgd29ya2Fyb3VuZFxuICAgICAgcG9wdXAuc3R5bGUucmVtb3ZlUHJvcGVydHkoJ29wYWNpdHknKTtcbiAgICB9LCBTSE9XX0NMQVNTX1RJTUVPVVQpOyAvLyAxMG1zIGluIG9yZGVyIHRvIGZpeCAjMjA2MlxuXG4gICAgYWRkQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIHN3YWxDbGFzc2VzLnNob3duKTtcbiAgICBpZiAocGFyYW1zLmhlaWdodEF1dG8gJiYgcGFyYW1zLmJhY2tkcm9wICYmICFwYXJhbXMudG9hc3QpIHtcbiAgICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1snaGVpZ2h0LWF1dG8nXSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZWZhdWx0SW5wdXRWYWxpZGF0b3JzID0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdGlvbk1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkIHwgc3RyaW5nPn1cbiAgICAgKi9cbiAgICBlbWFpbDogKHN0cmluZywgdmFsaWRhdGlvbk1lc3NhZ2UpID0+IHtcbiAgICAgIHJldHVybiAvXlthLXpBLVowLTkuK18tXStAW2EtekEtWjAtOS4tXStcXC5bYS16QS1aMC05LV17MiwyNH0kLy50ZXN0KHN0cmluZykgPyBQcm9taXNlLnJlc29sdmUoKSA6IFByb21pc2UucmVzb2x2ZSh2YWxpZGF0aW9uTWVzc2FnZSB8fCAnSW52YWxpZCBlbWFpbCBhZGRyZXNzJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRpb25NZXNzYWdlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZCB8IHN0cmluZz59XG4gICAgICovXG4gICAgdXJsOiAoc3RyaW5nLCB2YWxpZGF0aW9uTWVzc2FnZSkgPT4ge1xuICAgICAgLy8gdGFrZW4gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzgwOTQzNSB3aXRoIGEgc21hbGwgY2hhbmdlIGZyb20gIzEzMDYgYW5kICMyMDEzXG4gICAgICByZXR1cm4gL15odHRwcz86XFwvXFwvKHd3d1xcLik/Wy1hLXpBLVowLTlAOiUuXyt+Iz1dezEsMjU2fVxcLlthLXpdezIsNjN9XFxiKFstYS16QS1aMC05QDolXysufiM/Ji89XSopJC8udGVzdChzdHJpbmcpID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBQcm9taXNlLnJlc29sdmUodmFsaWRhdGlvbk1lc3NhZ2UgfHwgJ0ludmFsaWQgVVJMJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIHNldERlZmF1bHRJbnB1dFZhbGlkYXRvcnMocGFyYW1zKSB7XG4gICAgLy8gVXNlIGRlZmF1bHQgYGlucHV0VmFsaWRhdG9yYCBmb3Igc3VwcG9ydGVkIGlucHV0IHR5cGVzIGlmIG5vdCBwcm92aWRlZFxuICAgIGlmICghcGFyYW1zLmlucHV0VmFsaWRhdG9yKSB7XG4gICAgICBPYmplY3Qua2V5cyhkZWZhdWx0SW5wdXRWYWxpZGF0b3JzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChwYXJhbXMuaW5wdXQgPT09IGtleSkge1xuICAgICAgICAgIHBhcmFtcy5pbnB1dFZhbGlkYXRvciA9IGRlZmF1bHRJbnB1dFZhbGlkYXRvcnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgZnVuY3Rpb24gdmFsaWRhdGVDdXN0b21UYXJnZXRFbGVtZW50KHBhcmFtcykge1xuICAgIC8vIERldGVybWluZSBpZiB0aGUgY3VzdG9tIHRhcmdldCBlbGVtZW50IGlzIHZhbGlkXG4gICAgaWYgKCFwYXJhbXMudGFyZ2V0IHx8IHR5cGVvZiBwYXJhbXMudGFyZ2V0ID09PSAnc3RyaW5nJyAmJiAhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihwYXJhbXMudGFyZ2V0KSB8fCB0eXBlb2YgcGFyYW1zLnRhcmdldCAhPT0gJ3N0cmluZycgJiYgIXBhcmFtcy50YXJnZXQuYXBwZW5kQ2hpbGQpIHtcbiAgICAgIHdhcm4oJ1RhcmdldCBwYXJhbWV0ZXIgaXMgbm90IHZhbGlkLCBkZWZhdWx0aW5nIHRvIFwiYm9keVwiJyk7XG4gICAgICBwYXJhbXMudGFyZ2V0ID0gJ2JvZHknO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdHlwZSwgdGV4dCBhbmQgYWN0aW9ucyBvbiBwb3B1cFxuICAgKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIHNldFBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgc2V0RGVmYXVsdElucHV0VmFsaWRhdG9ycyhwYXJhbXMpO1xuXG4gICAgLy8gc2hvd0xvYWRlck9uQ29uZmlybSAmJiBwcmVDb25maXJtXG4gICAgaWYgKHBhcmFtcy5zaG93TG9hZGVyT25Db25maXJtICYmICFwYXJhbXMucHJlQ29uZmlybSkge1xuICAgICAgd2Fybignc2hvd0xvYWRlck9uQ29uZmlybSBpcyBzZXQgdG8gdHJ1ZSwgYnV0IHByZUNvbmZpcm0gaXMgbm90IGRlZmluZWQuXFxuJyArICdzaG93TG9hZGVyT25Db25maXJtIHNob3VsZCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggcHJlQ29uZmlybSwgc2VlIHVzYWdlIGV4YW1wbGU6XFxuJyArICdodHRwczovL3N3ZWV0YWxlcnQyLmdpdGh1Yi5pby8jYWpheC1yZXF1ZXN0Jyk7XG4gICAgfVxuICAgIHZhbGlkYXRlQ3VzdG9tVGFyZ2V0RWxlbWVudChwYXJhbXMpO1xuXG4gICAgLy8gUmVwbGFjZSBuZXdsaW5lcyB3aXRoIDxicj4gaW4gdGl0bGVcbiAgICBpZiAodHlwZW9mIHBhcmFtcy50aXRsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBhcmFtcy50aXRsZSA9IHBhcmFtcy50aXRsZS5zcGxpdCgnXFxuJykuam9pbignPGJyIC8+Jyk7XG4gICAgfVxuICAgIGluaXQocGFyYW1zKTtcbiAgfVxuXG4gIGxldCBjdXJyZW50SW5zdGFuY2U7XG4gIGNsYXNzIFN3ZWV0QWxlcnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgLy8gUHJldmVudCBydW4gaW4gTm9kZSBlbnZcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50SW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dGVyUGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh0aGlzLmNvbnN0cnVjdG9yLmFyZ3NUb1BhcmFtcyhhcmdzKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIHZhbHVlOiBvdXRlclBhcmFtcyxcbiAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHByb21pc2UgPSBjdXJyZW50SW5zdGFuY2UuX21haW4oY3VycmVudEluc3RhbmNlLnBhcmFtcyk7XG4gICAgICBwcml2YXRlUHJvcHMucHJvbWlzZS5zZXQodGhpcywgcHJvbWlzZSk7XG4gICAgfVxuICAgIF9tYWluKHVzZXJQYXJhbXMpIHtcbiAgICAgIGxldCBtaXhpblBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICBzaG93V2FybmluZ3NGb3JQYXJhbXMoT2JqZWN0LmFzc2lnbih7fSwgbWl4aW5QYXJhbXMsIHVzZXJQYXJhbXMpKTtcbiAgICAgIGlmIChnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UuX2Rlc3Ryb3koKTtcbiAgICAgICAgaWYgKGlzTW9kYWwoKSkge1xuICAgICAgICAgIHVuc2V0QXJpYUhpZGRlbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbG9iYWxTdGF0ZS5jdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByZXBhcmVQYXJhbXModXNlclBhcmFtcywgbWl4aW5QYXJhbXMpO1xuICAgICAgc2V0UGFyYW1ldGVycyhpbm5lclBhcmFtcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGlubmVyUGFyYW1zKTtcblxuICAgICAgLy8gY2xlYXIgdGhlIHByZXZpb3VzIHRpbWVyXG4gICAgICBpZiAoZ2xvYmFsU3RhdGUudGltZW91dCkge1xuICAgICAgICBnbG9iYWxTdGF0ZS50aW1lb3V0LnN0b3AoKTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlLnRpbWVvdXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFyIHRoZSByZXN0b3JlIGZvY3VzIHRpbWVvdXRcbiAgICAgIGNsZWFyVGltZW91dChnbG9iYWxTdGF0ZS5yZXN0b3JlRm9jdXNUaW1lb3V0KTtcbiAgICAgIGNvbnN0IGRvbUNhY2hlID0gcG9wdWxhdGVEb21DYWNoZShjdXJyZW50SW5zdGFuY2UpO1xuICAgICAgcmVuZGVyKGN1cnJlbnRJbnN0YW5jZSwgaW5uZXJQYXJhbXMpO1xuICAgICAgcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLnNldChjdXJyZW50SW5zdGFuY2UsIGlubmVyUGFyYW1zKTtcbiAgICAgIHJldHVybiBzd2FsUHJvbWlzZShjdXJyZW50SW5zdGFuY2UsIGRvbUNhY2hlLCBpbm5lclBhcmFtcyk7XG4gICAgfVxuXG4gICAgLy8gYGNhdGNoYCBjYW5ub3QgYmUgdGhlIG5hbWUgb2YgYSBtb2R1bGUgZXhwb3J0LCBzbyB3ZSBkZWZpbmUgb3VyIHRoZW5hYmxlIG1ldGhvZHMgaGVyZSBpbnN0ZWFkXG4gICAgdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgICAgY29uc3QgcHJvbWlzZSA9IHByaXZhdGVQcm9wcy5wcm9taXNlLmdldCh0aGlzKTtcbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4ob25GdWxmaWxsZWQpO1xuICAgIH1cbiAgICBmaW5hbGx5KG9uRmluYWxseSkge1xuICAgICAgY29uc3QgcHJvbWlzZSA9IHByaXZhdGVQcm9wcy5wcm9taXNlLmdldCh0aGlzKTtcbiAgICAgIHJldHVybiBwcm9taXNlLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtEb21DYWNoZX0gZG9tQ2FjaGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjb25zdCBzd2FsUHJvbWlzZSA9IChpbnN0YW5jZSwgZG9tQ2FjaGUsIGlubmVyUGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIGZ1bmN0aW9ucyB0byBoYW5kbGUgYWxsIGNsb3NpbmdzL2Rpc21pc3NhbHNcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtEaXNtaXNzUmVhc29ufSBkaXNtaXNzXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRpc21pc3NXaXRoID0gZGlzbWlzcyA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaW5zdGFuY2UuY2xvc2Uoe1xuICAgICAgICAgIGlzRGlzbWlzc2VkOiB0cnVlLFxuICAgICAgICAgIGRpc21pc3NcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcHJpdmF0ZU1ldGhvZHMuc3dhbFByb21pc2VSZXNvbHZlLnNldChpbnN0YW5jZSwgcmVzb2x2ZSk7XG4gICAgICBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlamVjdC5zZXQoaW5zdGFuY2UsIHJlamVjdCk7XG4gICAgICBkb21DYWNoZS5jb25maXJtQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgIGhhbmRsZUNvbmZpcm1CdXR0b25DbGljayhpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgICAgZG9tQ2FjaGUuZGVueUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBoYW5kbGVEZW55QnV0dG9uQ2xpY2soaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICAgIGRvbUNhY2hlLmNhbmNlbEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBoYW5kbGVDYW5jZWxCdXR0b25DbGljayhpbnN0YW5jZSwgZGlzbWlzc1dpdGgpO1xuICAgICAgfTtcbiAgICAgIGRvbUNhY2hlLmNsb3NlQnV0dG9uLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZGlzbWlzc1dpdGgoRGlzbWlzc1JlYXNvbi5jbG9zZSk7XG4gICAgICB9O1xuICAgICAgaGFuZGxlUG9wdXBDbGljayhpbnN0YW5jZSwgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKTtcbiAgICAgIGFkZEtleWRvd25IYW5kbGVyKGluc3RhbmNlLCBnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKTtcbiAgICAgIGhhbmRsZUlucHV0T3B0aW9uc0FuZFZhbHVlKGluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgICBvcGVuUG9wdXAoaW5uZXJQYXJhbXMpO1xuICAgICAgc2V0dXBUaW1lcihnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKTtcbiAgICAgIGluaXRGb2N1cyhkb21DYWNoZSwgaW5uZXJQYXJhbXMpO1xuXG4gICAgICAvLyBTY3JvbGwgY29udGFpbmVyIHRvIHRvcCBvbiBvcGVuICgjMTI0NywgIzE5NDYpXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZG9tQ2FjaGUuY29udGFpbmVyLnNjcm9sbFRvcCA9IDA7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gdXNlclBhcmFtc1xuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBtaXhpblBhcmFtc1xuICAgKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gICAqL1xuICBjb25zdCBwcmVwYXJlUGFyYW1zID0gKHVzZXJQYXJhbXMsIG1peGluUGFyYW1zKSA9PiB7XG4gICAgY29uc3QgdGVtcGxhdGVQYXJhbXMgPSBnZXRUZW1wbGF0ZVBhcmFtcyh1c2VyUGFyYW1zKTtcbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyYW1zLCBtaXhpblBhcmFtcywgdGVtcGxhdGVQYXJhbXMsIHVzZXJQYXJhbXMpOyAvLyBwcmVjZWRlbmNlIGlzIGRlc2NyaWJlZCBpbiAjMjEzMVxuICAgIHBhcmFtcy5zaG93Q2xhc3MgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyYW1zLnNob3dDbGFzcywgcGFyYW1zLnNob3dDbGFzcyk7XG4gICAgcGFyYW1zLmhpZGVDbGFzcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJhbXMuaGlkZUNsYXNzLCBwYXJhbXMuaGlkZUNsYXNzKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7RG9tQ2FjaGV9XG4gICAqL1xuICBjb25zdCBwb3B1bGF0ZURvbUNhY2hlID0gaW5zdGFuY2UgPT4ge1xuICAgIGNvbnN0IGRvbUNhY2hlID0ge1xuICAgICAgcG9wdXA6IGdldFBvcHVwKCksXG4gICAgICBjb250YWluZXI6IGdldENvbnRhaW5lcigpLFxuICAgICAgYWN0aW9uczogZ2V0QWN0aW9ucygpLFxuICAgICAgY29uZmlybUJ1dHRvbjogZ2V0Q29uZmlybUJ1dHRvbigpLFxuICAgICAgZGVueUJ1dHRvbjogZ2V0RGVueUJ1dHRvbigpLFxuICAgICAgY2FuY2VsQnV0dG9uOiBnZXRDYW5jZWxCdXR0b24oKSxcbiAgICAgIGxvYWRlcjogZ2V0TG9hZGVyKCksXG4gICAgICBjbG9zZUJ1dHRvbjogZ2V0Q2xvc2VCdXR0b24oKSxcbiAgICAgIHZhbGlkYXRpb25NZXNzYWdlOiBnZXRWYWxpZGF0aW9uTWVzc2FnZSgpLFxuICAgICAgcHJvZ3Jlc3NTdGVwczogZ2V0UHJvZ3Jlc3NTdGVwcygpXG4gICAgfTtcbiAgICBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuc2V0KGluc3RhbmNlLCBkb21DYWNoZSk7XG4gICAgcmV0dXJuIGRvbUNhY2hlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0dsb2JhbFN0YXRlfSBnbG9iYWxTdGF0ZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNtaXNzV2l0aFxuICAgKi9cbiAgY29uc3Qgc2V0dXBUaW1lciA9IChnbG9iYWxTdGF0ZSwgaW5uZXJQYXJhbXMsIGRpc21pc3NXaXRoKSA9PiB7XG4gICAgY29uc3QgdGltZXJQcm9ncmVzc0JhciA9IGdldFRpbWVyUHJvZ3Jlc3NCYXIoKTtcbiAgICBoaWRlKHRpbWVyUHJvZ3Jlc3NCYXIpO1xuICAgIGlmIChpbm5lclBhcmFtcy50aW1lcikge1xuICAgICAgZ2xvYmFsU3RhdGUudGltZW91dCA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICAgIGRpc21pc3NXaXRoKCd0aW1lcicpO1xuICAgICAgICBkZWxldGUgZ2xvYmFsU3RhdGUudGltZW91dDtcbiAgICAgIH0sIGlubmVyUGFyYW1zLnRpbWVyKTtcbiAgICAgIGlmIChpbm5lclBhcmFtcy50aW1lclByb2dyZXNzQmFyKSB7XG4gICAgICAgIHNob3codGltZXJQcm9ncmVzc0Jhcik7XG4gICAgICAgIGFwcGx5Q3VzdG9tQ2xhc3ModGltZXJQcm9ncmVzc0JhciwgaW5uZXJQYXJhbXMsICd0aW1lclByb2dyZXNzQmFyJyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0ICYmIGdsb2JhbFN0YXRlLnRpbWVvdXQucnVubmluZykge1xuICAgICAgICAgICAgLy8gdGltZXIgY2FuIGJlIGFscmVhZHkgc3RvcHBlZCBvciB1bnNldCBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICBhbmltYXRlVGltZXJQcm9ncmVzc0Jhcihpbm5lclBhcmFtcy50aW1lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9tQ2FjaGV9IGRvbUNhY2hlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gICAqL1xuICBjb25zdCBpbml0Rm9jdXMgPSAoZG9tQ2FjaGUsIGlubmVyUGFyYW1zKSA9PiB7XG4gICAgaWYgKGlubmVyUGFyYW1zLnRvYXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2FsbElmRnVuY3Rpb24oaW5uZXJQYXJhbXMuYWxsb3dFbnRlcktleSkpIHtcbiAgICAgIGJsdXJBY3RpdmVFbGVtZW50KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZm9jdXNCdXR0b24oZG9tQ2FjaGUsIGlubmVyUGFyYW1zKSkge1xuICAgICAgc2V0Rm9jdXMoLTEsIDEpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtEb21DYWNoZX0gZG9tQ2FjaGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBmb2N1c0J1dHRvbiA9IChkb21DYWNoZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgICBpZiAoaW5uZXJQYXJhbXMuZm9jdXNEZW55ICYmIGlzVmlzaWJsZSQxKGRvbUNhY2hlLmRlbnlCdXR0b24pKSB7XG4gICAgICBkb21DYWNoZS5kZW55QnV0dG9uLmZvY3VzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlubmVyUGFyYW1zLmZvY3VzQ2FuY2VsICYmIGlzVmlzaWJsZSQxKGRvbUNhY2hlLmNhbmNlbEJ1dHRvbikpIHtcbiAgICAgIGRvbUNhY2hlLmNhbmNlbEJ1dHRvbi5mb2N1cygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpbm5lclBhcmFtcy5mb2N1c0NvbmZpcm0gJiYgaXNWaXNpYmxlJDEoZG9tQ2FjaGUuY29uZmlybUJ1dHRvbikpIHtcbiAgICAgIGRvbUNhY2hlLmNvbmZpcm1CdXR0b24uZm9jdXMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGNvbnN0IGJsdXJBY3RpdmVFbGVtZW50ID0gKCkgPT4ge1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdHlwZW9mIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERlYXIgcnVzc2lhbiB1c2VycyB2aXNpdGluZyBydXNzaWFuIHNpdGVzLiBMZXQncyBoYXZlIGZ1bi5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIC9ecnVcXGIvLnRlc3QobmF2aWdhdG9yLmxhbmd1YWdlKSAmJiBsb2NhdGlvbi5ob3N0Lm1hdGNoKC9cXC4ocnV8c3V8eG4tLXAxYWkpJC8pKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBpbml0aWF0aW9uRGF0ZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzd2FsLWluaXRpYXRpb24nKTtcbiAgICBpZiAoIWluaXRpYXRpb25EYXRlKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc3dhbC1pbml0aWF0aW9uJywgYCR7bm93fWApO1xuICAgIH0gZWxzZSBpZiAoKG5vdy5nZXRUaW1lKCkgLSBEYXRlLnBhcnNlKGluaXRpYXRpb25EYXRlKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkgPiAzKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICBjb25zdCB1a3JhaW5pYW5BbnRoZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICB1a3JhaW5pYW5BbnRoZW0uc3JjID0gJ2h0dHBzOi8vZmxhZy1naW1uLnJ1L3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDIxLzA5L1VrcmFpbmEubXAzJztcbiAgICAgICAgdWtyYWluaWFuQW50aGVtLmxvb3AgPSB0cnVlO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHVrcmFpbmlhbkFudGhlbSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHVrcmFpbmlhbkFudGhlbS5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIDI1MDApO1xuICAgICAgfSwgNTAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBBc3NpZ24gaW5zdGFuY2UgbWV0aG9kcyBmcm9tIHNyYy9pbnN0YW5jZU1ldGhvZHMvKi5qcyB0byBwcm90b3R5cGVcbiAgT2JqZWN0LmFzc2lnbihTd2VldEFsZXJ0LnByb3RvdHlwZSwgaW5zdGFuY2VNZXRob2RzKTtcblxuICAvLyBBc3NpZ24gc3RhdGljIG1ldGhvZHMgZnJvbSBzcmMvc3RhdGljTWV0aG9kcy8qLmpzIHRvIGNvbnN0cnVjdG9yXG4gIE9iamVjdC5hc3NpZ24oU3dlZXRBbGVydCwgc3RhdGljTWV0aG9kcyk7XG5cbiAgLy8gUHJveHkgdG8gaW5zdGFuY2UgbWV0aG9kcyB0byBjb25zdHJ1Y3RvciwgZm9yIG5vdywgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIE9iamVjdC5rZXlzKGluc3RhbmNlTWV0aG9kcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Li4uYW55fSBhcmdzXG4gICAgICogQHJldHVybnMge2FueSB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBTd2VldEFsZXJ0W2tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2Vba2V5XSguLi5hcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuICBTd2VldEFsZXJ0LkRpc21pc3NSZWFzb24gPSBEaXNtaXNzUmVhc29uO1xuICBTd2VldEFsZXJ0LnZlcnNpb24gPSAnMTEuNy4xJztcblxuICBjb25zdCBTd2FsID0gU3dlZXRBbGVydDtcbiAgLy8gQHRzLWlnbm9yZVxuICBTd2FsLmRlZmF1bHQgPSBTd2FsO1xuXG4gIHJldHVybiBTd2FsO1xuXG59KSk7XG5pZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuU3dlZXRhbGVydDIpe3RoaXMuc3dhbCA9IHRoaXMuc3dlZXRBbGVydCA9IHRoaXMuU3dhbCA9IHRoaXMuU3dlZXRBbGVydCA9IHRoaXMuU3dlZXRhbGVydDJ9XG5cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7aWYoZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQobiksbi5zdHlsZVNoZWV0KW4uc3R5bGVTaGVldC5kaXNhYmxlZHx8KG4uc3R5bGVTaGVldC5jc3NUZXh0PXQpO2Vsc2UgdHJ5e24uaW5uZXJIVE1MPXR9Y2F0Y2goZSl7bi5pbm5lclRleHQ9dH19KGRvY3VtZW50LFwiLnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0e2JveC1zaXppbmc6Ym9yZGVyLWJveDtncmlkLWNvbHVtbjoxLzQgIWltcG9ydGFudDtncmlkLXJvdzoxLzQgIWltcG9ydGFudDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6bWluLWNvbnRlbnQgYXV0byBtaW4tY29udGVudDtwYWRkaW5nOjFlbTtvdmVyZmxvdy15OmhpZGRlbjtiYWNrZ3JvdW5kOiNmZmY7Ym94LXNoYWRvdzowIDAgMXB4IHJnYmEoMCwwLDAsLjA3NSksMCAxcHggMnB4IHJnYmEoMCwwLDAsLjA3NSksMXB4IDJweCA0cHggcmdiYSgwLDAsMCwuMDc1KSwxcHggM3B4IDhweCByZ2JhKDAsMCwwLC4wNzUpLDJweCA0cHggMTZweCByZ2JhKDAsMCwwLC4wNzUpO3BvaW50ZXItZXZlbnRzOmFsbH0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3Q+KntncmlkLWNvbHVtbjoyfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItdGl0bGV7bWFyZ2luOi41ZW0gMWVtO3BhZGRpbmc6MDtmb250LXNpemU6MWVtO3RleHQtYWxpZ246aW5pdGlhbH0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWxvYWRpbmd7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWlucHV0e2hlaWdodDoyZW07bWFyZ2luOi41ZW07Zm9udC1zaXplOjFlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZXtmb250LXNpemU6MWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItZm9vdGVye21hcmdpbjouNWVtIDAgMDtwYWRkaW5nOi41ZW0gMCAwO2ZvbnQtc2l6ZTouOGVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItY2xvc2V7Z3JpZC1jb2x1bW46My8zO2dyaWQtcm93OjEvOTk7YWxpZ24tc2VsZjpjZW50ZXI7d2lkdGg6LjhlbTtoZWlnaHQ6LjhlbTttYXJnaW46MDtmb250LXNpemU6MmVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaHRtbC1jb250YWluZXJ7bWFyZ2luOi41ZW0gMWVtO3BhZGRpbmc6MDtvdmVyZmxvdzppbml0aWFsO2ZvbnQtc2l6ZToxZW07dGV4dC1hbGlnbjppbml0aWFsfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaHRtbC1jb250YWluZXI6ZW1wdHl7cGFkZGluZzowfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItbG9hZGVye2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDoyZW07aGVpZ2h0OjJlbTttYXJnaW46LjI1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29ue2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDoyZW07bWluLXdpZHRoOjJlbTtoZWlnaHQ6MmVtO21hcmdpbjowIC41ZW0gMCAwfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbiAuc3dhbDItaWNvbi1jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOjEuOGVtO2ZvbnQtd2VpZ2h0OmJvbGR9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3t3aWR0aDoyZW07aGVpZ2h0OjJlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWljb24uc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV17dG9wOi44NzVlbTt3aWR0aDoxLjM3NWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9bGVmdF17bGVmdDouMzEyNWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9cmlnaHRde3JpZ2h0Oi4zMTI1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1hY3Rpb25ze2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0O2hlaWdodDphdXRvO21hcmdpbjowO21hcmdpbi10b3A6LjVlbTtwYWRkaW5nOjAgLjVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN0eWxlZHttYXJnaW46LjI1ZW0gLjVlbTtwYWRkaW5nOi40ZW0gLjZlbTtmb250LXNpemU6MWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2Vzc3tib3JkZXItY29sb3I6I2E1ZGM4Nn0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVde3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEuNmVtO2hlaWdodDozZW07dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7Ym9yZGVyLXJhZGl1czo1MCV9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9bGVmdF17dG9wOi0wLjhlbTtsZWZ0Oi0wLjVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtLW9yaWdpbjoyZW0gMmVtO2JvcmRlci1yYWRpdXM6NGVtIDAgMCA0ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9cmlnaHRde3RvcDotMC4yNWVtO2xlZnQ6LjkzNzVlbTt0cmFuc2Zvcm0tb3JpZ2luOjAgMS41ZW07Ym9yZGVyLXJhZGl1czowIDRlbSA0ZW0gMH0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3t3aWR0aDoyZW07aGVpZ2h0OjJlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtZml4e3RvcDowO2xlZnQ6LjQzNzVlbTt3aWR0aDouNDM3NWVtO2hlaWdodDoyLjY4NzVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVde2hlaWdodDouMzEyNWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPXRpcF17dG9wOjEuMTI1ZW07bGVmdDouMTg3NWVtO3dpZHRoOi43NWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPWxvbmdde3RvcDouOTM3NWVtO3JpZ2h0Oi4xODc1ZW07d2lkdGg6MS4zNzVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3Muc3dhbDItaWNvbi1zaG93IC5zd2FsMi1zdWNjZXNzLWxpbmUtdGlwe2FuaW1hdGlvbjpzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXAgLjc1c30uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3Muc3dhbDItaWNvbi1zaG93IC5zd2FsMi1zdWNjZXNzLWxpbmUtbG9uZ3thbmltYXRpb246c3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZyAuNzVzfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdC5zd2FsMi1zaG93e2FuaW1hdGlvbjpzd2FsMi10b2FzdC1zaG93IC41c30uc3dhbDItcG9wdXAuc3dhbDItdG9hc3Quc3dhbDItaGlkZXthbmltYXRpb246c3dhbDItdG9hc3QtaGlkZSAuMXMgZm9yd2FyZHN9LnN3YWwyLWNvbnRhaW5lcntkaXNwbGF5OmdyaWQ7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoxMDYwO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO2JveC1zaXppbmc6Ym9yZGVyLWJveDtncmlkLXRlbXBsYXRlLWFyZWFzOlxcXCJ0b3Atc3RhcnQgICAgIHRvcCAgICAgICAgICAgIHRvcC1lbmRcXFwiIFxcXCJjZW50ZXItc3RhcnQgIGNlbnRlciAgICAgICAgIGNlbnRlci1lbmRcXFwiIFxcXCJib3R0b20tc3RhcnQgIGJvdHRvbS1jZW50ZXIgIGJvdHRvbS1lbmRcXFwiO2dyaWQtdGVtcGxhdGUtcm93czptaW5tYXgobWluLWNvbnRlbnQsIGF1dG8pIG1pbm1heChtaW4tY29udGVudCwgYXV0bykgbWlubWF4KG1pbi1jb250ZW50LCBhdXRvKTtoZWlnaHQ6MTAwJTtwYWRkaW5nOi42MjVlbTtvdmVyZmxvdy14OmhpZGRlbjt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjFzOy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNofS5zd2FsMi1jb250YWluZXIuc3dhbDItYmFja2Ryb3Atc2hvdywuc3dhbDItY29udGFpbmVyLnN3YWwyLW5vYW5pbWF0aW9ue2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuNCl9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1iYWNrZHJvcC1oaWRle2JhY2tncm91bmQ6cmdiYSgwLDAsMCwwKSAhaW1wb3J0YW50fS5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXN0YXJ0LC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXN0YXJ0LC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXN0YXJ0e2dyaWQtdGVtcGxhdGUtY29sdW1uczptaW5tYXgoMCwgMWZyKSBhdXRvIGF1dG99LnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3AsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXIsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b217Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOmF1dG8gbWlubWF4KDAsIDFmcikgYXV0b30uc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1lbmQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItZW5kLC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLWVuZHtncmlkLXRlbXBsYXRlLWNvbHVtbnM6YXV0byBhdXRvIG1pbm1heCgwLCAxZnIpfS5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXN0YXJ0Pi5zd2FsMi1wb3B1cHthbGlnbi1zZWxmOnN0YXJ0fS5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoyO2FsaWduLXNlbGY6c3RhcnQ7anVzdGlmeS1zZWxmOmNlbnRlcn0uc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1lbmQ+LnN3YWwyLXBvcHVwLC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXJpZ2h0Pi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjozO2FsaWduLXNlbGY6c3RhcnQ7anVzdGlmeS1zZWxmOmVuZH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1zdGFydD4uc3dhbDItcG9wdXAsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItbGVmdD4uc3dhbDItcG9wdXB7Z3JpZC1yb3c6MjthbGlnbi1zZWxmOmNlbnRlcn0uc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlcj4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MjtncmlkLXJvdzoyO2FsaWduLXNlbGY6Y2VudGVyO2p1c3RpZnktc2VsZjpjZW50ZXJ9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItZW5kPi5zd2FsMi1wb3B1cCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1yaWdodD4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MztncmlkLXJvdzoyO2FsaWduLXNlbGY6Y2VudGVyO2p1c3RpZnktc2VsZjplbmR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tc3RhcnQ+LnN3YWwyLXBvcHVwLC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLWxlZnQ+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MzthbGlnbi1zZWxmOmVuZH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbT4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MjtncmlkLXJvdzozO2p1c3RpZnktc2VsZjpjZW50ZXI7YWxpZ24tc2VsZjplbmR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tZW5kPi5zd2FsMi1wb3B1cCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1yaWdodD4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MztncmlkLXJvdzozO2FsaWduLXNlbGY6ZW5kO2p1c3RpZnktc2VsZjplbmR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LXJvdz4uc3dhbDItcG9wdXAsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LWZ1bGxzY3JlZW4+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjEvNDt3aWR0aDoxMDAlfS5zd2FsMi1jb250YWluZXIuc3dhbDItZ3Jvdy1jb2x1bW4+LnN3YWwyLXBvcHVwLC5zd2FsMi1jb250YWluZXIuc3dhbDItZ3Jvdy1mdWxsc2NyZWVuPi5zd2FsMi1wb3B1cHtncmlkLXJvdzoxLzQ7YWxpZ24tc2VsZjpzdHJldGNofS5zd2FsMi1jb250YWluZXIuc3dhbDItbm8tdHJhbnNpdGlvbnt0cmFuc2l0aW9uOm5vbmUgIWltcG9ydGFudH0uc3dhbDItcG9wdXB7ZGlzcGxheTpub25lO3Bvc2l0aW9uOnJlbGF0aXZlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6bWlubWF4KDAsIDEwMCUpO3dpZHRoOjMyZW07bWF4LXdpZHRoOjEwMCU7cGFkZGluZzowIDAgMS4yNWVtO2JvcmRlcjpub25lO2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6I2ZmZjtjb2xvcjojNTQ1NDU0O2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOjFyZW19LnN3YWwyLXBvcHVwOmZvY3Vze291dGxpbmU6bm9uZX0uc3dhbDItcG9wdXAuc3dhbDItbG9hZGluZ3tvdmVyZmxvdy15OmhpZGRlbn0uc3dhbDItdGl0bGV7cG9zaXRpb246cmVsYXRpdmU7bWF4LXdpZHRoOjEwMCU7bWFyZ2luOjA7cGFkZGluZzouOGVtIDFlbSAwO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuODc1ZW07Zm9udC13ZWlnaHQ6NjAwO3RleHQtYWxpZ246Y2VudGVyO3RleHQtdHJhbnNmb3JtOm5vbmU7d29yZC13cmFwOmJyZWFrLXdvcmR9LnN3YWwyLWFjdGlvbnN7ZGlzcGxheTpmbGV4O3otaW5kZXg6MTtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZmxleC13cmFwOndyYXA7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6YXV0bzttYXJnaW46MS4yNWVtIGF1dG8gMDtwYWRkaW5nOjB9LnN3YWwyLWFjdGlvbnM6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkW2Rpc2FibGVkXXtvcGFjaXR5Oi40fS5zd2FsMi1hY3Rpb25zOm5vdCguc3dhbDItbG9hZGluZykgLnN3YWwyLXN0eWxlZDpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudChyZ2JhKDAsIDAsIDAsIDAuMSksIHJnYmEoMCwgMCwgMCwgMC4xKSl9LnN3YWwyLWFjdGlvbnM6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkOmFjdGl2ZXtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudChyZ2JhKDAsIDAsIDAsIDAuMiksIHJnYmEoMCwgMCwgMCwgMC4yKSl9LnN3YWwyLWxvYWRlcntkaXNwbGF5Om5vbmU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6Mi4yZW07aGVpZ2h0OjIuMmVtO21hcmdpbjowIDEuODc1ZW07YW5pbWF0aW9uOnN3YWwyLXJvdGF0ZS1sb2FkaW5nIDEuNXMgbGluZWFyIDBzIGluZmluaXRlIG5vcm1hbDtib3JkZXItd2lkdGg6LjI1ZW07Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci1yYWRpdXM6MTAwJTtib3JkZXItY29sb3I6IzI3NzhjNCByZ2JhKDAsMCwwLDApICMyNzc4YzQgcmdiYSgwLDAsMCwwKX0uc3dhbDItc3R5bGVke21hcmdpbjouMzEyNWVtO3BhZGRpbmc6LjYyNWVtIDEuMWVtO3RyYW5zaXRpb246Ym94LXNoYWRvdyAuMXM7Ym94LXNoYWRvdzowIDAgMCAzcHggcmdiYSgwLDAsMCwwKTtmb250LXdlaWdodDo1MDB9LnN3YWwyLXN0eWxlZDpub3QoW2Rpc2FibGVkXSl7Y3Vyc29yOnBvaW50ZXJ9LnN3YWwyLXN0eWxlZC5zd2FsMi1jb25maXJte2JvcmRlcjowO2JvcmRlci1yYWRpdXM6LjI1ZW07YmFja2dyb3VuZDppbml0aWFsO2JhY2tncm91bmQtY29sb3I6IzcwNjZlMDtjb2xvcjojZmZmO2ZvbnQtc2l6ZToxZW19LnN3YWwyLXN0eWxlZC5zd2FsMi1jb25maXJtOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgM3B4IHJnYmEoMTEyLDEwMiwyMjQsLjUpfS5zd2FsMi1zdHlsZWQuc3dhbDItZGVueXtib3JkZXI6MDtib3JkZXItcmFkaXVzOi4yNWVtO2JhY2tncm91bmQ6aW5pdGlhbDtiYWNrZ3JvdW5kLWNvbG9yOiNkYzM3NDE7Y29sb3I6I2ZmZjtmb250LXNpemU6MWVtfS5zd2FsMi1zdHlsZWQuc3dhbDItZGVueTpmb2N1c3tib3gtc2hhZG93OjAgMCAwIDNweCByZ2JhKDIyMCw1NSw2NSwuNSl9LnN3YWwyLXN0eWxlZC5zd2FsMi1jYW5jZWx7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czouMjVlbTtiYWNrZ3JvdW5kOmluaXRpYWw7YmFja2dyb3VuZC1jb2xvcjojNmU3ODgxO2NvbG9yOiNmZmY7Zm9udC1zaXplOjFlbX0uc3dhbDItc3R5bGVkLnN3YWwyLWNhbmNlbDpmb2N1c3tib3gtc2hhZG93OjAgMCAwIDNweCByZ2JhKDExMCwxMjAsMTI5LC41KX0uc3dhbDItc3R5bGVkLnN3YWwyLWRlZmF1bHQtb3V0bGluZTpmb2N1c3tib3gtc2hhZG93OjAgMCAwIDNweCByZ2JhKDEwMCwxNTAsMjAwLC41KX0uc3dhbDItc3R5bGVkOmZvY3Vze291dGxpbmU6bm9uZX0uc3dhbDItc3R5bGVkOjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowfS5zd2FsMi1mb290ZXJ7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW46MWVtIDAgMDtwYWRkaW5nOjFlbSAxZW0gMDtib3JkZXItdG9wOjFweCBzb2xpZCAjZWVlO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjFlbX0uc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDtncmlkLWNvbHVtbjphdXRvICFpbXBvcnRhbnQ7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjVweDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjVweH0uc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFye3dpZHRoOjEwMCU7aGVpZ2h0Oi4yNWVtO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMil9LnN3YWwyLWltYWdle21heC13aWR0aDoxMDAlO21hcmdpbjoyZW0gYXV0byAxZW19LnN3YWwyLWNsb3Nle3otaW5kZXg6MjthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDoxLjJlbTtoZWlnaHQ6MS4yZW07bWFyZ2luLXRvcDowO21hcmdpbi1yaWdodDowO21hcmdpbi1ib3R0b206LTEuMmVtO3BhZGRpbmc6MDtvdmVyZmxvdzpoaWRkZW47dHJhbnNpdGlvbjpjb2xvciAuMXMsYm94LXNoYWRvdyAuMXM7Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApO2NvbG9yOiNjY2M7Zm9udC1mYW1pbHk6c2VyaWY7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO2ZvbnQtc2l6ZToyLjVlbTtjdXJzb3I6cG9pbnRlcjtqdXN0aWZ5LXNlbGY6ZW5kfS5zd2FsMi1jbG9zZTpob3Zlcnt0cmFuc2Zvcm06bm9uZTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMCk7Y29sb3I6I2YyNzQ3NH0uc3dhbDItY2xvc2U6Zm9jdXN7b3V0bGluZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgM3B4IHJnYmEoMTAwLDE1MCwyMDAsLjUpfS5zd2FsMi1jbG9zZTo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH0uc3dhbDItaHRtbC1jb250YWluZXJ7ei1pbmRleDoxO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjFlbSAxLjZlbSAuM2VtO3BhZGRpbmc6MDtvdmVyZmxvdzphdXRvO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuMTI1ZW07Zm9udC13ZWlnaHQ6bm9ybWFsO2xpbmUtaGVpZ2h0Om5vcm1hbDt0ZXh0LWFsaWduOmNlbnRlcjt3b3JkLXdyYXA6YnJlYWstd29yZDt3b3JkLWJyZWFrOmJyZWFrLXdvcmR9LnN3YWwyLWlucHV0LC5zd2FsMi1maWxlLC5zd2FsMi10ZXh0YXJlYSwuc3dhbDItc2VsZWN0LC5zd2FsMi1yYWRpbywuc3dhbDItY2hlY2tib3h7bWFyZ2luOjFlbSAyZW0gM3B4fS5zd2FsMi1pbnB1dCwuc3dhbDItZmlsZSwuc3dhbDItdGV4dGFyZWF7Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOmF1dG87dHJhbnNpdGlvbjpib3JkZXItY29sb3IgLjFzLGJveC1zaGFkb3cgLjFzO2JvcmRlcjoxcHggc29saWQgI2Q5ZDlkOTtib3JkZXItcmFkaXVzOi4xODc1ZW07YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjA2KSwwIDAgMCAzcHggcmdiYSgwLDAsMCwwKTtjb2xvcjppbmhlcml0O2ZvbnQtc2l6ZToxLjEyNWVtfS5zd2FsMi1pbnB1dC5zd2FsMi1pbnB1dGVycm9yLC5zd2FsMi1maWxlLnN3YWwyLWlucHV0ZXJyb3IsLnN3YWwyLXRleHRhcmVhLnN3YWwyLWlucHV0ZXJyb3J7Ym9yZGVyLWNvbG9yOiNmMjc0NzQgIWltcG9ydGFudDtib3gtc2hhZG93OjAgMCAycHggI2YyNzQ3NCAhaW1wb3J0YW50fS5zd2FsMi1pbnB1dDpmb2N1cywuc3dhbDItZmlsZTpmb2N1cywuc3dhbDItdGV4dGFyZWE6Zm9jdXN7Ym9yZGVyOjFweCBzb2xpZCAjYjRkYmVkO291dGxpbmU6bm9uZTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4wNiksMCAwIDAgM3B4IHJnYmEoMTAwLDE1MCwyMDAsLjUpfS5zd2FsMi1pbnB1dDo6cGxhY2Vob2xkZXIsLnN3YWwyLWZpbGU6OnBsYWNlaG9sZGVyLC5zd2FsMi10ZXh0YXJlYTo6cGxhY2Vob2xkZXJ7Y29sb3I6I2NjY30uc3dhbDItcmFuZ2V7bWFyZ2luOjFlbSAyZW0gM3B4O2JhY2tncm91bmQ6I2ZmZn0uc3dhbDItcmFuZ2UgaW5wdXR7d2lkdGg6ODAlfS5zd2FsMi1yYW5nZSBvdXRwdXR7d2lkdGg6MjAlO2NvbG9yOmluaGVyaXQ7Zm9udC13ZWlnaHQ6NjAwO3RleHQtYWxpZ246Y2VudGVyfS5zd2FsMi1yYW5nZSBpbnB1dCwuc3dhbDItcmFuZ2Ugb3V0cHV0e2hlaWdodDoyLjYyNWVtO3BhZGRpbmc6MDtmb250LXNpemU6MS4xMjVlbTtsaW5lLWhlaWdodDoyLjYyNWVtfS5zd2FsMi1pbnB1dHtoZWlnaHQ6Mi42MjVlbTtwYWRkaW5nOjAgLjc1ZW19LnN3YWwyLWZpbGV7d2lkdGg6NzUlO21hcmdpbi1yaWdodDphdXRvO21hcmdpbi1sZWZ0OmF1dG87YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApO2ZvbnQtc2l6ZToxLjEyNWVtfS5zd2FsMi10ZXh0YXJlYXtoZWlnaHQ6Ni43NWVtO3BhZGRpbmc6Ljc1ZW19LnN3YWwyLXNlbGVjdHttaW4td2lkdGg6NTAlO21heC13aWR0aDoxMDAlO3BhZGRpbmc6LjM3NWVtIC42MjVlbTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMCk7Y29sb3I6aW5oZXJpdDtmb250LXNpemU6MS4xMjVlbX0uc3dhbDItcmFkaW8sLnN3YWwyLWNoZWNrYm94e2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JhY2tncm91bmQ6I2ZmZjtjb2xvcjppbmhlcml0fS5zd2FsMi1yYWRpbyBsYWJlbCwuc3dhbDItY2hlY2tib3ggbGFiZWx7bWFyZ2luOjAgLjZlbTtmb250LXNpemU6MS4xMjVlbX0uc3dhbDItcmFkaW8gaW5wdXQsLnN3YWwyLWNoZWNrYm94IGlucHV0e2ZsZXgtc2hyaW5rOjA7bWFyZ2luOjAgLjRlbX0uc3dhbDItaW5wdXQtbGFiZWx7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjFlbSBhdXRvIDB9LnN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZXthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW46MWVtIDAgMDtwYWRkaW5nOi42MjVlbTtvdmVyZmxvdzpoaWRkZW47YmFja2dyb3VuZDojZjBmMGYwO2NvbG9yOiM2NjY7Zm9udC1zaXplOjFlbTtmb250LXdlaWdodDozMDB9LnN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZTo6YmVmb3Jle2NvbnRlbnQ6XFxcIiFcXFwiO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjEuNWVtO21pbi13aWR0aDoxLjVlbTtoZWlnaHQ6MS41ZW07bWFyZ2luOjAgLjYyNWVtO2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQtY29sb3I6I2YyNzQ3NDtjb2xvcjojZmZmO2ZvbnQtd2VpZ2h0OjYwMDtsaW5lLWhlaWdodDoxLjVlbTt0ZXh0LWFsaWduOmNlbnRlcn0uc3dhbDItaWNvbntwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6NWVtO2hlaWdodDo1ZW07bWFyZ2luOjIuNWVtIGF1dG8gLjZlbTtib3JkZXI6MC4yNWVtIHNvbGlkIHJnYmEoMCwwLDAsMCk7Ym9yZGVyLXJhZGl1czo1MCU7Ym9yZGVyLWNvbG9yOiMwMDA7Zm9udC1mYW1pbHk6aW5oZXJpdDtsaW5lLWhlaWdodDo1ZW07Y3Vyc29yOmRlZmF1bHQ7dXNlci1zZWxlY3Q6bm9uZX0uc3dhbDItaWNvbiAuc3dhbDItaWNvbi1jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOjMuNzVlbX0uc3dhbDItaWNvbi5zd2FsMi1lcnJvcntib3JkZXItY29sb3I6I2YyNzQ3NDtjb2xvcjojZjI3NDc0fS5zd2FsMi1pY29uLnN3YWwyLWVycm9yIC5zd2FsMi14LW1hcmt7cG9zaXRpb246cmVsYXRpdmU7ZmxleC1ncm93OjF9LnN3YWwyLWljb24uc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV17ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6Mi4zMTI1ZW07d2lkdGg6Mi45Mzc1ZW07aGVpZ2h0Oi4zMTI1ZW07Ym9yZGVyLXJhZGl1czouMTI1ZW07YmFja2dyb3VuZC1jb2xvcjojZjI3NDc0fS5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVdW2NsYXNzJD1sZWZ0XXtsZWZ0OjEuMDYyNWVtO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVdW2NsYXNzJD1yaWdodF17cmlnaHQ6MWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1lcnJvci5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9LnN3YWwyLWljb24uc3dhbDItZXJyb3Iuc3dhbDItaWNvbi1zaG93IC5zd2FsMi14LW1hcmt7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3IteC1tYXJrIC41c30uc3dhbDItaWNvbi5zd2FsMi13YXJuaW5ne2JvcmRlci1jb2xvcjojZmFjZWE4O2NvbG9yOiNmOGJiODZ9LnN3YWwyLWljb24uc3dhbDItd2FybmluZy5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9LnN3YWwyLWljb24uc3dhbDItd2FybmluZy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLWljb24tY29udGVudHthbmltYXRpb246c3dhbDItYW5pbWF0ZS1pLW1hcmsgLjVzfS5zd2FsMi1pY29uLnN3YWwyLWluZm97Ym9yZGVyLWNvbG9yOiM5ZGUwZjY7Y29sb3I6IzNmYzNlZX0uc3dhbDItaWNvbi5zd2FsMi1pbmZvLnN3YWwyLWljb24tc2hvd3thbmltYXRpb246c3dhbDItYW5pbWF0ZS1lcnJvci1pY29uIC41c30uc3dhbDItaWNvbi5zd2FsMi1pbmZvLnN3YWwyLWljb24tc2hvdyAuc3dhbDItaWNvbi1jb250ZW50e2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWktbWFyayAuOHN9LnN3YWwyLWljb24uc3dhbDItcXVlc3Rpb257Ym9yZGVyLWNvbG9yOiNjOWRhZTE7Y29sb3I6Izg3YWRiZH0uc3dhbDItaWNvbi5zd2FsMi1xdWVzdGlvbi5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9LnN3YWwyLWljb24uc3dhbDItcXVlc3Rpb24uc3dhbDItaWNvbi1zaG93IC5zd2FsMi1pY29uLWNvbnRlbnR7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtcXVlc3Rpb24tbWFyayAuOHN9LnN3YWwyLWljb24uc3dhbDItc3VjY2Vzc3tib3JkZXItY29sb3I6I2E1ZGM4Njtjb2xvcjojYTVkYzg2fS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVde3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjMuNzVlbTtoZWlnaHQ6Ny41ZW07dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7Ym9yZGVyLXJhZGl1czo1MCV9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPWxlZnRde3RvcDotMC40Mzc1ZW07bGVmdDotMi4wNjM1ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybS1vcmlnaW46My43NWVtIDMuNzVlbTtib3JkZXItcmFkaXVzOjcuNWVtIDAgMCA3LjVlbX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9cmlnaHRde3RvcDotMC42ODc1ZW07bGVmdDoxLjg3NWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm0tb3JpZ2luOjAgMy43NWVtO2JvcmRlci1yYWRpdXM6MCA3LjVlbSA3LjVlbSAwfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3twb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjI7dG9wOi0wLjI1ZW07bGVmdDotMC4yNWVtO2JveC1zaXppbmc6Y29udGVudC1ib3g7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3JkZXI6LjI1ZW0gc29saWQgcmdiYSgxNjUsMjIwLDEzNCwuMyk7Ym9yZGVyLXJhZGl1czo1MCV9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyAuc3dhbDItc3VjY2Vzcy1maXh7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxO3RvcDouNWVtO2xlZnQ6MS42MjVlbTt3aWR0aDouNDM3NWVtO2hlaWdodDo1LjYyNWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXXtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MjtoZWlnaHQ6LjMxMjVlbTtib3JkZXItcmFkaXVzOi4xMjVlbTtiYWNrZ3JvdW5kLWNvbG9yOiNhNWRjODZ9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPXRpcF17dG9wOjIuODc1ZW07bGVmdDouODEyNWVtO3dpZHRoOjEuNTYyNWVtO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD1sb25nXXt0b3A6Mi4zNzVlbTtyaWdodDouNWVtO3dpZHRoOjIuOTM3NWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1saW5lLXRpcHthbmltYXRpb246c3dhbDItYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwIC43NXN9LnN3YWwyLWljb24uc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtbGluZS1sb25ne2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nIC43NXN9LnN3YWwyLWljb24uc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZS1yaWdodHthbmltYXRpb246c3dhbDItcm90YXRlLXN1Y2Nlc3MtY2lyY3VsYXItbGluZSA0LjI1cyBlYXNlLWlufS5zd2FsMi1wcm9ncmVzcy1zdGVwc3tmbGV4LXdyYXA6d3JhcDthbGlnbi1pdGVtczpjZW50ZXI7bWF4LXdpZHRoOjEwMCU7bWFyZ2luOjEuMjVlbSBhdXRvO3BhZGRpbmc6MDtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMCk7Zm9udC13ZWlnaHQ6NjAwfS5zd2FsMi1wcm9ncmVzcy1zdGVwcyBsaXtkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0uc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXB7ei1pbmRleDoyMDtmbGV4LXNocmluazowO3dpZHRoOjJlbTtoZWlnaHQ6MmVtO2JvcmRlci1yYWRpdXM6MmVtO2JhY2tncm91bmQ6IzI3NzhjNDtjb2xvcjojZmZmO2xpbmUtaGVpZ2h0OjJlbTt0ZXh0LWFsaWduOmNlbnRlcn0uc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXAuc3dhbDItYWN0aXZlLXByb2dyZXNzLXN0ZXB7YmFja2dyb3VuZDojMjc3OGM0fS5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcC5zd2FsMi1hY3RpdmUtcHJvZ3Jlc3Mtc3RlcH4uc3dhbDItcHJvZ3Jlc3Mtc3RlcHtiYWNrZ3JvdW5kOiNhZGQ4ZTY7Y29sb3I6I2ZmZn0uc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXAuc3dhbDItYWN0aXZlLXByb2dyZXNzLXN0ZXB+LnN3YWwyLXByb2dyZXNzLXN0ZXAtbGluZXtiYWNrZ3JvdW5kOiNhZGQ4ZTZ9LnN3YWwyLXByb2dyZXNzLXN0ZXBzIC5zd2FsMi1wcm9ncmVzcy1zdGVwLWxpbmV7ei1pbmRleDoxMDtmbGV4LXNocmluazowO3dpZHRoOjIuNWVtO2hlaWdodDouNGVtO21hcmdpbjowIC0xcHg7YmFja2dyb3VuZDojMjc3OGM0fVtjbGFzc149c3dhbDJdey13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjpyZ2JhKDAsMCwwLDApfS5zd2FsMi1zaG93e2FuaW1hdGlvbjpzd2FsMi1zaG93IC4zc30uc3dhbDItaGlkZXthbmltYXRpb246c3dhbDItaGlkZSAuMTVzIGZvcndhcmRzfS5zd2FsMi1ub2FuaW1hdGlvbnt0cmFuc2l0aW9uOm5vbmV9LnN3YWwyLXNjcm9sbGJhci1tZWFzdXJle3Bvc2l0aW9uOmFic29sdXRlO3RvcDotOTk5OXB4O3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7b3ZlcmZsb3c6c2Nyb2xsfS5zd2FsMi1ydGwgLnN3YWwyLWNsb3Nle21hcmdpbi1yaWdodDppbml0aWFsO21hcmdpbi1sZWZ0OjB9LnN3YWwyLXJ0bCAuc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFye3JpZ2h0OjA7bGVmdDphdXRvfUBrZXlmcmFtZXMgc3dhbDItdG9hc3Qtc2hvd3swJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMC42MjVlbSkgcm90YXRlWigyZGVnKX0zMyV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCkgcm90YXRlWigtMmRlZyl9NjYle3RyYW5zZm9ybTp0cmFuc2xhdGVZKDAuMzEyNWVtKSByb3RhdGVaKDJkZWcpfTEwMCV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCkgcm90YXRlWigwZGVnKX19QGtleWZyYW1lcyBzd2FsMi10b2FzdC1oaWRlezEwMCV7dHJhbnNmb3JtOnJvdGF0ZVooMWRlZyk7b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIHN3YWwyLXRvYXN0LWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcHswJXt0b3A6LjU2MjVlbTtsZWZ0Oi4wNjI1ZW07d2lkdGg6MH01NCV7dG9wOi4xMjVlbTtsZWZ0Oi4xMjVlbTt3aWR0aDowfTcwJXt0b3A6LjYyNWVtO2xlZnQ6LTAuMjVlbTt3aWR0aDoxLjYyNWVtfTg0JXt0b3A6MS4wNjI1ZW07bGVmdDouNzVlbTt3aWR0aDouNWVtfTEwMCV7dG9wOjEuMTI1ZW07bGVmdDouMTg3NWVtO3dpZHRoOi43NWVtfX1Aa2V5ZnJhbWVzIHN3YWwyLXRvYXN0LWFuaW1hdGUtc3VjY2Vzcy1saW5lLWxvbmd7MCV7dG9wOjEuNjI1ZW07cmlnaHQ6MS4zNzVlbTt3aWR0aDowfTY1JXt0b3A6MS4yNWVtO3JpZ2h0Oi45Mzc1ZW07d2lkdGg6MH04NCV7dG9wOi45Mzc1ZW07cmlnaHQ6MDt3aWR0aDoxLjEyNWVtfTEwMCV7dG9wOi45Mzc1ZW07cmlnaHQ6LjE4NzVlbTt3aWR0aDoxLjM3NWVtfX1Aa2V5ZnJhbWVzIHN3YWwyLXNob3d7MCV7dHJhbnNmb3JtOnNjYWxlKDAuNyl9NDUle3RyYW5zZm9ybTpzY2FsZSgxLjA1KX04MCV7dHJhbnNmb3JtOnNjYWxlKDAuOTUpfTEwMCV7dHJhbnNmb3JtOnNjYWxlKDEpfX1Aa2V5ZnJhbWVzIHN3YWwyLWhpZGV7MCV7dHJhbnNmb3JtOnNjYWxlKDEpO29wYWNpdHk6MX0xMDAle3RyYW5zZm9ybTpzY2FsZSgwLjUpO29wYWNpdHk6MH19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXB7MCV7dG9wOjEuMTg3NWVtO2xlZnQ6LjA2MjVlbTt3aWR0aDowfTU0JXt0b3A6MS4wNjI1ZW07bGVmdDouMTI1ZW07d2lkdGg6MH03MCV7dG9wOjIuMTg3NWVtO2xlZnQ6LTAuMzc1ZW07d2lkdGg6My4xMjVlbX04NCV7dG9wOjNlbTtsZWZ0OjEuMzEyNWVtO3dpZHRoOjEuMDYyNWVtfTEwMCV7dG9wOjIuODEyNWVtO2xlZnQ6LjgxMjVlbTt3aWR0aDoxLjU2MjVlbX19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nezAle3RvcDozLjM3NWVtO3JpZ2h0OjIuODc1ZW07d2lkdGg6MH02NSV7dG9wOjMuMzc1ZW07cmlnaHQ6Mi44NzVlbTt3aWR0aDowfTg0JXt0b3A6Mi4xODc1ZW07cmlnaHQ6MDt3aWR0aDozLjQzNzVlbX0xMDAle3RvcDoyLjM3NWVtO3JpZ2h0Oi41ZW07d2lkdGg6Mi45Mzc1ZW19fUBrZXlmcmFtZXMgc3dhbDItcm90YXRlLXN1Y2Nlc3MtY2lyY3VsYXItbGluZXswJXt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9NSV7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfTEyJXt0cmFuc2Zvcm06cm90YXRlKC00MDVkZWcpfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgtNDA1ZGVnKX19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLWVycm9yLXgtbWFya3swJXttYXJnaW4tdG9wOjEuNjI1ZW07dHJhbnNmb3JtOnNjYWxlKDAuNCk7b3BhY2l0eTowfTUwJXttYXJnaW4tdG9wOjEuNjI1ZW07dHJhbnNmb3JtOnNjYWxlKDAuNCk7b3BhY2l0eTowfTgwJXttYXJnaW4tdG9wOi0wLjM3NWVtO3RyYW5zZm9ybTpzY2FsZSgxLjE1KX0xMDAle21hcmdpbi10b3A6MDt0cmFuc2Zvcm06c2NhbGUoMSk7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbnswJXt0cmFuc2Zvcm06cm90YXRlWCgxMDBkZWcpO29wYWNpdHk6MH0xMDAle3RyYW5zZm9ybTpyb3RhdGVYKDBkZWcpO29wYWNpdHk6MX19QGtleWZyYW1lcyBzd2FsMi1yb3RhdGUtbG9hZGluZ3swJXt0cmFuc2Zvcm06cm90YXRlKDBkZWcpfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtcXVlc3Rpb24tbWFya3swJXt0cmFuc2Zvcm06cm90YXRlWSgtMzYwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGVZKDApfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtaS1tYXJrezAle3RyYW5zZm9ybTpyb3RhdGVaKDQ1ZGVnKTtvcGFjaXR5OjB9MjUle3RyYW5zZm9ybTpyb3RhdGVaKC0yNWRlZyk7b3BhY2l0eTouNH01MCV7dHJhbnNmb3JtOnJvdGF0ZVooMTVkZWcpO29wYWNpdHk6Ljh9NzUle3RyYW5zZm9ybTpyb3RhdGVaKC01ZGVnKTtvcGFjaXR5OjF9MTAwJXt0cmFuc2Zvcm06cm90YXRlWCgwKTtvcGFjaXR5OjF9fWJvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCk6bm90KC5zd2FsMi10b2FzdC1zaG93bil7b3ZlcmZsb3c6aGlkZGVufWJvZHkuc3dhbDItaGVpZ2h0LWF1dG97aGVpZ2h0OmF1dG8gIWltcG9ydGFudH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLDApICFpbXBvcnRhbnQ7cG9pbnRlci1ldmVudHM6bm9uZX1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIgLnN3YWwyLXBvcHVwe3BvaW50ZXItZXZlbnRzOmFsbH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIgLnN3YWwyLW1vZGFse2JveC1zaGFkb3c6MCAwIDEwcHggcmdiYSgwLDAsMCwuNCl9QG1lZGlhIHByaW50e2JvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCk6bm90KC5zd2FsMi10b2FzdC1zaG93bil7b3ZlcmZsb3cteTpzY3JvbGwgIWltcG9ydGFudH1ib2R5LnN3YWwyLXNob3duOm5vdCguc3dhbDItbm8tYmFja2Ryb3ApOm5vdCguc3dhbDItdG9hc3Qtc2hvd24pPlthcmlhLWhpZGRlbj10cnVlXXtkaXNwbGF5Om5vbmV9Ym9keS5zd2FsMi1zaG93bjpub3QoLnN3YWwyLW5vLWJhY2tkcm9wKTpub3QoLnN3YWwyLXRvYXN0LXNob3duKSAuc3dhbDItY29udGFpbmVye3Bvc2l0aW9uOnN0YXRpYyAhaW1wb3J0YW50fX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXJ7Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOjM2MHB4O21heC13aWR0aDoxMDAlO2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwwKTtwb2ludGVyLWV2ZW50czpub25lfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3B7dG9wOjA7cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLWVuZCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXJpZ2h0e3RvcDowO3JpZ2h0OjA7Ym90dG9tOmF1dG87bGVmdDphdXRvfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3Atc3RhcnQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1sZWZ0e3RvcDowO3JpZ2h0OmF1dG87Ym90dG9tOmF1dG87bGVmdDowfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItc3RhcnQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1sZWZ0e3RvcDo1MCU7cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlcnt0b3A6NTAlO3JpZ2h0OmF1dG87Ym90dG9tOmF1dG87bGVmdDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLCAtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLWVuZCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXJpZ2h0e3RvcDo1MCU7cmlnaHQ6MDtib3R0b206YXV0bztsZWZ0OmF1dG87dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1zdGFydCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLWxlZnR7dG9wOmF1dG87cmlnaHQ6YXV0bztib3R0b206MDtsZWZ0OjB9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbXt0b3A6YXV0bztyaWdodDphdXRvO2JvdHRvbTowO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tZW5kLGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tcmlnaHR7dG9wOmF1dG87cmlnaHQ6MDtib3R0b206MDtsZWZ0OmF1dG99XCIpOyJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImdsb2JhbFRoaXMiLCJzZWxmIiwiU3dlZXRhbGVydDIiLCJwcml2YXRlUHJvcHMiLCJhd2FpdGluZ1Byb21pc2UiLCJXZWFrTWFwIiwicHJvbWlzZSIsImlubmVyUGFyYW1zIiwiZG9tQ2FjaGUiLCJzd2FsUHJlZml4IiwicHJlZml4IiwiaXRlbXMiLCJyZXN1bHQiLCJpIiwic3dhbENsYXNzZXMiLCJpY29uVHlwZXMiLCJjb25zb2xlUHJlZml4IiwidW5pcXVlQXJyYXkiLCJhcnIiLCJsZW5ndGgiLCJpbmRleE9mIiwicHVzaCIsImNhcGl0YWxpemVGaXJzdExldHRlciIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ3YXJuIiwibWVzc2FnZSIsImNvbnNvbGUiLCJqb2luIiwiZXJyb3IiLCJwcmV2aW91c1dhcm5PbmNlTWVzc2FnZXMiLCJ3YXJuT25jZSIsImluY2x1ZGVzIiwid2FybkFib3V0RGVwcmVjYXRpb24iLCJkZXByZWNhdGVkUGFyYW0iLCJ1c2VJbnN0ZWFkIiwiY2FsbElmRnVuY3Rpb24iLCJhcmciLCJoYXNUb1Byb21pc2VGbiIsInRvUHJvbWlzZSIsImFzUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaXNQcm9taXNlIiwiZ2V0Q29udGFpbmVyIiwiZG9jdW1lbnQiLCJib2R5IiwicXVlcnlTZWxlY3RvciIsImNvbnRhaW5lciIsImVsZW1lbnRCeVNlbGVjdG9yIiwic2VsZWN0b3JTdHJpbmciLCJlbGVtZW50QnlDbGFzcyIsImNsYXNzTmFtZSIsImdldFBvcHVwIiwicG9wdXAiLCJnZXRJY29uIiwiaWNvbiIsImdldEljb25Db250ZW50IiwiZ2V0VGl0bGUiLCJ0aXRsZSIsImdldEh0bWxDb250YWluZXIiLCJnZXRJbWFnZSIsImltYWdlIiwiZ2V0UHJvZ3Jlc3NTdGVwcyIsImdldFZhbGlkYXRpb25NZXNzYWdlIiwiZ2V0Q29uZmlybUJ1dHRvbiIsImFjdGlvbnMiLCJjb25maXJtIiwiZ2V0Q2FuY2VsQnV0dG9uIiwiY2FuY2VsIiwiZ2V0RGVueUJ1dHRvbiIsImRlbnkiLCJnZXRJbnB1dExhYmVsIiwiZ2V0TG9hZGVyIiwibG9hZGVyIiwiZ2V0QWN0aW9ucyIsImdldEZvb3RlciIsImZvb3RlciIsImdldFRpbWVyUHJvZ3Jlc3NCYXIiLCJnZXRDbG9zZUJ1dHRvbiIsImNsb3NlIiwiZm9jdXNhYmxlIiwiZ2V0Rm9jdXNhYmxlRWxlbWVudHMiLCJmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleCIsIkFycmF5IiwiZnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzb3J0IiwiYSIsImIiLCJ0YWJpbmRleEEiLCJwYXJzZUludCIsImdldEF0dHJpYnV0ZSIsInRhYmluZGV4QiIsIm90aGVyRm9jdXNhYmxlRWxlbWVudHMiLCJmaWx0ZXIiLCJlbCIsImNvbmNhdCIsImlzVmlzaWJsZSQxIiwiaXNNb2RhbCIsImhhc0NsYXNzIiwic2hvd24iLCJpc1RvYXN0IiwidG9hc3QiLCJpc0xvYWRpbmciLCJoYXNBdHRyaWJ1dGUiLCJzdGF0ZXMiLCJwcmV2aW91c0JvZHlQYWRkaW5nIiwic2V0SW5uZXJIdG1sIiwiZWxlbSIsImh0bWwiLCJ0ZXh0Q29udGVudCIsInBhcnNlciIsIkRPTVBhcnNlciIsInBhcnNlZCIsInBhcnNlRnJvbVN0cmluZyIsImNoaWxkTm9kZXMiLCJmb3JFYWNoIiwiY2hpbGQiLCJhcHBlbmRDaGlsZCIsIkhUTUxWaWRlb0VsZW1lbnQiLCJIVE1MQXVkaW9FbGVtZW50IiwiY2xvbmVOb2RlIiwiY2xhc3NMaXN0Iiwic3BsaXQiLCJjb250YWlucyIsInJlbW92ZUN1c3RvbUNsYXNzZXMiLCJwYXJhbXMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJzaG93Q2xhc3MiLCJyZW1vdmUiLCJhcHBseUN1c3RvbUNsYXNzIiwiY3VzdG9tQ2xhc3MiLCJhZGRDbGFzcyIsImdldElucHV0JDEiLCJpbnB1dENsYXNzIiwiY2hlY2tib3giLCJyYWRpbyIsInJhbmdlIiwiaW5wdXQiLCJmb2N1c0lucHV0IiwiZm9jdXMiLCJ0eXBlIiwidmFsIiwidmFsdWUiLCJ0b2dnbGVDbGFzcyIsInRhcmdldCIsImNvbmRpdGlvbiIsIkJvb2xlYW4iLCJpc0FycmF5IiwiYWRkIiwicmVtb3ZlQ2xhc3MiLCJnZXREaXJlY3RDaGlsZEJ5Q2xhc3MiLCJjaGlsZHJlbiIsIkhUTUxFbGVtZW50IiwiYXBwbHlOdW1lcmljYWxTdHlsZSIsInByb3BlcnR5Iiwic3R5bGUiLCJyZW1vdmVQcm9wZXJ0eSIsInNob3ciLCJkaXNwbGF5IiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiaGlkZSIsInNldFN0eWxlIiwicGFyZW50Iiwic2VsZWN0b3IiLCJ0b2dnbGUiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImdldENsaWVudFJlY3RzIiwiYWxsQnV0dG9uc0FyZUhpZGRlbiIsImlzU2Nyb2xsYWJsZSIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImhhc0Nzc0FuaW1hdGlvbiIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJhbmltRHVyYXRpb24iLCJwYXJzZUZsb2F0IiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRyYW5zRHVyYXRpb24iLCJhbmltYXRlVGltZXJQcm9ncmVzc0JhciIsInRpbWVyIiwicmVzZXQiLCJ0aW1lclByb2dyZXNzQmFyIiwidHJhbnNpdGlvbiIsIndpZHRoIiwic2V0VGltZW91dCIsInN0b3BUaW1lclByb2dyZXNzQmFyIiwidGltZXJQcm9ncmVzc0JhcldpZHRoIiwidGltZXJQcm9ncmVzc0JhckZ1bGxXaWR0aCIsInRpbWVyUHJvZ3Jlc3NCYXJQZXJjZW50IiwiUkVTVE9SRV9GT0NVU19USU1FT1VUIiwiZ2xvYmFsU3RhdGUiLCJmb2N1c1ByZXZpb3VzQWN0aXZlRWxlbWVudCIsInByZXZpb3VzQWN0aXZlRWxlbWVudCIsInJlc3RvcmVBY3RpdmVFbGVtZW50IiwicmV0dXJuRm9jdXMiLCJ4Iiwic2Nyb2xsWCIsInkiLCJzY3JvbGxZIiwicmVzdG9yZUZvY3VzVGltZW91dCIsInNjcm9sbFRvIiwiaXNOb2RlRW52Iiwic3dlZXRIVE1MIiwiZmlsZSIsInNlbGVjdCIsImxhYmVsIiwidGV4dGFyZWEiLCJyZXBsYWNlIiwicmVzZXRPbGRDb250YWluZXIiLCJvbGRDb250YWluZXIiLCJkb2N1bWVudEVsZW1lbnQiLCJyZXNldFZhbGlkYXRpb25NZXNzYWdlJDEiLCJjdXJyZW50SW5zdGFuY2UiLCJyZXNldFZhbGlkYXRpb25NZXNzYWdlIiwiYWRkSW5wdXRDaGFuZ2VMaXN0ZW5lcnMiLCJyYW5nZU91dHB1dCIsIm9uaW5wdXQiLCJvbmNoYW5nZSIsImdldFRhcmdldCIsInNldHVwQWNjZXNzaWJpbGl0eSIsInNldEF0dHJpYnV0ZSIsInNldHVwUlRMIiwidGFyZ2V0RWxlbWVudCIsImRpcmVjdGlvbiIsInJ0bCIsImluaXQiLCJvbGRDb250YWluZXJFeGlzdGVkIiwiY3JlYXRlRWxlbWVudCIsInBhcnNlSHRtbFRvQ29udGFpbmVyIiwicGFyYW0iLCJoYW5kbGVPYmplY3QiLCJqcXVlcnkiLCJoYW5kbGVKcXVlcnlFbGVtIiwidG9TdHJpbmciLCJhbmltYXRpb25FbmRFdmVudCIsInRlc3RFbCIsInRyYW5zRW5kRXZlbnROYW1lcyIsIldlYmtpdEFuaW1hdGlvbiIsImFuaW1hdGlvbiIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm1lYXN1cmVTY3JvbGxiYXIiLCJzY3JvbGxEaXYiLCJzY3JvbGxiYXJXaWR0aCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFdpZHRoIiwicmVtb3ZlQ2hpbGQiLCJyZW5kZXJBY3Rpb25zIiwiaW5zdGFuY2UiLCJzaG93Q29uZmlybUJ1dHRvbiIsInNob3dEZW55QnV0dG9uIiwic2hvd0NhbmNlbEJ1dHRvbiIsInJlbmRlckJ1dHRvbnMiLCJsb2FkZXJIdG1sIiwiY29uZmlybUJ1dHRvbiIsImRlbnlCdXR0b24iLCJjYW5jZWxCdXR0b24iLCJyZW5kZXJCdXR0b24iLCJoYW5kbGVCdXR0b25zU3R5bGluZyIsInJldmVyc2VCdXR0b25zIiwiaW5zZXJ0QmVmb3JlIiwiYnV0dG9uc1N0eWxpbmciLCJzdHlsZWQiLCJjb25maXJtQnV0dG9uQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJkZW55QnV0dG9uQ29sb3IiLCJjYW5jZWxCdXR0b25Db2xvciIsImJ1dHRvbiIsImJ1dHRvblR5cGUiLCJyZW5kZXJDbG9zZUJ1dHRvbiIsImNsb3NlQnV0dG9uIiwiY2xvc2VCdXR0b25IdG1sIiwic2hvd0Nsb3NlQnV0dG9uIiwiY2xvc2VCdXR0b25BcmlhTGFiZWwiLCJyZW5kZXJDb250YWluZXIiLCJoYW5kbGVCYWNrZHJvcFBhcmFtIiwiYmFja2Ryb3AiLCJoYW5kbGVQb3NpdGlvblBhcmFtIiwicG9zaXRpb24iLCJoYW5kbGVHcm93UGFyYW0iLCJncm93IiwiYmFja2dyb3VuZCIsImNlbnRlciIsImdyb3dDbGFzcyIsImlucHV0Q2xhc3NlcyIsInJlbmRlcklucHV0IiwiZ2V0IiwicmVyZW5kZXIiLCJpbnB1dENvbnRhaW5lciIsInNldEF0dHJpYnV0ZXMiLCJpbnB1dEF0dHJpYnV0ZXMiLCJzaG93SW5wdXQiLCJzZXRDdXN0b21DbGFzcyIsInJlbmRlcklucHV0VHlwZSIsImdldElucHV0Q29udGFpbmVyIiwiaW5wdXRBdXRvRm9jdXMiLCJyZW1vdmVBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsImF0dHJOYW1lIiwibmFtZSIsInJlbW92ZUF0dHJpYnV0ZSIsImF0dHIiLCJzZXRJbnB1dFBsYWNlaG9sZGVyIiwicGxhY2Vob2xkZXIiLCJpbnB1dFBsYWNlaG9sZGVyIiwic2V0SW5wdXRMYWJlbCIsInByZXBlbmRUbyIsImlucHV0TGFiZWwiLCJpZCIsImxhYmVsQ2xhc3MiLCJpbm5lclRleHQiLCJpbnNlcnRBZGphY2VudEVsZW1lbnQiLCJpbnB1dFR5cGUiLCJjaGVja0FuZFNldElucHV0VmFsdWUiLCJpbnB1dFZhbHVlIiwidGV4dCIsImVtYWlsIiwicGFzc3dvcmQiLCJudW1iZXIiLCJ0ZWwiLCJ1cmwiLCJyYW5nZUlucHV0IiwiZGlzYWJsZWQiLCJzZWxlY3RlZCIsImNoZWNrYm94Q29udGFpbmVyIiwiY2hlY2tlZCIsImdldE1hcmdpbiIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsImluaXRpYWxQb3B1cFdpZHRoIiwidGV4dGFyZWFSZXNpemVIYW5kbGVyIiwidGV4dGFyZWFXaWR0aCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYXR0cmlidXRlRmlsdGVyIiwicmVuZGVyQ29udGVudCIsImh0bWxDb250YWluZXIiLCJyZW5kZXJGb290ZXIiLCJyZW5kZXJJY29uIiwic2V0Q29udGVudCIsImFwcGx5U3R5bGVzIiwiaWNvbkh0bWwiLCJrZXlzIiwiaWNvblR5cGUiLCJzZXRDb2xvciIsImFkanVzdFN1Y2Nlc3NJY29uQmFja2dyb3VuZENvbG9yIiwicG9wdXBCYWNrZ3JvdW5kQ29sb3IiLCJzdWNjZXNzSWNvblBhcnRzIiwic3VjY2Vzc0ljb25IdG1sIiwiZXJyb3JJY29uSHRtbCIsIm9sZENvbnRlbnQiLCJpbm5lckhUTUwiLCJuZXdDb250ZW50IiwiaWNvbkNvbnRlbnQiLCJkZWZhdWx0SWNvbkh0bWwiLCJxdWVzdGlvbiIsIndhcm5pbmciLCJpbmZvIiwidHJpbSIsImljb25Db2xvciIsImNvbG9yIiwiYm9yZGVyQ29sb3IiLCJzZWwiLCJjb250ZW50IiwicmVuZGVySW1hZ2UiLCJpbWFnZVVybCIsImltYWdlQWx0IiwiaW1hZ2VXaWR0aCIsImltYWdlSGVpZ2h0IiwicmVuZGVyUG9wdXAiLCJwYWRkaW5nIiwiYWRkQ2xhc3NlcyQxIiwibW9kYWwiLCJyZW5kZXJQcm9ncmVzc1N0ZXBzIiwicHJvZ3Jlc3NTdGVwc0NvbnRhaW5lciIsInByb2dyZXNzU3RlcHMiLCJjdXJyZW50UHJvZ3Jlc3NTdGVwIiwic3RlcCIsImluZGV4Iiwic3RlcEVsIiwiY3JlYXRlU3RlcEVsZW1lbnQiLCJsaW5lRWwiLCJjcmVhdGVMaW5lRWxlbWVudCIsInByb2dyZXNzU3RlcHNEaXN0YW5jZSIsInJlbmRlclRpdGxlIiwidGl0bGVUZXh0IiwicmVuZGVyIiwiZGlkUmVuZGVyIiwiaGlkZUxvYWRpbmciLCJzaG93UmVsYXRlZEJ1dHRvbiIsImxvYWRpbmciLCJidXR0b25Ub1JlcGxhY2UiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiZ2V0SW5wdXQiLCJpc1Zpc2libGUiLCJjbGlja0NvbmZpcm0iLCJjbGljayIsImNsaWNrRGVueSIsImNsaWNrQ2FuY2VsIiwiRGlzbWlzc1JlYXNvbiIsImZyZWV6ZSIsImVzYyIsInJlbW92ZUtleWRvd25IYW5kbGVyIiwia2V5ZG93blRhcmdldCIsImtleWRvd25IYW5kbGVyQWRkZWQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwia2V5ZG93bkhhbmRsZXIiLCJjYXB0dXJlIiwia2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSIsImFkZEtleWRvd25IYW5kbGVyIiwiZGlzbWlzc1dpdGgiLCJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNldEZvY3VzIiwiaW5jcmVtZW50IiwiZm9jdXNhYmxlRWxlbWVudHMiLCJhcnJvd0tleXNOZXh0QnV0dG9uIiwiYXJyb3dLZXlzUHJldmlvdXNCdXR0b24iLCJldmVudCIsImlzQ29tcG9zaW5nIiwia2V5Q29kZSIsInN0b3BLZXlkb3duUHJvcGFnYXRpb24iLCJzdG9wUHJvcGFnYXRpb24iLCJrZXkiLCJoYW5kbGVFbnRlciIsImhhbmRsZVRhYiIsImhhbmRsZUFycm93cyIsImhhbmRsZUVzYyIsImFsbG93RW50ZXJLZXkiLCJvdXRlckhUTUwiLCJwcmV2ZW50RGVmYXVsdCIsImJ0bkluZGV4Iiwic2hpZnRLZXkiLCJidXR0b25zIiwiYWN0aXZlRWxlbWVudCIsInNpYmxpbmciLCJidXR0b25Ub0ZvY3VzIiwiSFRNTEJ1dHRvbkVsZW1lbnQiLCJhbGxvd0VzY2FwZUtleSIsInByaXZhdGVNZXRob2RzIiwic3dhbFByb21pc2VSZXNvbHZlIiwic3dhbFByb21pc2VSZWplY3QiLCJzZXRBcmlhSGlkZGVuIiwiYm9keUNoaWxkcmVuIiwidW5zZXRBcmlhSGlkZGVuIiwiaU9TZml4IiwiaU9TIiwidGVzdCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIk1TU3RyZWFtIiwicGxhdGZvcm0iLCJtYXhUb3VjaFBvaW50cyIsImlvc2ZpeCIsIm9mZnNldCIsInNjcm9sbFRvcCIsInRvcCIsImxvY2tCb2R5U2Nyb2xsIiwiYWRkQm90dG9tUGFkZGluZ0ZvclRhbGxQb3B1cHMiLCJ1YSIsIm1hdGNoIiwid2Via2l0IiwiaU9TU2FmYXJpIiwiYm90dG9tUGFuZWxIZWlnaHQiLCJpbm5lckhlaWdodCIsInBhZGRpbmdCb3R0b20iLCJwcmV2ZW50VG91Y2hNb3ZlIiwib250b3VjaHN0YXJ0Iiwic2hvdWxkUHJldmVudFRvdWNoTW92ZSIsIm9udG91Y2htb3ZlIiwiaXNTdHlsdXMiLCJpc1pvb20iLCJ0YWdOYW1lIiwidG91Y2hlcyIsInRvdWNoVHlwZSIsInVuZG9JT1NmaXgiLCJmaXhTY3JvbGxiYXIiLCJwYWRkaW5nUmlnaHQiLCJ1bmRvU2Nyb2xsYmFyIiwicmVtb3ZlUG9wdXBBbmRSZXNldFN0YXRlIiwiZGlkQ2xvc2UiLCJ0cmlnZ2VyRGlkQ2xvc2VBbmREaXNwb3NlIiwidGhlbiIsImlzU2FmYXJpIiwicmVtb3ZlQm9keUNsYXNzZXMiLCJyZXNvbHZlVmFsdWUiLCJwcmVwYXJlUmVzb2x2ZVZhbHVlIiwidHJpZ2dlckNsb3NlUG9wdXAiLCJpc0F3YWl0aW5nUHJvbWlzZSIsImlzRGlzbWlzc2VkIiwiaGFuZGxlQXdhaXRpbmdQcm9taXNlIiwiaGlkZUNsYXNzIiwiaGFuZGxlUG9wdXBBbmltYXRpb24iLCJyZWplY3RQcm9taXNlIiwiZGVsZXRlIiwiX2Rlc3Ryb3kiLCJpc0NvbmZpcm1lZCIsImlzRGVuaWVkIiwiYXNzaWduIiwiYW5pbWF0aW9uSXNTdXBwb3J0ZWQiLCJ3aWxsQ2xvc2UiLCJhbmltYXRlUG9wdXAiLCJzd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2siLCJiaW5kIiwic2V0QnV0dG9uc0Rpc2FibGVkIiwic2V0SW5wdXREaXNhYmxlZCIsInJhZGlvc0NvbnRhaW5lciIsInBhcmVudE5vZGUiLCJyYWRpb3MiLCJlbmFibGVCdXR0b25zIiwiZGlzYWJsZUJ1dHRvbnMiLCJlbmFibGVJbnB1dCIsImRpc2FibGVJbnB1dCIsInNob3dWYWxpZGF0aW9uTWVzc2FnZSIsInZhbGlkYXRpb25NZXNzYWdlIiwiaW5wdXRlcnJvciIsImRlZmF1bHRQYXJhbXMiLCJ0ZW1wbGF0ZSIsImhlaWdodEF1dG8iLCJhbGxvd091dHNpZGVDbGljayIsInByZUNvbmZpcm0iLCJwcmVEZW55IiwiY29uZmlybUJ1dHRvblRleHQiLCJjb25maXJtQnV0dG9uQXJpYUxhYmVsIiwiZGVueUJ1dHRvblRleHQiLCJkZW55QnV0dG9uQXJpYUxhYmVsIiwiY2FuY2VsQnV0dG9uVGV4dCIsImNhbmNlbEJ1dHRvbkFyaWFMYWJlbCIsImZvY3VzQ29uZmlybSIsImZvY3VzRGVueSIsImZvY3VzQ2FuY2VsIiwic2hvd0xvYWRlck9uQ29uZmlybSIsInNob3dMb2FkZXJPbkRlbnkiLCJpbnB1dE9wdGlvbnMiLCJpbnB1dEF1dG9UcmltIiwiaW5wdXRWYWxpZGF0b3IiLCJyZXR1cm5JbnB1dFZhbHVlT25EZW55Iiwid2lsbE9wZW4iLCJkaWRPcGVuIiwiZGlkRGVzdHJveSIsInNjcm9sbGJhclBhZGRpbmciLCJ1cGRhdGFibGVQYXJhbXMiLCJkZXByZWNhdGVkUGFyYW1zIiwidG9hc3RJbmNvbXBhdGlibGVQYXJhbXMiLCJpc1ZhbGlkUGFyYW1ldGVyIiwicGFyYW1OYW1lIiwiaXNVcGRhdGFibGVQYXJhbWV0ZXIiLCJpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIiLCJjaGVja0lmUGFyYW1Jc1ZhbGlkIiwiY2hlY2tJZlRvYXN0UGFyYW1Jc1ZhbGlkIiwiY2hlY2tJZlBhcmFtSXNEZXByZWNhdGVkIiwic2hvd1dhcm5pbmdzRm9yUGFyYW1zIiwidXBkYXRlIiwidmFsaWRVcGRhdGFibGVQYXJhbXMiLCJmaWx0ZXJWYWxpZFBhcmFtcyIsInVwZGF0ZWRQYXJhbXMiLCJzZXQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiZGlzcG9zZVdlYWtNYXBzIiwiZGlzcG9zZVN3YWwiLCJ1bnNldFdlYWtNYXBzIiwib2JqIiwiaW5zdGFuY2VNZXRob2RzIiwiX19wcm90b19fIiwiZGlzYWJsZUxvYWRpbmciLCJjbG9zZVBvcHVwIiwiY2xvc2VNb2RhbCIsImNsb3NlVG9hc3QiLCJzaG93TG9hZGluZyIsIlN3YWwiLCJyZXBsYWNlQnV0dG9uIiwiaGFuZGxlSW5wdXRPcHRpb25zQW5kVmFsdWUiLCJoYW5kbGVJbnB1dE9wdGlvbnMiLCJoYW5kbGVJbnB1dFZhbHVlIiwiZ2V0SW5wdXRWYWx1ZSIsImdldENoZWNrYm94VmFsdWUiLCJnZXRSYWRpb1ZhbHVlIiwiZ2V0RmlsZVZhbHVlIiwiZmlsZXMiLCJwcm9jZXNzSW5wdXRPcHRpb25zIiwicG9wdWxhdGVJbnB1dE9wdGlvbnMiLCJmb3JtYXRJbnB1dE9wdGlvbnMiLCJjYXRjaCIsImVyciIsInJlbmRlck9wdGlvbiIsIm9wdGlvbkxhYmVsIiwib3B0aW9uVmFsdWUiLCJvcHRpb24iLCJpc1NlbGVjdGVkIiwiaW5wdXRPcHRpb24iLCJvcHRncm91cCIsIm8iLCJyYWRpb1ZhbHVlIiwicmFkaW9MYWJlbCIsInJhZGlvSW5wdXQiLCJyYWRpb0xhYmVsRWxlbWVudCIsIk1hcCIsInZhbHVlRm9ybWF0dGVkIiwiaGFuZGxlQ29uZmlybUJ1dHRvbkNsaWNrIiwiaGFuZGxlQ29uZmlybU9yRGVueVdpdGhJbnB1dCIsImhhbmRsZURlbnlCdXR0b25DbGljayIsImhhbmRsZUNhbmNlbEJ1dHRvbkNsaWNrIiwiaGFuZGxlSW5wdXRWYWxpZGF0b3IiLCJjaGVja1ZhbGlkaXR5IiwidmFsaWRhdGlvblByb21pc2UiLCJwcmVEZW55UHJvbWlzZSIsInByZURlbnlWYWx1ZSIsInJlamVjdFdpdGgiLCJzdWNjZWVkV2l0aCIsInByZUNvbmZpcm1Qcm9taXNlIiwicHJlQ29uZmlybVZhbHVlIiwiaGFuZGxlUG9wdXBDbGljayIsImhhbmRsZVRvYXN0Q2xpY2siLCJoYW5kbGVNb2RhbE1vdXNlZG93biIsImhhbmRsZUNvbnRhaW5lck1vdXNlZG93biIsImhhbmRsZU1vZGFsQ2xpY2siLCJvbmNsaWNrIiwiaXNBbnlCdXR0b25TaG93biIsImlnbm9yZU91dHNpZGVDbGljayIsIm9ubW91c2Vkb3duIiwib25tb3VzZXVwIiwiaXNKcXVlcnlFbGVtZW50IiwiaXNFbGVtZW50IiwiRWxlbWVudCIsImFyZ3NUb1BhcmFtcyIsImFyZ3MiLCJmaXJlIiwiX2xlbiIsIl9rZXkiLCJtaXhpbiIsIm1peGluUGFyYW1zIiwiTWl4aW5Td2FsIiwiX21haW4iLCJwcmlvcml0eU1peGluUGFyYW1zIiwiZ2V0VGltZXJMZWZ0IiwidGltZW91dCIsInN0b3BUaW1lciIsInN0b3AiLCJyZXN1bWVUaW1lciIsInJlbWFpbmluZyIsInN0YXJ0IiwidG9nZ2xlVGltZXIiLCJydW5uaW5nIiwiaW5jcmVhc2VUaW1lciIsIm4iLCJpbmNyZWFzZSIsImlzVGltZXJSdW5uaW5nIiwiaXNSdW5uaW5nIiwiYm9keUNsaWNrTGlzdGVuZXJBZGRlZCIsImNsaWNrSGFuZGxlcnMiLCJiaW5kQ2xpY2tIYW5kbGVyIiwiYm9keUNsaWNrTGlzdGVuZXIiLCJzdGF0aWNNZXRob2RzIiwiZW5hYmxlTG9hZGluZyIsIlRpbWVyIiwiY29uc3RydWN0b3IiLCJjYWxsYmFjayIsImRlbGF5Iiwic3RhcnRlZCIsIkRhdGUiLCJjbGVhclRpbWVvdXQiLCJnZXRUaW1lIiwic3dhbFN0cmluZ1BhcmFtcyIsImdldFRlbXBsYXRlUGFyYW1zIiwidGVtcGxhdGVDb250ZW50Iiwic2hvd1dhcm5pbmdzRm9yRWxlbWVudHMiLCJnZXRTd2FsUGFyYW1zIiwiZ2V0U3dhbEZ1bmN0aW9uUGFyYW1zIiwiZ2V0U3dhbEJ1dHRvbnMiLCJnZXRTd2FsSW1hZ2UiLCJnZXRTd2FsSWNvbiIsImdldFN3YWxJbnB1dCIsImdldFN3YWxTdHJpbmdQYXJhbXMiLCJzd2FsUGFyYW1zIiwic2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyIsIkpTT04iLCJwYXJzZSIsInN3YWxGdW5jdGlvbnMiLCJGdW5jdGlvbiIsInN3YWxCdXR0b25zIiwib3B0aW9uTmFtZSIsInBhcmFtTmFtZXMiLCJ0YWciLCJhbGxvd2VkRWxlbWVudHMiLCJ0b0xvd2VyQ2FzZSIsImFsbG93ZWRBdHRyaWJ1dGVzIiwiYXR0cmlidXRlIiwiU0hPV19DTEFTU19USU1FT1VUIiwib3BlblBvcHVwIiwiYm9keVN0eWxlcyIsImluaXRpYWxCb2R5T3ZlcmZsb3ciLCJvdmVyZmxvd1kiLCJhZGRDbGFzc2VzIiwic2V0U2Nyb2xsaW5nVmlzaWJpbGl0eSIsImZpeFNjcm9sbENvbnRhaW5lciIsInN3YWxPcGVuQW5pbWF0aW9uRmluaXNoZWQiLCJzZXRQcm9wZXJ0eSIsImRlZmF1bHRJbnB1dFZhbGlkYXRvcnMiLCJzdHJpbmciLCJzZXREZWZhdWx0SW5wdXRWYWxpZGF0b3JzIiwidmFsaWRhdGVDdXN0b21UYXJnZXRFbGVtZW50Iiwic2V0UGFyYW1ldGVycyIsIlN3ZWV0QWxlcnQiLCJvdXRlclBhcmFtcyIsImNvbmZpZ3VyYWJsZSIsInVzZXJQYXJhbXMiLCJwcmVwYXJlUGFyYW1zIiwicG9wdWxhdGVEb21DYWNoZSIsInN3YWxQcm9taXNlIiwib25GdWxmaWxsZWQiLCJmaW5hbGx5Iiwib25GaW5hbGx5IiwicmVqZWN0IiwiZGlzbWlzcyIsInNldHVwVGltZXIiLCJpbml0Rm9jdXMiLCJ0ZW1wbGF0ZVBhcmFtcyIsImJsdXJBY3RpdmVFbGVtZW50IiwiZm9jdXNCdXR0b24iLCJibHVyIiwibGFuZ3VhZ2UiLCJsb2NhdGlvbiIsImhvc3QiLCJub3ciLCJpbml0aWF0aW9uRGF0ZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZXRJdGVtIiwicG9pbnRlckV2ZW50cyIsInVrcmFpbmlhbkFudGhlbSIsInNyYyIsImxvb3AiLCJwbGF5IiwidmVyc2lvbiIsImRlZmF1bHQiLCJzd2FsIiwic3dlZXRBbGVydCIsInQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlU2hlZXQiLCJjc3NUZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sweetalert2/dist/sweetalert2.all.js\n");

/***/ })

};
;